diff --git a/build/declarations/loading2/octree-geometry-node.d.ts b/build/declarations/loading2/octree-geometry-node.d.ts
index 9b5c9aa42c762e18b99bd574d5fd783f4dd5d636..0eda42de27382e44b3d0d919ba654dc17380eb96 100644
--- a/build/declarations/loading2/octree-geometry-node.d.ts
+++ b/build/declarations/loading2/octree-geometry-node.d.ts
@@ -1,15 +1,16 @@
 import { Box3, BufferGeometry, Sphere } from 'three';
-import { IPointCloudTreeNode } from '../types';
+import { IPointCloudGeometryNode } from '../types';
 import { OctreeGeometry } from './octree-geometry';
-export declare class OctreeGeometryNode implements IPointCloudTreeNode {
+export declare class OctreeGeometryNode implements IPointCloudGeometryNode {
     name: string;
     octreeGeometry: OctreeGeometry;
     boundingBox: Box3;
     constructor(name: string, octreeGeometry: OctreeGeometry, boundingBox: Box3);
     loaded: boolean;
     loading: boolean;
+    failed: boolean;
     parent: OctreeGeometryNode | null;
-    geometry: BufferGeometry | null;
+    geometry: BufferGeometry | undefined;
     nodeType?: number;
     byteOffset?: bigint;
     byteSize?: bigint;
@@ -34,7 +35,7 @@ export declare class OctreeGeometryNode implements IPointCloudTreeNode {
     isLoaded(): boolean;
     getBoundingSphere(): Sphere;
     getBoundingBox(): Box3;
-    load(): void;
+    load(): Promise<void>;
     getNumPoints(): number;
     dispose(): void;
     traverse(cb: (node: OctreeGeometryNode) => void, includeSelf?: boolean): void;
diff --git a/build/declarations/materials/clipping.d.ts b/build/declarations/materials/clipping.d.ts
index af45f6bc001035908613763677d11ebbd4201635..f78673ba0b246a4d66b54bf3c86b0d887b4bb5e3 100644
--- a/build/declarations/materials/clipping.d.ts
+++ b/build/declarations/materials/clipping.d.ts
@@ -1,4 +1,4 @@
-import { Box3, Matrix4, Vector3 } from 'three';
+import { Box3, Color, Matrix4, Vector3 } from 'three';
 export declare enum ClipMode {
     DISABLED = 0,
     CLIP_OUTSIDE = 1,
@@ -11,4 +11,5 @@ export interface IClipBox {
     inverse: Matrix4;
     matrix: Matrix4;
     position: Vector3;
+    color?: Color;
 }
diff --git a/build/declarations/materials/point-cloud-material.d.ts b/build/declarations/materials/point-cloud-material.d.ts
index a92a6661968a5e24d87d69fbf3990e9ead665c78..1a90561c96d06d7767df9f92e3449685ed9b82e7 100644
--- a/build/declarations/materials/point-cloud-material.d.ts
+++ b/build/declarations/materials/point-cloud-material.d.ts
@@ -18,6 +18,7 @@ export interface IPointCloudMaterialUniforms {
     classificationLUT: IUniform<Texture>;
     clipBoxCount: IUniform<number>;
     clipBoxes: IUniform<Float32Array>;
+    clipHighlightColors: IUniform<Float32Array>;
     clipExtent: IUniform<[number, number, number, number]>;
     depthMap: IUniform<Texture | null>;
     diffuse: IUniform<[number, number, number]>;
diff --git a/build/declarations/point-cloud-octree-geometry-node.d.ts b/build/declarations/point-cloud-octree-geometry-node.d.ts
index 7d1b11a1588599282582d2c8ce94cab434f6d911..f6369b6a8c25b1baaeda0aad864f79f8affee94c 100644
--- a/build/declarations/point-cloud-octree-geometry-node.d.ts
+++ b/build/declarations/point-cloud-octree-geometry-node.d.ts
@@ -4,13 +4,13 @@
  */
 import { Box3, BufferGeometry, EventDispatcher, Sphere, Vector3 } from 'three';
 import { PointCloudOctreeGeometry } from './point-cloud-octree-geometry';
-import { IPointCloudTreeNode } from './types';
+import { IPointCloudGeometryNode } from './types';
 export interface NodeData {
     children: number;
     numPoints: number;
     name: string;
 }
-export declare class PointCloudOctreeGeometryNode extends EventDispatcher implements IPointCloudTreeNode {
+export declare class PointCloudOctreeGeometryNode extends EventDispatcher implements IPointCloudGeometryNode {
     id: number;
     name: string;
     pcoGeometry: PointCloudOctreeGeometry;
diff --git a/build/declarations/point-cloud-octree-node.d.ts b/build/declarations/point-cloud-octree-node.d.ts
index e7430c5c3539b66eac0816091c8482494cdba0f4..72af19af850508f529954c7ebafe6642455d6d4d 100644
--- a/build/declarations/point-cloud-octree-node.d.ts
+++ b/build/declarations/point-cloud-octree-node.d.ts
@@ -1,8 +1,7 @@
 import { Box3, EventDispatcher, Object3D, Points, Sphere } from 'three';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
-import { IPointCloudTreeNode } from './types';
+import { IPointCloudGeometryNode, IPointCloudTreeNode } from './types';
 export declare class PointCloudOctreeNode extends EventDispatcher implements IPointCloudTreeNode {
-    geometryNode: PointCloudOctreeGeometryNode;
+    geometryNode: IPointCloudGeometryNode;
     sceneNode: Points;
     pcIndex: number | undefined;
     boundingBoxNode: Object3D | null;
@@ -10,7 +9,7 @@ export declare class PointCloudOctreeNode extends EventDispatcher implements IPo
     readonly loaded = true;
     readonly isTreeNode: boolean;
     readonly isGeometryNode: boolean;
-    constructor(geometryNode: PointCloudOctreeGeometryNode, sceneNode: Points);
+    constructor(geometryNode: IPointCloudGeometryNode, sceneNode: Points);
     dispose(): void;
     disposeSceneNode(): void;
     traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void;
diff --git a/build/declarations/point-cloud-octree.d.ts b/build/declarations/point-cloud-octree.d.ts
index e2c4c0bc9bccd1a3f6f1df45d51a2b565b0097a0..c13496ded4f5326b1933277864e8715514ef18fb 100644
--- a/build/declarations/point-cloud-octree.d.ts
+++ b/build/declarations/point-cloud-octree.d.ts
@@ -1,10 +1,9 @@
 import { Box3, Camera, Object3D, Ray, Sphere, WebGLRenderer } from 'three';
 import { PointCloudMaterial, PointSizeType } from './materials';
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
 import { PointCloudOctreeNode } from './point-cloud-octree-node';
 import { PickParams } from './point-cloud-octree-picker';
 import { PointCloudTree } from './point-cloud-tree';
-import { IPointCloudTreeNode, IPotree, PCOGeometry, PickPoint } from './types';
+import { IPointCloudGeometryNode, IPointCloudTreeNode, IPotree, PCOGeometry, PickPoint } from './types';
 export declare class PointCloudOctree extends PointCloudTree {
     potree: IPotree;
     disposed: boolean;
@@ -21,7 +20,7 @@ export declare class PointCloudOctree extends PointCloudTree {
     root: IPointCloudTreeNode | null;
     boundingBoxNodes: Object3D[];
     visibleNodes: PointCloudOctreeNode[];
-    visibleGeometry: PointCloudOctreeGeometryNode[];
+    visibleGeometry: IPointCloudGeometryNode[];
     numVisiblePoints: number;
     showBoundingBox: boolean;
     private visibleBounds;
@@ -31,7 +30,7 @@ export declare class PointCloudOctree extends PointCloudTree {
     dispose(): void;
     get pointSizeType(): PointSizeType;
     set pointSizeType(value: PointSizeType);
-    toTreeNode(geometryNode: PointCloudOctreeGeometryNode, parent?: PointCloudOctreeNode | null): PointCloudOctreeNode;
+    toTreeNode(geometryNode: IPointCloudGeometryNode, parent?: PointCloudOctreeNode | null): PointCloudOctreeNode;
     updateVisibleBounds(): void;
     updateBoundingBoxes(): void;
     updateMatrixWorld(force: boolean): void;
diff --git a/build/declarations/type-predicates.d.ts b/build/declarations/type-predicates.d.ts
index fbb5db4a23b627c511ada6323064a6920c8e4f45..ce9b755b728e026280ffda0ba7a5cfcc71da331c 100644
--- a/build/declarations/type-predicates.d.ts
+++ b/build/declarations/type-predicates.d.ts
@@ -1,4 +1,4 @@
-import { PointCloudOctreeGeometryNode } from './point-cloud-octree-geometry-node';
+import { IPointCloudGeometryNode } from './types';
 import { PointCloudOctreeNode } from './point-cloud-octree-node';
-export declare function isGeometryNode(node?: any): node is PointCloudOctreeGeometryNode;
+export declare function isGeometryNode(node?: any): node is IPointCloudGeometryNode;
 export declare function isTreeNode(node?: any): node is PointCloudOctreeNode;
diff --git a/build/declarations/types.d.ts b/build/declarations/types.d.ts
index 89808067ca540a74e4779d696d77f2485db71a3f..5c5fccd40d4dfbd352dcb276c3e9d300478af2ce 100644
--- a/build/declarations/types.d.ts
+++ b/build/declarations/types.d.ts
@@ -1,4 +1,4 @@
-import { Box3, Camera, Sphere, Vector3, WebGLRenderer } from 'three';
+import { Box3, BufferGeometry, Camera, Sphere, Vector3, WebGLRenderer } from 'three';
 import { GetUrlFn, XhrRequest } from './loading/types';
 import { OctreeGeometry } from './loading2/octree-geometry';
 import { PointCloudOctree } from './point-cloud-octree';
@@ -19,6 +19,14 @@ export interface IPointCloudTreeNode {
     dispose(): void;
     traverse(cb: (node: IPointCloudTreeNode) => void, includeSelf?: boolean): void;
 }
+export interface IPointCloudGeometryNode extends IPointCloudTreeNode {
+    geometry: BufferGeometry | undefined;
+    oneTimeDisposeHandlers: Function[];
+    loading: boolean;
+    loaded: boolean;
+    failed: boolean;
+    load(): Promise<void>;
+}
 export interface IVisibilityUpdateResult {
     visibleNodes: IPointCloudTreeNode[];
     numVisiblePoints: number;
diff --git a/build/potree.js b/build/potree.js
index 3c065f802951399c22dff82349ec6a60d5aa67bd..6be1c860c79dca6517c1b9466b18c839bbc4af44 100644
--- a/build/potree.js
+++ b/build/potree.js
@@ -1 +1 @@
-!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("three")):"function"==typeof define&&define.amd?define("potree",["three"],I):"object"==typeof exports?exports.potree=I(require("three")):g.potree=I(g.three)}(self,(__WEBPACK_EXTERNAL_MODULE__604__=>(()=>{"use strict";var __webpack_modules__={414:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nuniform mat4 projectionMatrix;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D map;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n\\tfloat dx = 1.0 / screenWidth;\\n\\tfloat dy = 1.0 / screenHeight;\\n\\n\\tvec3 color = vec3(0.0, 0.0, 0.0);\\n\\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\\n    \\n\\tcolor = color / 9.0;\\n\\t\\n\\tgl_FragColor = vec4(color, 1.0);\\n\\t\\n\\t\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLmZyYWc/MjI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnVuaWZvcm0gZmxvYXQgc2NyZWVuV2lkdGg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5IZWlnaHQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IGR4ID0gMS4wIC8gc2NyZWVuV2lkdGg7XFxuXFx0ZmxvYXQgZHkgPSAxLjAgLyBzY3JlZW5IZWlnaHQ7XFxuXFxuXFx0dmVjMyBjb2xvciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsIC1keSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgLWR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAtZHkpKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICAgMCkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgICAwKSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgIDApKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICBkeSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgIGR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgZHkpKS5yZ2I7XFxuICAgIFxcblxcdGNvbG9yID0gY29sb3IgLyA5LjA7XFxuXFx0XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cXHRcXG5cXHRcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n')},575:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n\\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLnZlcnQ/NWRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcblxcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZVdiA9IHV2O1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9ICAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///575\n')},168:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#if defined paraboloid_point_shape\\n\\t#extension GL_EXT_frag_depth : enable\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\\nuniform mat4 projectionMatrix;\\nuniform float opacity;\\n\\nuniform float blendHardness;\\nuniform float blendDepthSupplement;\\nuniform float fov;\\nuniform float spacing;\\nuniform float pcIndex;\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D depthMap;\\n\\n#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tuniform vec4 clipExtent;\\n#endif\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec4 highlightedPointColor;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\nfloat specularStrength = 1.0;\\n\\nvoid main() {\\n\\tvec3 color = vColor;\\n\\tfloat depth = gl_FragCoord.z;\\n\\n\\t#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tvec2 ndc = vec2((gl_FragCoord.x / screenWidth), 1.0 - (gl_FragCoord.y / screenHeight));\\n\\n\\tif(step(clipExtent.x, ndc.x) * step(ndc.x, clipExtent.z) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\n\\tif(step(clipExtent.y, ndc.y) * step(ndc.y, clipExtent.w) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif  \\n\\n\\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\\n\\t\\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\\n\\t\\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\\n\\t#endif\\n\\n\\t#if defined(circle_point_shape) || defined (weighted_splats)\\n\\t\\tfloat cc = u*u + v*v;\\n\\t\\tif(cc > 1.0){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\t\\tfloat sDepth = texture2D(depthMap, uv).r;\\n\\t\\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined color_type_point_index\\n\\t\\tgl_FragColor = vec4(color, pcIndex / 255.0);\\n\\t#else\\n\\t\\tgl_FragColor = vec4(color, vOpacity);\\n\\t#endif\\n\\n\\t#ifdef use_point_cloud_mixing\\n\\t\\tbool discardFragment = false;\\n\\n\\t\\tif (pointCloudMixingMode == 1) {  // Checkboard\\n\\t\\t\\tfloat vPointCloudID = pointCloudID > 10. ? pointCloudID/10.: pointCloudID;\\n\\t\\t\\tdiscardFragment = mod(gl_FragCoord.x, vPointCloudID) > 0.5 && mod(gl_FragCoord.y, vPointCloudID) > 0.5;\\n\\t\\t}\\n\\t\\telse if (pointCloudMixingMode == 2) {  // Stripes\\n\\t\\t\\tfloat angle = pointCloudMixAngle * pointCloudID / 180.;\\n\\t\\t\\tfloat u = cos(angle) * gl_FragCoord.x + sin(angle) * gl_FragCoord.y;\\n\\t\\t\\tfloat v = -sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y;\\n\\n\\t\\t\\tdiscardFragment = mod(u, stripeDistanceX) >= stripeDistanceX/stripeDivisorX && mod(v, stripeDistanceY) >= stripeDistanceY/stripeDivisorY;\\n\\t\\t}\\n\\t\\tif (discardFragment) {\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#ifdef use_texture_blending\\n\\t\\tvec2 vUv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\n\\t\\tvec4 tColor = texture2D(backgroundMap, vUv);\\n\\t\\tgl_FragColor = vec4(vOpacity * color, 1.) + vec4((1. - vOpacity) * tColor.rgb, 0.);\\n\\t#endif\\n\\n\\t#if defined(color_type_phong)\\n\\t\\t#if MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0\\n\\t\\t\\tvec3 normal = normalize( vNormal );\\n\\t\\t\\tnormal.z = abs(normal.z);\\n\\n\\t\\t\\tvec3 viewPosition = normalize( vViewPosition );\\n\\t\\t#endif\\n\\n\\t\\t// code taken from three.js phong light fragment shader\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\tvec3 pointDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 pointSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\t\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\t\\t\\tfloat lDistance = 1.0;\\n\\t\\t\\t\\tif ( pointLightDistance[ i ] > 0.0 )\\n\\t\\t\\t\\t\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n\\t\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\t\\t\\t\\tpointSpecular = vec3(0.0, 0.0, 0.0);\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\tvec3 dirDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 dirSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n\\t\\t\\t\\tvec3 dirVector = normalize( lDirection.xyz );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\t\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\tvec3 totalDiffuse = vec3( 0.0 );\\n\\t\\tvec3 totalSpecular = vec3( 0.0 );\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += pointDiffuse;\\n\\t\\t\\ttotalSpecular += pointSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += dirDiffuse;\\n\\t\\t\\ttotalSpecular += dirSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\\n\\n\\t\\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\\n\\t\\tfloat w = exp(-wx * wx * 0.5);\\n\\n\\t\\t//float distance = length(2.0 * gl_PointCoord - 1.0);\\n\\t\\t//float w = exp( -(distance * distance) / blendHardness);\\n\\n\\t\\tgl_FragColor.rgb = gl_FragColor.rgb * w;\\n\\t\\tgl_FragColor.a = w;\\n\\t#endif\\n\\n\\t#if defined paraboloid_point_shape\\n\\t\\tfloat wi = 0.0 - ( u*u + v*v);\\n\\t\\tvec4 pos = vec4(vViewPosition, 1.0);\\n\\t\\tpos.z += wi * vRadius;\\n\\t\\tfloat linearDepth = -pos.z;\\n\\t\\tpos = projectionMatrix * pos;\\n\\t\\tpos = pos / pos.w;\\n\\t\\tfloat expDepth = pos.z;\\n\\t\\tdepth = (pos.z + 1.0) / 2.0;\\n\\t\\tgl_FragDepthEXT = depth;\\n\\n\\t\\t#if defined(color_type_depth)\\n\\t\\t\\tgl_FragColor.r = linearDepth;\\n\\t\\t\\tgl_FragColor.g = expDepth;\\n\\t\\t#endif\\n\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = log2(linearDepth);\\n\\t\\t#endif\\n\\n\\t#else\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = vLogDepth;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t#ifdef highlight_point\\n\\t\\tif (vHighlight > 0.0) {\\n\\t\\t\\tgl_FragColor = highlightedPointColor;\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQuZnJhZz8wNTA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2lmIGRlZmluZWQgcGFyYWJvbG9pZF9wb2ludF9zaGFwZVxcblxcdCNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcXG51bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnVuaWZvcm0gZmxvYXQgYmxlbmRIYXJkbmVzcztcXG51bmlmb3JtIGZsb2F0IGJsZW5kRGVwdGhTdXBwbGVtZW50O1xcbnVuaWZvcm0gZmxvYXQgZm92O1xcbnVuaWZvcm0gZmxvYXQgc3BhY2luZztcXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkZXB0aE1hcDtcXG5cXG4jaWYgZGVmaW5lZCAoY2xpcF9ob3Jpem9udGFsbHkpIHx8IGRlZmluZWQgKGNsaXBfdmVydGljYWxseSlcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcEV4dGVudDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX3RleHR1cmVfYmxlbmRpbmdcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBiYWNrZ3JvdW5kTWFwO1xcbiNlbmRpZlxcblxcblxcbiNpZmRlZiB1c2VfcG9pbnRfY2xvdWRfbWl4aW5nXFxuXFx0dW5pZm9ybSBpbnQgcG9pbnRDbG91ZE1peGluZ01vZGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkSUQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkTWl4QW5nbGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVg7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVk7XFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXZpc29yWDtcXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpdmlzb3JZO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBoaWdobGlnaHRfcG9pbnRcXG5cXHR1bmlmb3JtIHZlYzQgaGlnaGxpZ2h0ZWRQb2ludENvbG9yO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2lmICFkZWZpbmVkKGNvbG9yX3R5cGVfcG9pbnRfaW5kZXgpXFxuXFx0dmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0dmFyeWluZyBmbG9hdCB2TGluZWFyRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHR2YXJ5aW5nIGZsb2F0IHZMb2dEZXB0aDtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyBmbG9hdCB2UmFkaXVzO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHZhcnlpbmcgZmxvYXQgdkhpZ2hsaWdodDtcXG4jZW5kaWZcXG5cXG5mbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yO1xcblxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLno7XFxuXFxuXFx0I2lmIGRlZmluZWQgKGNsaXBfaG9yaXpvbnRhbGx5KSB8fCBkZWZpbmVkIChjbGlwX3ZlcnRpY2FsbHkpXFxuXFx0dmVjMiBuZGMgPSB2ZWMyKChnbF9GcmFnQ29vcmQueCAvIHNjcmVlbldpZHRoKSwgMS4wIC0gKGdsX0ZyYWdDb29yZC55IC8gc2NyZWVuSGVpZ2h0KSk7XFxuXFxuXFx0aWYoc3RlcChjbGlwRXh0ZW50LngsIG5kYy54KSAqIHN0ZXAobmRjLngsIGNsaXBFeHRlbnQueikgPCAxLjApXFxuXFx0e1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcblxcdGlmKHN0ZXAoY2xpcEV4dGVudC55LCBuZGMueSkgKiBzdGVwKG5kYy55LCBjbGlwRXh0ZW50LncpIDwgMS4wKVxcblxcdHtcXG5cXHRcXHRkaXNjYXJkO1xcblxcdH1cXG5cXHQjZW5kaWYgIFxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKSB8fCBkZWZpbmVkICh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0XFx0ZmxvYXQgdSA9IDIuMCAqIGdsX1BvaW50Q29vcmQueCAtIDEuMDtcXG5cXHRcXHRmbG9hdCB2ID0gMi4wICogZ2xfUG9pbnRDb29yZC55IC0gMS4wO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZCAod2VpZ2h0ZWRfc3BsYXRzKVxcblxcdFxcdGZsb2F0IGNjID0gdSp1ICsgdip2O1xcblxcdFxcdGlmKGNjID4gMS4wKXtcXG5cXHRcXHRcXHRkaXNjYXJkO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCB3ZWlnaHRlZF9zcGxhdHNcXG5cXHRcXHR2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdmVjMihzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcXG5cXHRcXHRmbG9hdCBzRGVwdGggPSB0ZXh0dXJlMkQoZGVwdGhNYXAsIHV2KS5yO1xcblxcdFxcdGlmKHZMaW5lYXJEZXB0aCA+IHNEZXB0aCArIHZSYWRpdXMgKyBibGVuZERlcHRoU3VwcGxlbWVudCl7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIGRlZmluZWQgY29sb3JfdHlwZV9wb2ludF9pbmRleFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIHBjSW5kZXggLyAyNTUuMCk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCB2T3BhY2l0eSk7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV9wb2ludF9jbG91ZF9taXhpbmdcXG5cXHRcXHRib29sIGRpc2NhcmRGcmFnbWVudCA9IGZhbHNlO1xcblxcblxcdFxcdGlmIChwb2ludENsb3VkTWl4aW5nTW9kZSA9PSAxKSB7ICAvLyBDaGVja2JvYXJkXFxuXFx0XFx0XFx0ZmxvYXQgdlBvaW50Q2xvdWRJRCA9IHBvaW50Q2xvdWRJRCA+IDEwLiA/IHBvaW50Q2xvdWRJRC8xMC46IHBvaW50Q2xvdWRJRDtcXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QoZ2xfRnJhZ0Nvb3JkLngsIHZQb2ludENsb3VkSUQpID4gMC41ICYmIG1vZChnbF9GcmFnQ29vcmQueSwgdlBvaW50Q2xvdWRJRCkgPiAwLjU7XFxuXFx0XFx0fVxcblxcdFxcdGVsc2UgaWYgKHBvaW50Q2xvdWRNaXhpbmdNb2RlID09IDIpIHsgIC8vIFN0cmlwZXNcXG5cXHRcXHRcXHRmbG9hdCBhbmdsZSA9IHBvaW50Q2xvdWRNaXhBbmdsZSAqIHBvaW50Q2xvdWRJRCAvIDE4MC47XFxuXFx0XFx0XFx0ZmxvYXQgdSA9IGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIHNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXHRcXHRcXHRmbG9hdCB2ID0gLXNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QodSwgc3RyaXBlRGlzdGFuY2VYKSA+PSBzdHJpcGVEaXN0YW5jZVgvc3RyaXBlRGl2aXNvclggJiYgbW9kKHYsIHN0cmlwZURpc3RhbmNlWSkgPj0gc3RyaXBlRGlzdGFuY2VZL3N0cmlwZURpdmlzb3JZO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoZGlzY2FyZEZyYWdtZW50KSB7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV90ZXh0dXJlX2JsZW5kaW5nXFxuXFx0XFx0dmVjMiB2VXYgPSBnbF9GcmFnQ29vcmQueHkgLyB2ZWMyKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xcblxcblxcdFxcdHZlYzQgdENvbG9yID0gdGV4dHVyZTJEKGJhY2tncm91bmRNYXAsIHZVdik7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2T3BhY2l0eSAqIGNvbG9yLCAxLikgKyB2ZWM0KCgxLiAtIHZPcGFjaXR5KSAqIHRDb2xvci5yZ2IsIDAuKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKVxcblxcdFxcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXHRcXHRcXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcdFxcdFxcdG5vcm1hbC56ID0gYWJzKG5vcm1hbC56KTtcXG5cXG5cXHRcXHRcXHR2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdC8vIGNvZGUgdGFrZW4gZnJvbSB0aHJlZS5qcyBwaG9uZyBsaWdodCBmcmFnbWVudCBzaGFkZXJcXG5cXG5cXHRcXHQjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdHZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcblxcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblxcdFxcdFxcdFxcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuXFx0XFx0XFx0XFx0aWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxuXFx0XFx0XFx0XFx0XFx0bERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGRpZmZ1c2VcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0cG9pbnREaWZmdXNlICs9IGRpZmZ1c2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzcGVjdWxhclxcblxcblxcdFxcdFxcdFxcdHZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1xcblxcdFxcdFxcdFxcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0XFx0cG9pbnRTcGVjdWxhciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdCNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHR2ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0XFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkaWZmdXNlXFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblxcdFxcdFxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0ZGlyRGlmZnVzZSArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcblxcblxcdFxcdFxcdFxcdC8vIHNwZWN1bGFyXFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRkaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxuXFx0XFx0dmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0XFx0dG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcXG5cXHRcXHRcXHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblxcdFxcdFxcdHRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1xcblxcdFxcdFxcdHRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1xcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkIHdlaWdodGVkX3NwbGF0c1xcblxcdCAgICAvL2Zsb2F0IHcgPSBwb3coMS4wIC0gKHUqdSArIHYqdiksIGJsZW5kSGFyZG5lc3MpO1xcblxcblxcdFxcdGZsb2F0IHd4ID0gMi4wICogbGVuZ3RoKDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjApO1xcblxcdFxcdGZsb2F0IHcgPSBleHAoLXd4ICogd3ggKiAwLjUpO1xcblxcblxcdFxcdC8vZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgoMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMCk7XFxuXFx0XFx0Ly9mbG9hdCB3ID0gZXhwKCAtKGRpc3RhbmNlICogZGlzdGFuY2UpIC8gYmxlbmRIYXJkbmVzcyk7XFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IGdsX0ZyYWdDb2xvci5yZ2IgKiB3O1xcblxcdFxcdGdsX0ZyYWdDb2xvci5hID0gdztcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCBwYXJhYm9sb2lkX3BvaW50X3NoYXBlXFxuXFx0XFx0ZmxvYXQgd2kgPSAwLjAgLSAoIHUqdSArIHYqdik7XFxuXFx0XFx0dmVjNCBwb3MgPSB2ZWM0KHZWaWV3UG9zaXRpb24sIDEuMCk7XFxuXFx0XFx0cG9zLnogKz0gd2kgKiB2UmFkaXVzO1xcblxcdFxcdGZsb2F0IGxpbmVhckRlcHRoID0gLXBvcy56O1xcblxcdFxcdHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiBwb3M7XFxuXFx0XFx0cG9zID0gcG9zIC8gcG9zLnc7XFxuXFx0XFx0ZmxvYXQgZXhwRGVwdGggPSBwb3MuejtcXG5cXHRcXHRkZXB0aCA9IChwb3MueiArIDEuMCkgLyAyLjA7XFxuXFx0XFx0Z2xfRnJhZ0RlcHRoRVhUID0gZGVwdGg7XFxuXFxuXFx0XFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9kZXB0aClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuciA9IGxpbmVhckRlcHRoO1xcblxcdFxcdFxcdGdsX0ZyYWdDb2xvci5nID0gZXhwRGVwdGg7XFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IGxvZzIobGluZWFyRGVwdGgpO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdCNlbHNlXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IHZMb2dEZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgaGlnaGxpZ2h0X3BvaW50XFxuXFx0XFx0aWYgKHZIaWdobGlnaHQgPiAwLjApIHtcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSBoaWdobGlnaHRlZFBvaW50Q29sb3I7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbn1cXG5cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///168\n')},245:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#define max_clip_boxes 30\\n\\nattribute vec3 position;\\nattribute vec3 color;\\n\\n#ifdef color_rgba\\n\\tattribute vec4 rgba;\\n#endif\\n\\nattribute vec3 normal;\\nattribute float intensity;\\nattribute float classification;\\nattribute float returnNumber;\\nattribute float numberOfReturns;\\nattribute float pointSourceID;\\nattribute vec4 indices;\\nattribute vec2 uv;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nuniform float pcIndex;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float fov;\\nuniform float spacing;\\n\\n#if defined use_clip_box\\n\\tuniform mat4 clipBoxes[max_clip_boxes];\\n#endif\\n\\nuniform float heightMin;\\nuniform float heightMax;\\nuniform float size; // pixel size factor\\nuniform float minSize; // minimum pixel size\\nuniform float maxSize; // maximum pixel size\\nuniform float octreeSize;\\nuniform vec3 bbSize;\\nuniform vec3 uColor;\\nuniform float opacity;\\nuniform float clipBoxCount;\\nuniform float level;\\nuniform float vnStart;\\nuniform bool isLeafNode;\\n\\nuniform float filterByNormalThreshold;\\nuniform vec2 intensityRange;\\nuniform float opacityAttenuation;\\nuniform float intensityGamma;\\nuniform float intensityContrast;\\nuniform float intensityBrightness;\\nuniform float rgbGamma;\\nuniform float rgbContrast;\\nuniform float rgbBrightness;\\nuniform float transition;\\nuniform float wRGB;\\nuniform float wIntensity;\\nuniform float wElevation;\\nuniform float wClassification;\\nuniform float wReturnNumber;\\nuniform float wSourceID;\\n\\nuniform sampler2D visibleNodes;\\nuniform sampler2D gradient;\\nuniform sampler2D classificationLUT;\\nuniform sampler2D depthMap;\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec3 highlightedPointCoordinate;\\n\\tuniform bool enablePointHighlighting;\\n\\tuniform float highlightedPointScale;\\n#endif\\n\\n#ifdef use_filter_by_normal\\n\\tuniform int normalFilteringMode;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\n// ---------------------\\n// OCTREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat round(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = int(vnStart);\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\n\\t\\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(round(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(round(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(round(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\\n\\t}\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(2.0, getLOD());\\n}\\n\\n#endif\\n\\n// ---------------------\\n// KD-TREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\\n\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tfloat intOffset = 0.0;\\n\\tfloat depth = 0.0;\\n\\n\\tvec3 size = bbSize;\\n\\tvec3 pos = position;\\n\\n\\tfor (float i = 0.0; i <= 1000.0; i++) {\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(intOffset / 2048.0, 0.0));\\n\\n\\t\\tint children = int(value.r * 255.0);\\n\\t\\tfloat next = value.g * 255.0;\\n\\t\\tint split = int(value.b * 255.0);\\n\\n\\t\\tif (next == 0.0) {\\n\\t\\t \\treturn depth;\\n\\t\\t}\\n\\n\\t\\tvec3 splitv = vec3(0.0, 0.0, 0.0);\\n\\t\\tif (split == 1) {\\n\\t\\t\\tsplitv.x = 1.0;\\n\\t\\t} else if (split == 2) {\\n\\t\\t \\tsplitv.y = 1.0;\\n\\t\\t} else if (split == 4) {\\n\\t\\t \\tsplitv.z = 1.0;\\n\\t\\t}\\n\\n\\t\\tintOffset = intOffset + next;\\n\\n\\t\\tfloat factor = length(pos * splitv / size);\\n\\t\\tif (factor < 0.5) {\\n\\t\\t \\t// left\\n\\t\\t\\tif (children == 0 || children == 2) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right\\n\\t\\t\\tpos = pos - size * splitv * 0.5;\\n\\t\\t\\tif (children == 0 || children == 1) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t\\tif (children == 3) {\\n\\t\\t\\t\\tintOffset = intOffset + 1.0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\\n\\n\\t\\tdepth++;\\n\\t}\\n\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(1.3, getLOD());\\n}\\n\\n#endif\\n\\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\\nfloat getContrastFactor(float contrast) {\\n\\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\\n}\\n\\nvec3 getRGB() {\\n\\t\\n\\t#ifdef color_rgba\\n\\t\\tvec3 rgb = rgba.rgb;\\n\\t#else\\t\\n\\t\\tvec3 rgb = color;\\n\\t#endif\\t\\t\\n\\n\\t#if defined(use_rgb_gamma_contrast_brightness)\\n\\t\\trgb = pow(rgb, vec3(rgbGamma));\\n\\t\\trgb = rgb + rgbBrightness;\\n\\t\\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\\n\\t\\trgb = clamp(rgb, 0.0, 1.0);\\n\\t\\treturn rgb;\\n\\t#else\\n\\t\\treturn rgb;\\n\\t#endif\\n}\\n\\nfloat getIntensity() {\\n\\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\\n\\tw = pow(w, intensityGamma);\\n\\tw = w + intensityBrightness;\\n\\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\\n\\tw = clamp(w, 0.0, 1.0);\\n\\n\\treturn w;\\n}\\n\\nvec3 getElevation() {\\n\\tvec4 world = modelMatrix * vec4( position, 1.0 );\\n\\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\\n\\tvec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\\n\\n\\treturn cElevation;\\n}\\n\\nvec4 getClassification() {\\n\\tvec2 uv = vec2(classification / 255.0, 0.5);\\n\\tvec4 classColor = texture2D(classificationLUT, uv);\\n\\n\\treturn classColor;\\n}\\n\\nvec3 getReturnNumber() {\\n\\tif (numberOfReturns == 1.0) {\\n\\t\\treturn vec3(1.0, 1.0, 0.0);\\n\\t} else {\\n\\t\\tif (returnNumber == 1.0) {\\n\\t\\t\\treturn vec3(1.0, 0.0, 0.0);\\n\\t\\t} else if (returnNumber == numberOfReturns) {\\n\\t\\t\\treturn vec3(0.0, 0.0, 1.0);\\n\\t\\t} else {\\n\\t\\t\\treturn vec3(0.0, 1.0, 0.0);\\n\\t\\t}\\n\\t}\\n}\\n\\nvec3 getSourceID() {\\n\\tfloat w = mod(pointSourceID, 10.0) / 10.0;\\n\\treturn texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n}\\n\\nvec3 getCompositeColor() {\\n\\tvec3 c;\\n\\tfloat w;\\n\\n\\tc += wRGB * getRGB();\\n\\tw += wRGB;\\n\\n\\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\\n\\tw += wIntensity;\\n\\n\\tc += wElevation * getElevation();\\n\\tw += wElevation;\\n\\n\\tc += wReturnNumber * getReturnNumber();\\n\\tw += wReturnNumber;\\n\\n\\tc += wSourceID * getSourceID();\\n\\tw += wSourceID;\\n\\n\\tvec4 cl = wClassification * getClassification();\\n\\tc += cl.a * cl.rgb;\\n\\tw += wClassification * cl.a;\\n\\n\\tc = c / w;\\n\\n\\tif (w == 0.0) {\\n\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t}\\n\\n\\treturn c;\\n}\\n\\nvoid main() {\\n\\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\t\\tvViewPosition = mvPosition.xyz;\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvLinearDepth = gl_Position.w;\\n\\t#endif\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\t\\tvNormal = normalize(normalMatrix * normal);\\n\\t#endif\\n\\n\\t#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\t\\tvLogDepth = log2(-mvPosition.z);\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT SIZE\\n\\t// ---------------------\\n\\n\\tfloat pointSize = 1.0;\\n\\tfloat slope = tan(fov / 2.0);\\n\\tfloat projFactor =  -0.5 * screenHeight / (slope * mvPosition.z);\\n\\n\\t#if defined fixed_point_size\\n\\t\\tpointSize = size;\\n\\t#elif defined attenuated_point_size\\n\\t\\tpointSize = size * spacing * projFactor;\\n\\t#elif defined adaptive_point_size\\n\\t\\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\\n\\t\\tpointSize = worldSpaceSize * projFactor;\\n\\t#endif\\n\\n\\tpointSize = max(minSize, pointSize);\\n\\tpointSize = min(maxSize, pointSize);\\n\\n\\t#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\t\\tvRadius = pointSize / projFactor;\\n\\t#endif\\n\\n\\tgl_PointSize = pointSize;\\n\\n\\t// ---------------------\\n\\t// HIGHLIGHTING\\n\\t// ---------------------\\n\\n\\t#ifdef highlight_point\\n\\t\\tvec4 mPosition = modelMatrix * vec4(position, 1.0);\\n\\t\\tif (enablePointHighlighting && abs(mPosition.x - highlightedPointCoordinate.x) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.y - highlightedPointCoordinate.y) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.z - highlightedPointCoordinate.z) < 0.0001) {\\n\\t\\t\\tvHighlight = 1.0;\\n\\t\\t\\tgl_PointSize = pointSize * highlightedPointScale;\\n\\t\\t} else {\\n\\t\\t\\tvHighlight = 0.0;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// OPACITY\\n\\t// ---------------------\\n\\n\\t#ifndef color_type_point_index\\n\\t\\t#ifdef attenuated_opacity\\n\\t\\t\\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\\n\\t\\t#else\\n\\t\\t\\tvOpacity = opacity;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// FILTERING\\n\\t// ---------------------\\n\\n\\t#ifdef use_filter_by_normal\\n\\t\\tbool discardPoint = false;\\n\\t\\t// Absolute normal filtering\\n\\t\\tif (normalFilteringMode == 1) {\\n\\t\\t\\tdiscardPoint = (abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold);\\n\\t\\t}\\n\\t\\t// less than equal to\\n\\t\\telse if (normalFilteringMode == 2) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z <= filterByNormalThreshold;\\n\\t\\t\\t}\\n\\t\\t// greater than\\n\\t\\telse if(normalFilteringMode == 3) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z > filterByNormalThreshold;\\n\\t\\t\\t}\\n\\n\\t\\tif (discardPoint)\\n\\t\\t{\\n\\t\\t\\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT COLOR\\n\\t// ---------------------\\n\\n\\t#ifdef color_type_rgb\\n\\t\\tvColor = getRGB();\\n\\t#elif defined color_type_height\\n\\t\\tvColor = getElevation();\\n\\t#elif defined color_type_rgb_height\\n\\t\\tvec3 cHeight = getElevation();\\n\\t\\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\\n\\t#elif defined color_type_depth\\n\\t\\tfloat linearDepth = -mvPosition.z ;\\n\\t\\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\\n\\t\\tvColor = vec3(linearDepth, expDepth, 0.0);\\n\\t#elif defined color_type_intensity\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = vec3(w, w, w);\\n\\t#elif defined color_type_intensity_gradient\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_color\\n\\t\\tvColor = uColor;\\n\\t#elif defined color_type_lod\\n\\tfloat w = getLOD() / 10.0;\\n\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_point_index\\n\\t\\tvColor = indices.rgb;\\n\\t#elif defined color_type_classification\\n\\t  vec4 cl = getClassification();\\n\\t\\tvColor = cl.rgb;\\n\\t#elif defined color_type_return_number\\n\\t\\tvColor = getReturnNumber();\\n\\t#elif defined color_type_source\\n\\t\\tvColor = getSourceID();\\n\\t#elif defined color_type_normal\\n\\t\\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\\n\\t#elif defined color_type_phong\\n\\t\\tvColor = color;\\n\\t#elif defined color_type_composite\\n\\t\\tvColor = getCompositeColor();\\n\\t#endif\\n\\n\\t#if !defined color_type_composite && defined color_type_classification\\n\\t\\tif (cl.a == 0.0) {\\n\\t\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// CLIPPING\\n\\t// ---------------------\\n\\n\\t#if defined use_clip_box\\n\\t\\tbool insideAny = false;\\n\\t\\tfor (int i = 0; i < max_clip_boxes; i++) {\\n\\t\\t\\tif (i == int(clipBoxCount)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\\n\\t\\t\\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\\n\\t\\t\\tinsideAny = insideAny || inside;\\n\\t\\t}\\n\\n\\t\\tif (!insideAny) {\\n\\t\\t\\t#if defined clip_outside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#elif defined clip_highlight_inside && !defined(color_type_depth)\\n\\t\\t\\t\\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\\n\\t\\t\\t#endif\\n\\t\\t} else {\\n\\t\\t\\t#if defined clip_highlight_inside\\n\\t\\t\\t\\tvColor.r += 0.5;\\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ1LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQudmVydD9lZmM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2RlZmluZSBtYXhfY2xpcF9ib3hlcyAzMFxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcblxcbiNpZmRlZiBjb2xvcl9yZ2JhXFxuXFx0YXR0cmlidXRlIHZlYzQgcmdiYTtcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGludGVuc2l0eTtcXG5hdHRyaWJ1dGUgZmxvYXQgY2xhc3NpZmljYXRpb247XFxuYXR0cmlidXRlIGZsb2F0IHJldHVybk51bWJlcjtcXG5hdHRyaWJ1dGUgZmxvYXQgbnVtYmVyT2ZSZXR1cm5zO1xcbmF0dHJpYnV0ZSBmbG9hdCBwb2ludFNvdXJjZUlEO1xcbmF0dHJpYnV0ZSB2ZWM0IGluZGljZXM7XFxuYXR0cmlidXRlIHZlYzIgdXY7XFxuXFxudW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcXG5cXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxuXFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG51bmlmb3JtIGZsb2F0IGZvdjtcXG51bmlmb3JtIGZsb2F0IHNwYWNpbmc7XFxuXFxuI2lmIGRlZmluZWQgdXNlX2NsaXBfYm94XFxuXFx0dW5pZm9ybSBtYXQ0IGNsaXBCb3hlc1ttYXhfY2xpcF9ib3hlc107XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBmbG9hdCBoZWlnaHRNaW47XFxudW5pZm9ybSBmbG9hdCBoZWlnaHRNYXg7XFxudW5pZm9ybSBmbG9hdCBzaXplOyAvLyBwaXhlbCBzaXplIGZhY3RvclxcbnVuaWZvcm0gZmxvYXQgbWluU2l6ZTsgLy8gbWluaW11bSBwaXhlbCBzaXplXFxudW5pZm9ybSBmbG9hdCBtYXhTaXplOyAvLyBtYXhpbXVtIHBpeGVsIHNpemVcXG51bmlmb3JtIGZsb2F0IG9jdHJlZVNpemU7XFxudW5pZm9ybSB2ZWMzIGJiU2l6ZTtcXG51bmlmb3JtIHZlYzMgdUNvbG9yO1xcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG51bmlmb3JtIGZsb2F0IGNsaXBCb3hDb3VudDtcXG51bmlmb3JtIGZsb2F0IGxldmVsO1xcbnVuaWZvcm0gZmxvYXQgdm5TdGFydDtcXG51bmlmb3JtIGJvb2wgaXNMZWFmTm9kZTtcXG5cXG51bmlmb3JtIGZsb2F0IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcbnVuaWZvcm0gdmVjMiBpbnRlbnNpdHlSYW5nZTtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHlBdHRlbnVhdGlvbjtcXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eUdhbW1hO1xcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5Q29udHJhc3Q7XFxudW5pZm9ybSBmbG9hdCBpbnRlbnNpdHlCcmlnaHRuZXNzO1xcbnVuaWZvcm0gZmxvYXQgcmdiR2FtbWE7XFxudW5pZm9ybSBmbG9hdCByZ2JDb250cmFzdDtcXG51bmlmb3JtIGZsb2F0IHJnYkJyaWdodG5lc3M7XFxudW5pZm9ybSBmbG9hdCB0cmFuc2l0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd1JHQjtcXG51bmlmb3JtIGZsb2F0IHdJbnRlbnNpdHk7XFxudW5pZm9ybSBmbG9hdCB3RWxldmF0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd0NsYXNzaWZpY2F0aW9uO1xcbnVuaWZvcm0gZmxvYXQgd1JldHVybk51bWJlcjtcXG51bmlmb3JtIGZsb2F0IHdTb3VyY2VJRDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB2aXNpYmxlTm9kZXM7XFxudW5pZm9ybSBzYW1wbGVyMkQgZ3JhZGllbnQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgY2xhc3NpZmljYXRpb25MVVQ7XFxudW5pZm9ybSBzYW1wbGVyMkQgZGVwdGhNYXA7XFxuXFxuI2lmZGVmIHVzZV90ZXh0dXJlX2JsZW5kaW5nXFxuXFx0dW5pZm9ybSBzYW1wbGVyMkQgYmFja2dyb3VuZE1hcDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX3BvaW50X2Nsb3VkX21peGluZ1xcblxcdHVuaWZvcm0gaW50IHBvaW50Q2xvdWRNaXhpbmdNb2RlO1xcblxcdHVuaWZvcm0gZmxvYXQgcG9pbnRDbG91ZElEO1xcblxcblxcdHVuaWZvcm0gZmxvYXQgcG9pbnRDbG91ZE1peEFuZ2xlO1xcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGlzdGFuY2VYO1xcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGlzdGFuY2VZO1xcblxcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGl2aXNvclg7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXZpc29yWTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgaGlnaGxpZ2h0X3BvaW50XFxuXFx0dW5pZm9ybSB2ZWMzIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlO1xcblxcdHVuaWZvcm0gYm9vbCBlbmFibGVQb2ludEhpZ2hsaWdodGluZztcXG5cXHR1bmlmb3JtIGZsb2F0IGhpZ2hsaWdodGVkUG9pbnRTY2FsZTtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX2ZpbHRlcl9ieV9ub3JtYWxcXG5cXHR1bmlmb3JtIGludCBub3JtYWxGaWx0ZXJpbmdNb2RlO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2lmICFkZWZpbmVkKGNvbG9yX3R5cGVfcG9pbnRfaW5kZXgpXFxuXFx0dmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0dmFyeWluZyBmbG9hdCB2TGluZWFyRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHR2YXJ5aW5nIGZsb2F0IHZMb2dEZXB0aDtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyBmbG9hdCB2UmFkaXVzO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHZhcnlpbmcgZmxvYXQgdkhpZ2hsaWdodDtcXG4jZW5kaWZcXG5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBPQ1RSRUVcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG4jaWYgKGRlZmluZWQoYWRhcHRpdmVfcG9pbnRfc2l6ZSkgfHwgZGVmaW5lZChjb2xvcl90eXBlX2xvZCkpICYmIGRlZmluZWQodHJlZV90eXBlX29jdHJlZSlcXG5cXG4vKipcXG4gKiBSb3VuZHMgdGhlIHNwZWNpZmllZCBudW1iZXIgdG8gdGhlIGNsb3Nlc3QgaW50ZWdlci5cXG4gKi9cXG5mbG9hdCByb3VuZChmbG9hdCBudW1iZXIpe1xcblxcdHJldHVybiBmbG9vcihudW1iZXIgKyAwLjUpO1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgMS1iaXRzIHVwIHRvIGluY2x1c2l2ZSBpbmRleCBwb3NpdGlvbi5cXG4gKlxcbiAqIG51bWJlciBpcyB0cmVhdGVkIGFzIGlmIGl0IHdlcmUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2UgMC0yNTVcXG4gKi9cXG5pbnQgbnVtYmVyT2ZPbmVzKGludCBudW1iZXIsIGludCBpbmRleCkge1xcblxcdGludCBudW1PbmVzID0gMDtcXG5cXHRpbnQgdG1wID0gMTI4O1xcblxcdGZvciAoaW50IGkgPSA3OyBpID49IDA7IGktLSkge1xcblxcblxcdFxcdGlmIChudW1iZXIgPj0gdG1wKSB7XFxuXFx0XFx0XFx0bnVtYmVyID0gbnVtYmVyIC0gdG1wO1xcblxcblxcdFxcdFxcdGlmIChpIDw9IGluZGV4KSB7XFxuXFx0XFx0XFx0XFx0bnVtT25lcysrO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dG1wID0gdG1wIC8gMjtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG51bU9uZXM7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBiaXQgYXQgaW5kZXggaXMgMS4wXFxuICpcXG4gKiBudW1iZXIgaXMgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIDAtMjU1XFxuICovXFxuYm9vbCBpc0JpdFNldChpbnQgbnVtYmVyLCBpbnQgaW5kZXgpe1xcblxcblxcdC8vIHdlaXJkIG11bHRpIGVsc2UgaWYgZHVlIHRvIGxhY2sgb2YgcHJvcGVyIGFycmF5LCBpbnQgYW5kIGJpdHdpc2Ugc3VwcG9ydCBpbiBXZWJHTCAxLjBcXG5cXHRpbnQgcG93aSA9IDE7XFxuXFx0aWYgKGluZGV4ID09IDApIHtcXG5cXHRcXHRwb3dpID0gMTtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDEpIHtcXG5cXHRcXHRwb3dpID0gMjtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDIpIHtcXG5cXHRcXHRwb3dpID0gNDtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDMpIHtcXG5cXHRcXHRwb3dpID0gODtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDQpIHtcXG5cXHRcXHRwb3dpID0gMTY7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSA1KSB7XFxuXFx0XFx0cG93aSA9IDMyO1xcblxcdH0gZWxzZSBpZiAoaW5kZXggPT0gNikge1xcblxcdFxcdHBvd2kgPSA2NDtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDcpIHtcXG5cXHRcXHRwb3dpID0gMTI4O1xcblxcdH1cXG5cXG5cXHRpbnQgbmRwID0gbnVtYmVyIC8gcG93aTtcXG5cXG5cXHRyZXR1cm4gbW9kKGZsb2F0KG5kcCksIDIuMCkgIT0gMC4wO1xcbn1cXG5cXG4vKipcXG4gKiBHZXRzIHRoZSB0aGUgTE9EIGF0IHRoZSBwb2ludCBwb3NpdGlvbi5cXG4gKi9cXG5mbG9hdCBnZXRMT0QoKSB7XFxuXFx0dmVjMyBvZmZzZXQgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcblxcdGludCBpT2Zmc2V0ID0gaW50KHZuU3RhcnQpO1xcblxcdGZsb2F0IGRlcHRoID0gbGV2ZWw7XFxuXFxuXFx0Zm9yIChmbG9hdCBpID0gMC4wOyBpIDw9IDMwLjA7IGkrKykge1xcblxcdFxcdGZsb2F0IG5vZGVTaXplQXRMZXZlbCA9IG9jdHJlZVNpemUgIC8gcG93KDIuMCwgaSArIGxldmVsICsgMC4wKTtcXG5cXG5cXHRcXHR2ZWMzIGluZGV4M2QgPSAocG9zaXRpb24tb2Zmc2V0KSAvIG5vZGVTaXplQXRMZXZlbDtcXG5cXHRcXHRpbmRleDNkID0gZmxvb3IoaW5kZXgzZCArIDAuNSk7XFxuXFx0XFx0aW50IGluZGV4ID0gaW50KHJvdW5kKDQuMCAqIGluZGV4M2QueCArIDIuMCAqIGluZGV4M2QueSArIGluZGV4M2QueikpO1xcblxcblxcdFxcdHZlYzQgdmFsdWUgPSB0ZXh0dXJlMkQodmlzaWJsZU5vZGVzLCB2ZWMyKGZsb2F0KGlPZmZzZXQpIC8gMjA0OC4wLCAwLjApKTtcXG5cXHRcXHRpbnQgbWFzayA9IGludChyb3VuZCh2YWx1ZS5yICogMjU1LjApKTtcXG5cXG5cXHRcXHRpZiAoaXNCaXRTZXQobWFzaywgaW5kZXgpKSB7XFxuXFx0XFx0XFx0Ly8gdGhlcmUgYXJlIG1vcmUgdmlzaWJsZSBjaGlsZCBub2RlcyBhdCB0aGlzIHBvc2l0aW9uXFxuXFx0XFx0XFx0aW50IGFkdmFuY2VHID0gaW50KHJvdW5kKHZhbHVlLmcgKiAyNTUuMCkpICogMjU2O1xcblxcdFxcdFxcdGludCBhZHZhbmNlQiA9IGludChyb3VuZCh2YWx1ZS5iICogMjU1LjApKTtcXG5cXHRcXHRcXHRpbnQgYWR2YW5jZUNoaWxkID0gbnVtYmVyT2ZPbmVzKG1hc2ssIGluZGV4IC0gMSk7XFxuXFx0XFx0XFx0aW50IGFkdmFuY2UgPSBhZHZhbmNlRyArIGFkdmFuY2VCICsgYWR2YW5jZUNoaWxkO1xcblxcblxcdFxcdFxcdGlPZmZzZXQgPSBpT2Zmc2V0ICsgYWR2YW5jZTtcXG5cXG5cXHRcXHRcXHRkZXB0aCsrO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZhbHVlLmEgKiAyNTUuMDsgLy8gbm8gbW9yZSB2aXNpYmxlIGNoaWxkIG5vZGVzIGF0IHRoaXMgcG9zaXRpb25cXG5cXHRcXHR9XFxuXFxuXFx0XFx0b2Zmc2V0ID0gb2Zmc2V0ICsgKHZlYzMoMS4wLCAxLjAsIDEuMCkgKiBub2RlU2l6ZUF0TGV2ZWwgKiAwLjUpICogaW5kZXgzZDtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGRlcHRoO1xcbn1cXG5cXG5mbG9hdCBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpIHtcXG5cXHRyZXR1cm4gMC41ICogcG93KDIuMCwgZ2V0TE9EKCkpO1xcbn1cXG5cXG4jZW5kaWZcXG5cXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4vLyBLRC1UUkVFXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuI2lmIChkZWZpbmVkKGFkYXB0aXZlX3BvaW50X3NpemUpIHx8IGRlZmluZWQoY29sb3JfdHlwZV9sb2QpKSAmJiBkZWZpbmVkKHRyZWVfdHlwZV9rZHRyZWUpXFxuXFxuZmxvYXQgZ2V0TE9EKCkge1xcblxcdHZlYzMgb2Zmc2V0ID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXHRmbG9hdCBpbnRPZmZzZXQgPSAwLjA7XFxuXFx0ZmxvYXQgZGVwdGggPSAwLjA7XFxuXFxuXFx0dmVjMyBzaXplID0gYmJTaXplO1xcblxcdHZlYzMgcG9zID0gcG9zaXRpb247XFxuXFxuXFx0Zm9yIChmbG9hdCBpID0gMC4wOyBpIDw9IDEwMDAuMDsgaSsrKSB7XFxuXFxuXFx0XFx0dmVjNCB2YWx1ZSA9IHRleHR1cmUyRCh2aXNpYmxlTm9kZXMsIHZlYzIoaW50T2Zmc2V0IC8gMjA0OC4wLCAwLjApKTtcXG5cXG5cXHRcXHRpbnQgY2hpbGRyZW4gPSBpbnQodmFsdWUuciAqIDI1NS4wKTtcXG5cXHRcXHRmbG9hdCBuZXh0ID0gdmFsdWUuZyAqIDI1NS4wO1xcblxcdFxcdGludCBzcGxpdCA9IGludCh2YWx1ZS5iICogMjU1LjApO1xcblxcblxcdFxcdGlmIChuZXh0ID09IDAuMCkge1xcblxcdFxcdCBcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0fVxcblxcblxcdFxcdHZlYzMgc3BsaXR2ID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHRpZiAoc3BsaXQgPT0gMSkge1xcblxcdFxcdFxcdHNwbGl0di54ID0gMS4wO1xcblxcdFxcdH0gZWxzZSBpZiAoc3BsaXQgPT0gMikge1xcblxcdFxcdCBcXHRzcGxpdHYueSA9IDEuMDtcXG5cXHRcXHR9IGVsc2UgaWYgKHNwbGl0ID09IDQpIHtcXG5cXHRcXHQgXFx0c3BsaXR2LnogPSAxLjA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGludE9mZnNldCA9IGludE9mZnNldCArIG5leHQ7XFxuXFxuXFx0XFx0ZmxvYXQgZmFjdG9yID0gbGVuZ3RoKHBvcyAqIHNwbGl0diAvIHNpemUpO1xcblxcdFxcdGlmIChmYWN0b3IgPCAwLjUpIHtcXG5cXHRcXHQgXFx0Ly8gbGVmdFxcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAwIHx8IGNoaWxkcmVuID09IDIpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gcmlnaHRcXG5cXHRcXHRcXHRwb3MgPSBwb3MgLSBzaXplICogc3BsaXR2ICogMC41O1xcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAwIHx8IGNoaWxkcmVuID09IDEpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZGVwdGg7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmIChjaGlsZHJlbiA9PSAzKSB7XFxuXFx0XFx0XFx0XFx0aW50T2Zmc2V0ID0gaW50T2Zmc2V0ICsgMS4wO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0c2l6ZSA9IHNpemUgKiAoKDEuMCAtIChzcGxpdHYgKyAxLjApIC8gMi4wKSArIDAuNSk7XFxuXFxuXFx0XFx0ZGVwdGgrKztcXG5cXHR9XFxuXFxuXFxuXFx0cmV0dXJuIGRlcHRoO1xcbn1cXG5cXG5mbG9hdCBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpIHtcXG5cXHRyZXR1cm4gMC41ICogcG93KDEuMywgZ2V0TE9EKCkpO1xcbn1cXG5cXG4jZW5kaWZcXG5cXG4vLyBmb3JtdWxhIGFkYXB0ZWQgZnJvbTogaHR0cDovL3d3dy5kZnN0dWRpb3MuY28udWsvYXJ0aWNsZXMvcHJvZ3JhbW1pbmcvaW1hZ2UtcHJvZ3JhbW1pbmctYWxnb3JpdGhtcy9pbWFnZS1wcm9jZXNzaW5nLWFsZ29yaXRobXMtcGFydC01LWNvbnRyYXN0LWFkanVzdG1lbnQvXFxuZmxvYXQgZ2V0Q29udHJhc3RGYWN0b3IoZmxvYXQgY29udHJhc3QpIHtcXG5cXHRyZXR1cm4gKDEuMDE1ODczMDE1ODczMDE1NiAqIChjb250cmFzdCArIDEuMCkpIC8gKDEuMDE1ODczMDE1ODczMDE1NiAtIGNvbnRyYXN0KTtcXG59XFxuXFxudmVjMyBnZXRSR0IoKSB7XFxuXFx0XFxuXFx0I2lmZGVmIGNvbG9yX3JnYmFcXG5cXHRcXHR2ZWMzIHJnYiA9IHJnYmEucmdiO1xcblxcdCNlbHNlXFx0XFxuXFx0XFx0dmVjMyByZ2IgPSBjb2xvcjtcXG5cXHQjZW5kaWZcXHRcXHRcXG5cXG5cXHQjaWYgZGVmaW5lZCh1c2VfcmdiX2dhbW1hX2NvbnRyYXN0X2JyaWdodG5lc3MpXFxuXFx0XFx0cmdiID0gcG93KHJnYiwgdmVjMyhyZ2JHYW1tYSkpO1xcblxcdFxcdHJnYiA9IHJnYiArIHJnYkJyaWdodG5lc3M7XFxuXFx0XFx0cmdiID0gKHJnYiAtIDAuNSkgKiBnZXRDb250cmFzdEZhY3RvcihyZ2JDb250cmFzdCkgKyAwLjU7XFxuXFx0XFx0cmdiID0gY2xhbXAocmdiLCAwLjAsIDEuMCk7XFxuXFx0XFx0cmV0dXJuIHJnYjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiByZ2I7XFxuXFx0I2VuZGlmXFxufVxcblxcbmZsb2F0IGdldEludGVuc2l0eSgpIHtcXG5cXHRmbG9hdCB3ID0gKGludGVuc2l0eSAtIGludGVuc2l0eVJhbmdlLngpIC8gKGludGVuc2l0eVJhbmdlLnkgLSBpbnRlbnNpdHlSYW5nZS54KTtcXG5cXHR3ID0gcG93KHcsIGludGVuc2l0eUdhbW1hKTtcXG5cXHR3ID0gdyArIGludGVuc2l0eUJyaWdodG5lc3M7XFxuXFx0dyA9ICh3IC0gMC41KSAqIGdldENvbnRyYXN0RmFjdG9yKGludGVuc2l0eUNvbnRyYXN0KSArIDAuNTtcXG5cXHR3ID0gY2xhbXAodywgMC4wLCAxLjApO1xcblxcblxcdHJldHVybiB3O1xcbn1cXG5cXG52ZWMzIGdldEVsZXZhdGlvbigpIHtcXG5cXHR2ZWM0IHdvcmxkID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFx0ZmxvYXQgdyA9ICh3b3JsZC56IC0gaGVpZ2h0TWluKSAvIChoZWlnaHRNYXgtaGVpZ2h0TWluKTtcXG5cXHR2ZWMzIGNFbGV2YXRpb24gPSB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywxLjAtdykpLnJnYjtcXG5cXG5cXHRyZXR1cm4gY0VsZXZhdGlvbjtcXG59XFxuXFxudmVjNCBnZXRDbGFzc2lmaWNhdGlvbigpIHtcXG5cXHR2ZWMyIHV2ID0gdmVjMihjbGFzc2lmaWNhdGlvbiAvIDI1NS4wLCAwLjUpO1xcblxcdHZlYzQgY2xhc3NDb2xvciA9IHRleHR1cmUyRChjbGFzc2lmaWNhdGlvbkxVVCwgdXYpO1xcblxcblxcdHJldHVybiBjbGFzc0NvbG9yO1xcbn1cXG5cXG52ZWMzIGdldFJldHVybk51bWJlcigpIHtcXG5cXHRpZiAobnVtYmVyT2ZSZXR1cm5zID09IDEuMCkge1xcblxcdFxcdHJldHVybiB2ZWMzKDEuMCwgMS4wLCAwLjApO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0aWYgKHJldHVybk51bWJlciA9PSAxLjApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMygxLjAsIDAuMCwgMC4wKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHJldHVybk51bWJlciA9PSBudW1iZXJPZlJldHVybnMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMygwLjAsIDAuMCwgMS4wKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJldHVybiB2ZWMzKDAuMCwgMS4wLCAwLjApO1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbnZlYzMgZ2V0U291cmNlSUQoKSB7XFxuXFx0ZmxvYXQgdyA9IG1vZChwb2ludFNvdXJjZUlELCAxMC4wKSAvIDEwLjA7XFxuXFx0cmV0dXJuIHRleHR1cmUyRChncmFkaWVudCwgdmVjMih3LCAxLjAgLSB3KSkucmdiO1xcbn1cXG5cXG52ZWMzIGdldENvbXBvc2l0ZUNvbG9yKCkge1xcblxcdHZlYzMgYztcXG5cXHRmbG9hdCB3O1xcblxcblxcdGMgKz0gd1JHQiAqIGdldFJHQigpO1xcblxcdHcgKz0gd1JHQjtcXG5cXG5cXHRjICs9IHdJbnRlbnNpdHkgKiBnZXRJbnRlbnNpdHkoKSAqIHZlYzMoMS4wLCAxLjAsIDEuMCk7XFxuXFx0dyArPSB3SW50ZW5zaXR5O1xcblxcblxcdGMgKz0gd0VsZXZhdGlvbiAqIGdldEVsZXZhdGlvbigpO1xcblxcdHcgKz0gd0VsZXZhdGlvbjtcXG5cXG5cXHRjICs9IHdSZXR1cm5OdW1iZXIgKiBnZXRSZXR1cm5OdW1iZXIoKTtcXG5cXHR3ICs9IHdSZXR1cm5OdW1iZXI7XFxuXFxuXFx0YyArPSB3U291cmNlSUQgKiBnZXRTb3VyY2VJRCgpO1xcblxcdHcgKz0gd1NvdXJjZUlEO1xcblxcblxcdHZlYzQgY2wgPSB3Q2xhc3NpZmljYXRpb24gKiBnZXRDbGFzc2lmaWNhdGlvbigpO1xcblxcdGMgKz0gY2wuYSAqIGNsLnJnYjtcXG5cXHR3ICs9IHdDbGFzc2lmaWNhdGlvbiAqIGNsLmE7XFxuXFxuXFx0YyA9IGMgLyB3O1xcblxcblxcdGlmICh3ID09IDAuMCkge1xcblxcdFxcdGdsX1Bvc2l0aW9uID0gdmVjNCgxMDAuMCwgMTAwLjAsIDEwMC4wLCAwLjApO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gYztcXG59XFxuXFxudm9pZCBtYWluKCkge1xcblxcdHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxuXFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cXG5cXHQjaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0XFx0dlZpZXdQb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkIHdlaWdodGVkX3NwbGF0c1xcblxcdFxcdHZMaW5lYXJEZXB0aCA9IGdsX1Bvc2l0aW9uLnc7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9waG9uZykgJiYgKE1BWF9QT0lOVF9MSUdIVFMgPiAwIHx8IE1BWF9ESVJfTElHSFRTID4gMClcXG5cXHRcXHR2Tm9ybWFsID0gbm9ybWFsaXplKG5vcm1hbE1hdHJpeCAqIG5vcm1hbCk7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHR2TG9nRGVwdGggPSBsb2cyKC1tdlBvc2l0aW9uLnopO1xcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIFBPSU5UIFNJWkVcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHRmbG9hdCBwb2ludFNpemUgPSAxLjA7XFxuXFx0ZmxvYXQgc2xvcGUgPSB0YW4oZm92IC8gMi4wKTtcXG5cXHRmbG9hdCBwcm9qRmFjdG9yID0gIC0wLjUgKiBzY3JlZW5IZWlnaHQgLyAoc2xvcGUgKiBtdlBvc2l0aW9uLnopO1xcblxcblxcdCNpZiBkZWZpbmVkIGZpeGVkX3BvaW50X3NpemVcXG5cXHRcXHRwb2ludFNpemUgPSBzaXplO1xcblxcdCNlbGlmIGRlZmluZWQgYXR0ZW51YXRlZF9wb2ludF9zaXplXFxuXFx0XFx0cG9pbnRTaXplID0gc2l6ZSAqIHNwYWNpbmcgKiBwcm9qRmFjdG9yO1xcblxcdCNlbGlmIGRlZmluZWQgYWRhcHRpdmVfcG9pbnRfc2l6ZVxcblxcdFxcdGZsb2F0IHdvcmxkU3BhY2VTaXplID0gMi4wICogc2l6ZSAqIHNwYWNpbmcgLyBnZXRQb2ludFNpemVBdHRlbnVhdGlvbigpO1xcblxcdFxcdHBvaW50U2l6ZSA9IHdvcmxkU3BhY2VTaXplICogcHJvakZhY3RvcjtcXG5cXHQjZW5kaWZcXG5cXG5cXHRwb2ludFNpemUgPSBtYXgobWluU2l6ZSwgcG9pbnRTaXplKTtcXG5cXHRwb2ludFNpemUgPSBtaW4obWF4U2l6ZSwgcG9pbnRTaXplKTtcXG5cXG5cXHQjaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpIHx8IGRlZmluZWQocGFyYWJvbG9pZF9wb2ludF9zaGFwZSlcXG5cXHRcXHR2UmFkaXVzID0gcG9pbnRTaXplIC8gcHJvakZhY3RvcjtcXG5cXHQjZW5kaWZcXG5cXG5cXHRnbF9Qb2ludFNpemUgPSBwb2ludFNpemU7XFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gSElHSExJR0hUSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdFxcdHZlYzQgbVBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcdFxcdGlmIChlbmFibGVQb2ludEhpZ2hsaWdodGluZyAmJiBhYnMobVBvc2l0aW9uLnggLSBoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZS54KSA8IDAuMDAwMSAmJlxcblxcdFxcdFxcdGFicyhtUG9zaXRpb24ueSAtIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlLnkpIDwgMC4wMDAxICYmXFxuXFx0XFx0XFx0YWJzKG1Qb3NpdGlvbi56IC0gaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGUueikgPCAwLjAwMDEpIHtcXG5cXHRcXHRcXHR2SGlnaGxpZ2h0ID0gMS4wO1xcblxcdFxcdFxcdGdsX1BvaW50U2l6ZSA9IHBvaW50U2l6ZSAqIGhpZ2hsaWdodGVkUG9pbnRTY2FsZTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZIaWdobGlnaHQgPSAwLjA7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIE9QQUNJVFlcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHQjaWZuZGVmIGNvbG9yX3R5cGVfcG9pbnRfaW5kZXhcXG5cXHRcXHQjaWZkZWYgYXR0ZW51YXRlZF9vcGFjaXR5XFxuXFx0XFx0XFx0dk9wYWNpdHkgPSBvcGFjaXR5ICogZXhwKC1sZW5ndGgoLW12UG9zaXRpb24ueHl6KSAvIG9wYWNpdHlBdHRlbnVhdGlvbik7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHR2T3BhY2l0eSA9IG9wYWNpdHk7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gRklMVEVSSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmZGVmIHVzZV9maWx0ZXJfYnlfbm9ybWFsXFxuXFx0XFx0Ym9vbCBkaXNjYXJkUG9pbnQgPSBmYWxzZTtcXG5cXHRcXHQvLyBBYnNvbHV0ZSBub3JtYWwgZmlsdGVyaW5nXFxuXFx0XFx0aWYgKG5vcm1hbEZpbHRlcmluZ01vZGUgPT0gMSkge1xcblxcdFxcdFxcdGRpc2NhcmRQb2ludCA9IChhYnMoKG1vZGVsVmlld01hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS56KSA+IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkKTtcXG5cXHRcXHR9XFxuXFx0XFx0Ly8gbGVzcyB0aGFuIGVxdWFsIHRvXFxuXFx0XFx0ZWxzZSBpZiAobm9ybWFsRmlsdGVyaW5nTW9kZSA9PSAyKSB7XFxuXFx0XFx0XFx0ZGlzY2FyZFBvaW50ID0gKG1vZGVsVmlld01hdHJpeCAqIHZlYzQobm9ybWFsLCAwLjApKS56IDw9IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHQvLyBncmVhdGVyIHRoYW5cXG5cXHRcXHRlbHNlIGlmKG5vcm1hbEZpbHRlcmluZ01vZGUgPT0gMykge1xcblxcdFxcdFxcdGRpc2NhcmRQb2ludCA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueiA+IGZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoZGlzY2FyZFBvaW50KVxcblxcdFxcdHtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMC4wLCAwLjAsIDIuMCwgMS4wKTtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFx0Ly8gUE9JTlQgQ09MT1JcXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXHQjaWZkZWYgY29sb3JfdHlwZV9yZ2JcXG5cXHRcXHR2Q29sb3IgPSBnZXRSR0IoKTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfaGVpZ2h0XFxuXFx0XFx0dkNvbG9yID0gZ2V0RWxldmF0aW9uKCk7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX3JnYl9oZWlnaHRcXG5cXHRcXHR2ZWMzIGNIZWlnaHQgPSBnZXRFbGV2YXRpb24oKTtcXG5cXHRcXHR2Q29sb3IgPSAoMS4wIC0gdHJhbnNpdGlvbikgKiBnZXRSR0IoKSArIHRyYW5zaXRpb24gKiBjSGVpZ2h0O1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9kZXB0aFxcblxcdFxcdGZsb2F0IGxpbmVhckRlcHRoID0gLW12UG9zaXRpb24ueiA7XFxuXFx0XFx0ZmxvYXQgZXhwRGVwdGggPSAoZ2xfUG9zaXRpb24ueiAvIGdsX1Bvc2l0aW9uLncpICogMC41ICsgMC41O1xcblxcdFxcdHZDb2xvciA9IHZlYzMobGluZWFyRGVwdGgsIGV4cERlcHRoLCAwLjApO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9pbnRlbnNpdHlcXG5cXHRcXHRmbG9hdCB3ID0gZ2V0SW50ZW5zaXR5KCk7XFxuXFx0XFx0dkNvbG9yID0gdmVjMyh3LCB3LCB3KTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfaW50ZW5zaXR5X2dyYWRpZW50XFxuXFx0XFx0ZmxvYXQgdyA9IGdldEludGVuc2l0eSgpO1xcblxcdFxcdHZDb2xvciA9IHRleHR1cmUyRChncmFkaWVudCwgdmVjMih3LCAxLjAgLSB3KSkucmdiO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9jb2xvclxcblxcdFxcdHZDb2xvciA9IHVDb2xvcjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfbG9kXFxuXFx0ZmxvYXQgdyA9IGdldExPRCgpIC8gMTAuMDtcXG5cXHR2Q29sb3IgPSB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywgMS4wIC0gdykpLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfcG9pbnRfaW5kZXhcXG5cXHRcXHR2Q29sb3IgPSBpbmRpY2VzLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfY2xhc3NpZmljYXRpb25cXG5cXHQgIHZlYzQgY2wgPSBnZXRDbGFzc2lmaWNhdGlvbigpO1xcblxcdFxcdHZDb2xvciA9IGNsLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfcmV0dXJuX251bWJlclxcblxcdFxcdHZDb2xvciA9IGdldFJldHVybk51bWJlcigpO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9zb3VyY2VcXG5cXHRcXHR2Q29sb3IgPSBnZXRTb3VyY2VJRCgpO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9ub3JtYWxcXG5cXHRcXHR2Q29sb3IgPSAobW9kZWxNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueHl6O1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9waG9uZ1xcblxcdFxcdHZDb2xvciA9IGNvbG9yO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9jb21wb3NpdGVcXG5cXHRcXHR2Q29sb3IgPSBnZXRDb21wb3NpdGVDb2xvcigpO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiAhZGVmaW5lZCBjb2xvcl90eXBlX2NvbXBvc2l0ZSAmJiBkZWZpbmVkIGNvbG9yX3R5cGVfY2xhc3NpZmljYXRpb25cXG5cXHRcXHRpZiAoY2wuYSA9PSAwLjApIHtcXG5cXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMTAwLjAsIDEwMC4wLCAxMDAuMCwgMC4wKTtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIENMSVBQSU5HXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmIGRlZmluZWQgdXNlX2NsaXBfYm94XFxuXFx0XFx0Ym9vbCBpbnNpZGVBbnkgPSBmYWxzZTtcXG5cXHRcXHRmb3IgKGludCBpID0gMDsgaSA8IG1heF9jbGlwX2JveGVzOyBpKyspIHtcXG5cXHRcXHRcXHRpZiAoaSA9PSBpbnQoY2xpcEJveENvdW50KSkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2ZWM0IGNsaXBQb3NpdGlvbiA9IGNsaXBCb3hlc1tpXSAqIG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHRcXHRcXHRib29sIGluc2lkZSA9IC0wLjUgPD0gY2xpcFBvc2l0aW9uLnggJiYgY2xpcFBvc2l0aW9uLnggPD0gMC41O1xcblxcdFxcdFxcdGluc2lkZSA9IGluc2lkZSAmJiAtMC41IDw9IGNsaXBQb3NpdGlvbi55ICYmIGNsaXBQb3NpdGlvbi55IDw9IDAuNTtcXG5cXHRcXHRcXHRpbnNpZGUgPSBpbnNpZGUgJiYgLTAuNSA8PSBjbGlwUG9zaXRpb24ueiAmJiBjbGlwUG9zaXRpb24ueiA8PSAwLjU7XFxuXFx0XFx0XFx0aW5zaWRlQW55ID0gaW5zaWRlQW55IHx8IGluc2lkZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCFpbnNpZGVBbnkpIHtcXG5cXHRcXHRcXHQjaWYgZGVmaW5lZCBjbGlwX291dHNpZGVcXG5cXHRcXHRcXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMTAwMC4wLCAxMDAwLjAsIDEwMDAuMCwgMS4wKTtcXG5cXHRcXHRcXHQjZWxpZiBkZWZpbmVkIGNsaXBfaGlnaGxpZ2h0X2luc2lkZSAmJiAhZGVmaW5lZChjb2xvcl90eXBlX2RlcHRoKVxcblxcdFxcdFxcdFxcdGZsb2F0IGMgPSAodkNvbG9yLnIgKyB2Q29sb3IuZyArIHZDb2xvci5iKSAvIDYuMDtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCNpZiBkZWZpbmVkIGNsaXBfaGlnaGxpZ2h0X2luc2lkZVxcblxcdFxcdFxcdFxcdHZDb2xvci5yICs9IDAuNTtcXG5cXHRcXHRcXHQjZW5kaWZcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxufVxcblwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///245\n')},238:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  BlurMaterial: () => (/* reexport */ BlurMaterial),\n  ClipMode: () => (/* reexport */ ClipMode),\n  GRAYSCALE: () => (/* reexport */ GRAYSCALE),\n  INFERNO: () => (/* reexport */ INFERNO),\n  NormalFilteringMode: () => (/* reexport */ NormalFilteringMode),\n  PLASMA: () => (/* reexport */ PLASMA),\n  POINT_ATTRIBUTES: () => (/* reexport */ POINT_ATTRIBUTES),\n  POINT_ATTRIBUTE_TYPES: () => (/* reexport */ POINT_ATTRIBUTE_TYPES),\n  PointAttributeName: () => (/* reexport */ PointAttributeName),\n  PointAttributes: () => (/* reexport */ PointAttributes),\n  PointCloudMaterial: () => (/* reexport */ PointCloudMaterial),\n  PointCloudMixingMode: () => (/* reexport */ PointCloudMixingMode),\n  PointCloudOctree: () => (/* reexport */ PointCloudOctree),\n  PointCloudOctreeGeometry: () => (/* reexport */ PointCloudOctreeGeometry),\n  PointCloudOctreeGeometryNode: () => (/* reexport */ PointCloudOctreeGeometryNode),\n  PointCloudOctreeNode: () => (/* reexport */ PointCloudOctreeNode),\n  PointCloudOctreePicker: () => (/* reexport */ PointCloudOctreePicker),\n  PointCloudTree: () => (/* reexport */ PointCloudTree),\n  PointColorType: () => (/* reexport */ PointColorType),\n  PointOpacityType: () => (/* reexport */ PointOpacityType),\n  PointShape: () => (/* reexport */ PointShape),\n  PointSizeType: () => (/* reexport */ PointSizeType),\n  Potree: () => (/* reexport */ Potree),\n  QueueItem: () => (/* reexport */ QueueItem),\n  RAINBOW: () => (/* reexport */ RAINBOW),\n  SPECTRAL: () => (/* reexport */ SPECTRAL),\n  TreeType: () => (/* reexport */ TreeType),\n  V1_LOADER: () => (/* reexport */ loadPOC),\n  V2_LOADER: () => (/* reexport */ loadOctree),\n  VIRIDIS: () => (/* reexport */ VIRIDIS),\n  Version: () => (/* reexport */ Version),\n  YELLOW_GREEN: () => (/* reexport */ YELLOW_GREEN),\n  generateClassificationTexture: () => (/* reexport */ generateClassificationTexture),\n  generateDataTexture: () => (/* reexport */ generateDataTexture),\n  generateGradientTexture: () => (/* reexport */ generateGradientTexture)\n});\n\n// EXTERNAL MODULE: external \"three\"\nvar external_three_ = __webpack_require__(604);\n;// CONCATENATED MODULE: ./src/materials/blur-material.ts\n\nclass BlurMaterial extends external_three_.ShaderMaterial {\n    constructor() {\n        super(...arguments);\n        this.vertexShader = __webpack_require__(575);\n        this.fragmentShader = __webpack_require__(414);\n        this.uniforms = {\n            screenWidth: { type: 'f', value: 0 },\n            screenHeight: { type: 'f', value: 0 },\n            map: { type: 't', value: null },\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./src/materials/clipping.ts\nvar ClipMode;\n(function (ClipMode) {\n    ClipMode[ClipMode[\"DISABLED\"] = 0] = \"DISABLED\";\n    ClipMode[ClipMode[\"CLIP_OUTSIDE\"] = 1] = \"CLIP_OUTSIDE\";\n    ClipMode[ClipMode[\"HIGHLIGHT_INSIDE\"] = 2] = \"HIGHLIGHT_INSIDE\";\n    ClipMode[ClipMode[\"CLIP_HORIZONTALLY\"] = 3] = \"CLIP_HORIZONTALLY\";\n    ClipMode[ClipMode[\"CLIP_VERTICALLY\"] = 4] = \"CLIP_VERTICALLY\";\n})(ClipMode || (ClipMode = {}));\n\n;// CONCATENATED MODULE: ./src/materials/enums.ts\nvar PointSizeType;\n(function (PointSizeType) {\n    PointSizeType[PointSizeType[\"FIXED\"] = 0] = \"FIXED\";\n    PointSizeType[PointSizeType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\n    PointSizeType[PointSizeType[\"ADAPTIVE\"] = 2] = \"ADAPTIVE\";\n})(PointSizeType || (PointSizeType = {}));\nvar PointShape;\n(function (PointShape) {\n    PointShape[PointShape[\"SQUARE\"] = 0] = \"SQUARE\";\n    PointShape[PointShape[\"CIRCLE\"] = 1] = \"CIRCLE\";\n    PointShape[PointShape[\"PARABOLOID\"] = 2] = \"PARABOLOID\";\n})(PointShape || (PointShape = {}));\nvar TreeType;\n(function (TreeType) {\n    TreeType[TreeType[\"OCTREE\"] = 0] = \"OCTREE\";\n    TreeType[TreeType[\"KDTREE\"] = 1] = \"KDTREE\";\n})(TreeType || (TreeType = {}));\nvar PointOpacityType;\n(function (PointOpacityType) {\n    PointOpacityType[PointOpacityType[\"FIXED\"] = 0] = \"FIXED\";\n    PointOpacityType[PointOpacityType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\n})(PointOpacityType || (PointOpacityType = {}));\nvar PointColorType;\n(function (PointColorType) {\n    PointColorType[PointColorType[\"RGB\"] = 0] = \"RGB\";\n    PointColorType[PointColorType[\"COLOR\"] = 1] = \"COLOR\";\n    PointColorType[PointColorType[\"DEPTH\"] = 2] = \"DEPTH\";\n    PointColorType[PointColorType[\"HEIGHT\"] = 3] = \"HEIGHT\";\n    PointColorType[PointColorType[\"ELEVATION\"] = 3] = \"ELEVATION\";\n    PointColorType[PointColorType[\"INTENSITY\"] = 4] = \"INTENSITY\";\n    PointColorType[PointColorType[\"INTENSITY_GRADIENT\"] = 5] = \"INTENSITY_GRADIENT\";\n    PointColorType[PointColorType[\"LOD\"] = 6] = \"LOD\";\n    PointColorType[PointColorType[\"LEVEL_OF_DETAIL\"] = 6] = \"LEVEL_OF_DETAIL\";\n    PointColorType[PointColorType[\"POINT_INDEX\"] = 7] = \"POINT_INDEX\";\n    PointColorType[PointColorType[\"CLASSIFICATION\"] = 8] = \"CLASSIFICATION\";\n    PointColorType[PointColorType[\"RETURN_NUMBER\"] = 9] = \"RETURN_NUMBER\";\n    PointColorType[PointColorType[\"SOURCE\"] = 10] = \"SOURCE\";\n    PointColorType[PointColorType[\"NORMAL\"] = 11] = \"NORMAL\";\n    PointColorType[PointColorType[\"PHONG\"] = 12] = \"PHONG\";\n    PointColorType[PointColorType[\"RGB_HEIGHT\"] = 13] = \"RGB_HEIGHT\";\n    PointColorType[PointColorType[\"COMPOSITE\"] = 50] = \"COMPOSITE\";\n})(PointColorType || (PointColorType = {}));\nvar NormalFilteringMode;\n(function (NormalFilteringMode) {\n    NormalFilteringMode[NormalFilteringMode[\"ABSOLUTE_NORMAL_FILTERING_MODE\"] = 1] = \"ABSOLUTE_NORMAL_FILTERING_MODE\";\n    NormalFilteringMode[NormalFilteringMode[\"LESS_EQUAL_NORMAL_FILTERING_MODE\"] = 2] = \"LESS_EQUAL_NORMAL_FILTERING_MODE\";\n    NormalFilteringMode[NormalFilteringMode[\"GREATER_NORMAL_FILTERING_MODE\"] = 3] = \"GREATER_NORMAL_FILTERING_MODE\";\n})(NormalFilteringMode || (NormalFilteringMode = {}));\nvar PointCloudMixingMode;\n(function (PointCloudMixingMode) {\n    PointCloudMixingMode[PointCloudMixingMode[\"CHECKBOARD\"] = 1] = \"CHECKBOARD\";\n    PointCloudMixingMode[PointCloudMixingMode[\"STRIPES\"] = 2] = \"STRIPES\";\n})(PointCloudMixingMode || (PointCloudMixingMode = {}));\n\n;// CONCATENATED MODULE: ./src/constants.ts\n\nconst DEFAULT_RGB_BRIGHTNESS = 0;\nconst DEFAULT_RGB_CONTRAST = 0;\nconst DEFAULT_RGB_GAMMA = 1;\nconst DEFAULT_MAX_POINT_SIZE = 50;\nconst DEFAULT_MIN_NODE_PIXEL_SIZE = 50;\nconst DEFAULT_MIN_POINT_SIZE = 2;\nconst DEFAULT_PICK_WINDOW_SIZE = 15;\nconst DEFAULT_POINT_BUDGET = 1000000;\nconst MAX_LOADS_TO_GPU = 2;\nconst MAX_NUM_NODES_LOADING = 4;\nconst PERSPECTIVE_CAMERA = 'PerspectiveCamera';\nconst COLOR_BLACK = new external_three_.Color(0, 0, 0);\nconst DEFAULT_HIGHLIGHT_COLOR = new external_three_.Vector4(1, 0, 0, 1);\n\n;// CONCATENATED MODULE: ./src/utils/utils.ts\nfunction getIndexFromName(name) {\n    return parseInt(name.charAt(name.length - 1), 10);\n}\n/**\n * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...\n */\nfunction byLevelAndIndex(a, b) {\n    const na = a.name;\n    const nb = b.name;\n    if (na.length !== nb.length) {\n        return na.length - nb.length;\n    }\n    else if (na < nb) {\n        return -1;\n    }\n    else if (na > nb) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction handleFailedRequest(response) {\n    if (response.status !== 200) {\n        throw Error('Response error');\n    }\n    return response;\n}\nfunction handleEmptyBuffer(buffer) {\n    if (!buffer || buffer.byteLength === 0) {\n        throw Error('Empty buffer');\n    }\n    return buffer;\n}\n\n;// CONCATENATED MODULE: ./src/materials/classification.ts\n\nconst DEFAULT_CLASSIFICATION = {\n    0: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\n    1: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\n    2: new external_three_.Vector4(0.63, 0.32, 0.18, 1.0),\n    3: new external_three_.Vector4(0.0, 1.0, 0.0, 1.0),\n    4: new external_three_.Vector4(0.0, 0.8, 0.0, 1.0),\n    5: new external_three_.Vector4(0.0, 0.6, 0.0, 1.0),\n    6: new external_three_.Vector4(1.0, 0.66, 0.0, 1.0),\n    7: new external_three_.Vector4(1.0, 0, 1.0, 1.0),\n    8: new external_three_.Vector4(1.0, 0, 0.0, 1.0),\n    9: new external_three_.Vector4(0.0, 0.0, 1.0, 1.0),\n    12: new external_three_.Vector4(1.0, 1.0, 0.0, 1.0),\n    DEFAULT: new external_three_.Vector4(0.3, 0.6, 0.6, 0.5),\n};\n\n;// CONCATENATED MODULE: ./src/materials/gradients/grayscale.ts\n\nconst GRAYSCALE = [\n    [0, new external_three_.Color(0, 0, 0)],\n    [1, new external_three_.Color(1, 1, 1)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/inferno.ts\n\nconst INFERNO = [\n    [0.0, new external_three_.Color(0.077, 0.042, 0.206)],\n    [0.1, new external_three_.Color(0.225, 0.036, 0.388)],\n    [0.2, new external_three_.Color(0.373, 0.074, 0.432)],\n    [0.3, new external_three_.Color(0.522, 0.128, 0.42)],\n    [0.4, new external_three_.Color(0.665, 0.182, 0.37)],\n    [0.5, new external_three_.Color(0.797, 0.255, 0.287)],\n    [0.6, new external_three_.Color(0.902, 0.364, 0.184)],\n    [0.7, new external_three_.Color(0.969, 0.516, 0.063)],\n    [0.8, new external_three_.Color(0.988, 0.683, 0.072)],\n    [0.9, new external_three_.Color(0.961, 0.859, 0.298)],\n    [1.0, new external_three_.Color(0.988, 0.998, 0.645)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/plasma.ts\n\nconst PLASMA = [\n    [0.0, new external_three_.Color(0.241, 0.015, 0.61)],\n    [0.1, new external_three_.Color(0.387, 0.001, 0.654)],\n    [0.2, new external_three_.Color(0.524, 0.025, 0.653)],\n    [0.3, new external_three_.Color(0.651, 0.125, 0.596)],\n    [0.4, new external_three_.Color(0.752, 0.227, 0.513)],\n    [0.5, new external_three_.Color(0.837, 0.329, 0.431)],\n    [0.6, new external_three_.Color(0.907, 0.435, 0.353)],\n    [0.7, new external_three_.Color(0.963, 0.554, 0.272)],\n    [0.8, new external_three_.Color(0.992, 0.681, 0.195)],\n    [0.9, new external_three_.Color(0.987, 0.822, 0.144)],\n    [1.0, new external_three_.Color(0.94, 0.975, 0.131)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/rainbow.ts\n\nconst RAINBOW = [\n    [0, new external_three_.Color(0.278, 0, 0.714)],\n    [1 / 6, new external_three_.Color(0, 0, 1)],\n    [2 / 6, new external_three_.Color(0, 1, 1)],\n    [3 / 6, new external_three_.Color(0, 1, 0)],\n    [4 / 6, new external_three_.Color(1, 1, 0)],\n    [5 / 6, new external_three_.Color(1, 0.64, 0)],\n    [1, new external_three_.Color(1, 0, 0)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/spectral.ts\n\n// From chroma spectral http://gka.github.io/chroma.js/\nconst SPECTRAL = [\n    [0, new external_three_.Color(0.3686, 0.3098, 0.6353)],\n    [0.1, new external_three_.Color(0.1961, 0.5333, 0.7412)],\n    [0.2, new external_three_.Color(0.4, 0.7608, 0.6471)],\n    [0.3, new external_three_.Color(0.6706, 0.8667, 0.6431)],\n    [0.4, new external_three_.Color(0.902, 0.9608, 0.5961)],\n    [0.5, new external_three_.Color(1.0, 1.0, 0.749)],\n    [0.6, new external_three_.Color(0.9961, 0.8784, 0.5451)],\n    [0.7, new external_three_.Color(0.9922, 0.6824, 0.3804)],\n    [0.8, new external_three_.Color(0.9569, 0.4275, 0.2627)],\n    [0.9, new external_three_.Color(0.8353, 0.2431, 0.3098)],\n    [1, new external_three_.Color(0.6196, 0.0039, 0.2588)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/vidris.ts\n\nconst VIRIDIS = [\n    [0.0, new external_three_.Color(0.267, 0.005, 0.329)],\n    [0.1, new external_three_.Color(0.283, 0.141, 0.458)],\n    [0.2, new external_three_.Color(0.254, 0.265, 0.53)],\n    [0.3, new external_three_.Color(0.207, 0.372, 0.553)],\n    [0.4, new external_three_.Color(0.164, 0.471, 0.558)],\n    [0.5, new external_three_.Color(0.128, 0.567, 0.551)],\n    [0.6, new external_three_.Color(0.135, 0.659, 0.518)],\n    [0.7, new external_three_.Color(0.267, 0.749, 0.441)],\n    [0.8, new external_three_.Color(0.478, 0.821, 0.318)],\n    [0.9, new external_three_.Color(0.741, 0.873, 0.15)],\n    [1.0, new external_three_.Color(0.993, 0.906, 0.144)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/yellow-green.ts\n\nconst YELLOW_GREEN = [\n    [0, new external_three_.Color(0.1647, 0.2824, 0.3451)],\n    [0.1, new external_three_.Color(0.1338, 0.3555, 0.4227)],\n    [0.2, new external_three_.Color(0.061, 0.4319, 0.4864)],\n    [0.3, new external_three_.Color(0.0, 0.5099, 0.5319)],\n    [0.4, new external_three_.Color(0.0, 0.5881, 0.5569)],\n    [0.5, new external_three_.Color(0.137, 0.665, 0.5614)],\n    [0.6, new external_three_.Color(0.2906, 0.7395, 0.5477)],\n    [0.7, new external_three_.Color(0.4453, 0.8099, 0.5201)],\n    [0.8, new external_three_.Color(0.6102, 0.8748, 0.485)],\n    [0.9, new external_three_.Color(0.7883, 0.9323, 0.4514)],\n    [1, new external_three_.Color(0.9804, 0.9804, 0.4314)],\n];\n\n;// CONCATENATED MODULE: ./src/materials/gradients/index.ts\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/materials/texture-generation.ts\n\nfunction generateDataTexture(width, height, color) {\n    const size = width * height;\n    const data = new Uint8Array(4 * size);\n    const r = Math.floor(color.r * 255);\n    const g = Math.floor(color.g * 255);\n    const b = Math.floor(color.b * 255);\n    for (let i = 0; i < size; i++) {\n        data[i * 3] = r;\n        data[i * 3 + 1] = g;\n        data[i * 3 + 2] = b;\n    }\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\n    texture.needsUpdate = true;\n    texture.magFilter = external_three_.NearestFilter;\n    return texture;\n}\nfunction generateGradientTexture(gradient) {\n    const size = 64;\n    const canvas = document.createElement('canvas');\n    canvas.width = size;\n    canvas.height = size;\n    const context = canvas.getContext('2d');\n    context.rect(0, 0, size, size);\n    const ctxGradient = context.createLinearGradient(0, 0, size, size);\n    for (let i = 0; i < gradient.length; i++) {\n        const step = gradient[i];\n        ctxGradient.addColorStop(step[0], `#${step[1].getHexString()}`);\n    }\n    context.fillStyle = ctxGradient;\n    context.fill();\n    const texture = new external_three_.CanvasTexture(canvas);\n    texture.needsUpdate = true;\n    texture.minFilter = external_three_.LinearFilter;\n    // textureImage = texture.image;\n    return texture;\n}\nfunction generateClassificationTexture(classification) {\n    const width = 256;\n    const height = 256;\n    const size = width * height;\n    const data = new Uint8Array(4 * size);\n    for (let x = 0; x < width; x++) {\n        for (let y = 0; y < height; y++) {\n            const i = x + width * y;\n            let color;\n            if (classification[x]) {\n                color = classification[x];\n            }\n            else if (classification[x % 32]) {\n                color = classification[x % 32];\n            }\n            else {\n                color = classification.DEFAULT;\n            }\n            data[4 * i + 0] = 255 * color.x;\n            data[4 * i + 1] = 255 * color.y;\n            data[4 * i + 2] = 255 * color.z;\n            data[4 * i + 3] = 255 * color.w;\n        }\n    }\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\n    texture.magFilter = external_three_.NearestFilter;\n    texture.needsUpdate = true;\n    return texture;\n}\n\n;// CONCATENATED MODULE: ./src/materials/point-cloud-material.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n\n\n\n\n\n\n\nconst TREE_TYPE_DEFS = {\n    [TreeType.OCTREE]: 'tree_type_octree',\n    [TreeType.KDTREE]: 'tree_type_kdtree',\n};\nconst SIZE_TYPE_DEFS = {\n    [PointSizeType.FIXED]: 'fixed_point_size',\n    [PointSizeType.ATTENUATED]: 'attenuated_point_size',\n    [PointSizeType.ADAPTIVE]: 'adaptive_point_size',\n};\nconst OPACITY_DEFS = {\n    [PointOpacityType.ATTENUATED]: 'attenuated_opacity',\n    [PointOpacityType.FIXED]: 'fixed_opacity',\n};\nconst SHAPE_DEFS = {\n    [PointShape.SQUARE]: 'square_point_shape',\n    [PointShape.CIRCLE]: 'circle_point_shape',\n    [PointShape.PARABOLOID]: 'paraboloid_point_shape',\n};\nconst COLOR_DEFS = {\n    [PointColorType.RGB]: 'color_type_rgb',\n    [PointColorType.COLOR]: 'color_type_color',\n    [PointColorType.DEPTH]: 'color_type_depth',\n    [PointColorType.HEIGHT]: 'color_type_height',\n    [PointColorType.INTENSITY]: 'color_type_intensity',\n    [PointColorType.INTENSITY_GRADIENT]: 'color_type_intensity_gradient',\n    [PointColorType.LOD]: 'color_type_lod',\n    [PointColorType.POINT_INDEX]: 'color_type_point_index',\n    [PointColorType.CLASSIFICATION]: 'color_type_classification',\n    [PointColorType.RETURN_NUMBER]: 'color_type_return_number',\n    [PointColorType.SOURCE]: 'color_type_source',\n    [PointColorType.NORMAL]: 'color_type_normal',\n    [PointColorType.PHONG]: 'color_type_phong',\n    [PointColorType.RGB_HEIGHT]: 'color_type_rgb_height',\n    [PointColorType.COMPOSITE]: 'color_type_composite',\n};\nconst CLIP_MODE_DEFS = {\n    [ClipMode.DISABLED]: 'clip_disabled',\n    [ClipMode.CLIP_OUTSIDE]: 'clip_outside',\n    [ClipMode.HIGHLIGHT_INSIDE]: 'clip_highlight_inside',\n    [ClipMode.CLIP_HORIZONTALLY]: 'clip_horizontally',\n    [ClipMode.CLIP_VERTICALLY]: 'clip_vertically',\n};\nclass PointCloudMaterial extends external_three_.RawShaderMaterial {\n    constructor(parameters = {}) {\n        super();\n        /**\n         * Use the drawing buffer size instead of the dom client width and height when passing the screen height and screen width uniforms to the\n         * shader. This is useful if you have offscreen canvases (which in some browsers return 0 as client width and client height).\n         */\n        this.useDrawingBufferSize = false;\n        this.lights = false;\n        this.fog = false;\n        this.colorRgba = false;\n        this.numClipBoxes = 0;\n        this.clipBoxes = [];\n        this.visibleNodeTextureOffsets = new Map();\n        this._gradient = SPECTRAL;\n        this.gradientTexture = generateGradientTexture(this._gradient);\n        this._classification = DEFAULT_CLASSIFICATION;\n        this.classificationTexture = generateClassificationTexture(this._classification);\n        this.uniforms = {\n            bbSize: makeUniform('fv', [0, 0, 0]),\n            blendDepthSupplement: makeUniform('f', 0.0),\n            blendHardness: makeUniform('f', 2.0),\n            classificationLUT: makeUniform('t', this.classificationTexture || new external_three_.Texture()),\n            clipBoxCount: makeUniform('f', 0),\n            clipBoxes: makeUniform('Matrix4fv', []),\n            clipExtent: makeUniform('fv', [0.0, 0.0, 1.0, 1.0]),\n            depthMap: makeUniform('t', null),\n            diffuse: makeUniform('fv', [1, 1, 1]),\n            fov: makeUniform('f', 1.0),\n            gradient: makeUniform('t', this.gradientTexture || new external_three_.Texture()),\n            heightMax: makeUniform('f', 1.0),\n            heightMin: makeUniform('f', 0.0),\n            intensityBrightness: makeUniform('f', 0),\n            intensityContrast: makeUniform('f', 0),\n            intensityGamma: makeUniform('f', 1),\n            intensityRange: makeUniform('fv', [0, 65000]),\n            isLeafNode: makeUniform('b', 0),\n            level: makeUniform('f', 0.0),\n            maxSize: makeUniform('f', DEFAULT_MAX_POINT_SIZE),\n            minSize: makeUniform('f', DEFAULT_MIN_POINT_SIZE),\n            octreeSize: makeUniform('f', 0),\n            opacity: makeUniform('f', 1.0),\n            pcIndex: makeUniform('f', 0),\n            rgbBrightness: makeUniform('f', DEFAULT_RGB_BRIGHTNESS),\n            rgbContrast: makeUniform('f', DEFAULT_RGB_CONTRAST),\n            rgbGamma: makeUniform('f', DEFAULT_RGB_GAMMA),\n            screenHeight: makeUniform('f', 1.0),\n            screenWidth: makeUniform('f', 1.0),\n            size: makeUniform('f', 1),\n            spacing: makeUniform('f', 1.0),\n            toModel: makeUniform('Matrix4f', []),\n            transition: makeUniform('f', 0.5),\n            uColor: makeUniform('c', new external_three_.Color(0xffffff)),\n            // @ts-ignore\n            visibleNodes: makeUniform('t', this.visibleNodesTexture || new external_three_.Texture()),\n            vnStart: makeUniform('f', 0.0),\n            wClassification: makeUniform('f', 0),\n            wElevation: makeUniform('f', 0),\n            wIntensity: makeUniform('f', 0),\n            wReturnNumber: makeUniform('f', 0),\n            wRGB: makeUniform('f', 1),\n            wSourceID: makeUniform('f', 0),\n            opacityAttenuation: makeUniform('f', 1),\n            filterByNormalThreshold: makeUniform('f', 0),\n            highlightedPointCoordinate: makeUniform('fv', new external_three_.Vector3()),\n            highlightedPointColor: makeUniform('fv', DEFAULT_HIGHLIGHT_COLOR.clone()),\n            enablePointHighlighting: makeUniform('b', true),\n            highlightedPointScale: makeUniform('f', 2.0),\n            backgroundMap: makeUniform('t', null),\n            normalFilteringMode: makeUniform('i', NormalFilteringMode.ABSOLUTE_NORMAL_FILTERING_MODE),\n            pointCloudID: makeUniform('f', 2),\n            pointCloudMixingMode: makeUniform('i', PointCloudMixingMode.CHECKBOARD),\n            stripeDistanceX: makeUniform('f', 5),\n            stripeDistanceY: makeUniform('f', 5),\n            stripeDivisorX: makeUniform('f', 2),\n            stripeDivisorY: makeUniform('f', 2),\n            pointCloudMixAngle: makeUniform('f', 31),\n        };\n        this.useClipBox = false;\n        this.weighted = false;\n        this.pointColorType = PointColorType.RGB;\n        this.pointSizeType = PointSizeType.ADAPTIVE;\n        this.clipMode = ClipMode.DISABLED;\n        this.useEDL = false;\n        this.shape = PointShape.SQUARE;\n        this.treeType = TreeType.OCTREE;\n        this.pointOpacityType = PointOpacityType.FIXED;\n        this.useFilterByNormal = false;\n        this.useTextureBlending = false;\n        this.usePointCloudMixing = false;\n        this.highlightPoint = false;\n        this.attributes = {\n            position: { type: 'fv', value: [] },\n            color: { type: 'fv', value: [] },\n            normal: { type: 'fv', value: [] },\n            intensity: { type: 'f', value: [] },\n            classification: { type: 'f', value: [] },\n            returnNumber: { type: 'f', value: [] },\n            numberOfReturns: { type: 'f', value: [] },\n            pointSourceID: { type: 'f', value: [] },\n            indices: { type: 'fv', value: [] },\n        };\n        const tex = (this.visibleNodesTexture = generateDataTexture(2048, 1, new external_three_.Color(0xffffff)));\n        tex.minFilter = external_three_.NearestFilter;\n        tex.magFilter = external_three_.NearestFilter;\n        this.setUniform('visibleNodes', tex);\n        this.treeType = getValid(parameters.treeType, TreeType.OCTREE);\n        this.size = getValid(parameters.size, 1.0);\n        this.minSize = getValid(parameters.minSize, 2.0);\n        this.maxSize = getValid(parameters.maxSize, 50.0);\n        this.colorRgba = Boolean(parameters.colorRgba);\n        this.classification = DEFAULT_CLASSIFICATION;\n        this.defaultAttributeValues.normal = [0, 0, 0];\n        this.defaultAttributeValues.classification = [0, 0, 0];\n        this.defaultAttributeValues.indices = [0, 0, 0, 0];\n        this.vertexColors = true;\n        this.updateShaderSource();\n    }\n    dispose() {\n        super.dispose();\n        if (this.gradientTexture) {\n            this.gradientTexture.dispose();\n            this.gradientTexture = undefined;\n        }\n        if (this.visibleNodesTexture) {\n            this.visibleNodesTexture.dispose();\n            this.visibleNodesTexture = undefined;\n        }\n        this.clearVisibleNodeTextureOffsets();\n        if (this.classificationTexture) {\n            this.classificationTexture.dispose();\n            this.classificationTexture = undefined;\n        }\n        if (this.depthMap) {\n            this.depthMap.dispose();\n            this.depthMap = undefined;\n        }\n        if (this.backgroundMap) {\n            this.backgroundMap.dispose();\n            this.backgroundMap = undefined;\n        }\n    }\n    clearVisibleNodeTextureOffsets() {\n        this.visibleNodeTextureOffsets.clear();\n    }\n    updateShaderSource() {\n        this.vertexShader = this.applyDefines((__webpack_require__(245)/* [\"default\"] */ .A));\n        this.fragmentShader = this.applyDefines((__webpack_require__(168)/* [\"default\"] */ .A));\n        if (this.opacity === 1.0) {\n            this.blending = external_three_.NoBlending;\n            this.transparent = false;\n            this.depthTest = true;\n            this.depthWrite = true;\n            this.depthFunc = external_three_.LessEqualDepth;\n        }\n        else if (this.opacity < 1.0 && !this.useEDL) {\n            this.blending = external_three_.AdditiveBlending;\n            this.transparent = true;\n            this.depthTest = false;\n            this.depthWrite = true;\n        }\n        if (this.weighted) {\n            this.blending = external_three_.AdditiveBlending;\n            this.transparent = true;\n            this.depthTest = true;\n            this.depthWrite = false;\n            this.depthFunc = external_three_.LessEqualDepth;\n        }\n        this.needsUpdate = true;\n    }\n    applyDefines(shaderSrc) {\n        const parts = [];\n        function define(value) {\n            if (value) {\n                parts.push(`#define ${value}`);\n            }\n        }\n        define(TREE_TYPE_DEFS[this.treeType]);\n        define(SIZE_TYPE_DEFS[this.pointSizeType]);\n        define(SHAPE_DEFS[this.shape]);\n        define(COLOR_DEFS[this.pointColorType]);\n        define(CLIP_MODE_DEFS[this.clipMode]);\n        define(OPACITY_DEFS[this.pointOpacityType]);\n        // We only perform gamma and brightness/contrast calculations per point if values are specified.\n        if (this.rgbGamma !== DEFAULT_RGB_GAMMA ||\n            this.rgbBrightness !== DEFAULT_RGB_BRIGHTNESS ||\n            this.rgbContrast !== DEFAULT_RGB_CONTRAST) {\n            define('use_rgb_gamma_contrast_brightness');\n        }\n        if (this.useFilterByNormal) {\n            define('use_filter_by_normal');\n        }\n        if (this.useEDL) {\n            define('use_edl');\n        }\n        if (this.weighted) {\n            define('weighted_splats');\n        }\n        if (this.numClipBoxes > 0) {\n            define('use_clip_box');\n        }\n        if (this.highlightPoint) {\n            define('highlight_point');\n        }\n        if (this.useTextureBlending) {\n            define('use_texture_blending');\n        }\n        if (this.usePointCloudMixing) {\n            define('use_point_cloud_mixing');\n        }\n        if (this.colorRgba) {\n            define('color_rgba');\n        }\n        define('MAX_POINT_LIGHTS 0');\n        define('MAX_DIR_LIGHTS 0');\n        parts.push(shaderSrc);\n        return parts.join('\\n');\n    }\n    setPointCloudMixingMode(mode) {\n        this.pointCloudMixingMode = mode;\n    }\n    getPointCloudMixingMode() {\n        if (this.pointCloudMixingMode === PointCloudMixingMode.STRIPES) {\n            return PointCloudMixingMode.STRIPES;\n        }\n        return PointCloudMixingMode.CHECKBOARD;\n    }\n    setClipBoxes(clipBoxes) {\n        if (!clipBoxes) {\n            return;\n        }\n        this.clipBoxes = clipBoxes;\n        const doUpdate = this.numClipBoxes !== clipBoxes.length && (clipBoxes.length === 0 || this.numClipBoxes === 0);\n        this.numClipBoxes = clipBoxes.length;\n        this.setUniform('clipBoxCount', this.numClipBoxes);\n        if (doUpdate) {\n            this.updateShaderSource();\n        }\n        const clipBoxesLength = this.numClipBoxes * 16;\n        const clipBoxesArray = new Float32Array(clipBoxesLength);\n        for (let i = 0; i < this.numClipBoxes; i++) {\n            clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);\n        }\n        for (let i = 0; i < clipBoxesLength; i++) {\n            if (isNaN(clipBoxesArray[i])) {\n                clipBoxesArray[i] = Infinity;\n            }\n        }\n        this.setUniform('clipBoxes', clipBoxesArray);\n    }\n    get gradient() {\n        return this._gradient;\n    }\n    set gradient(value) {\n        if (this._gradient !== value) {\n            this._gradient = value;\n            this.gradientTexture = generateGradientTexture(this._gradient);\n            this.setUniform('gradient', this.gradientTexture);\n        }\n    }\n    get classification() {\n        return this._classification;\n    }\n    set classification(value) {\n        const copy = {};\n        for (const key of Object.keys(value)) {\n            copy[key] = value[key].clone();\n        }\n        let isEqual = false;\n        if (this._classification === undefined) {\n            isEqual = false;\n        }\n        else {\n            isEqual = Object.keys(copy).length === Object.keys(this._classification).length;\n            for (const key of Object.keys(copy)) {\n                isEqual = isEqual && this._classification[key] !== undefined;\n                isEqual = isEqual && copy[key].equals(this._classification[key]);\n            }\n        }\n        if (!isEqual) {\n            this._classification = copy;\n            this.recomputeClassification();\n        }\n    }\n    recomputeClassification() {\n        this.classificationTexture = generateClassificationTexture(this._classification);\n        this.setUniform('classificationLUT', this.classificationTexture);\n    }\n    get elevationRange() {\n        return [this.heightMin, this.heightMax];\n    }\n    set elevationRange(value) {\n        this.heightMin = value[0];\n        this.heightMax = value[1];\n    }\n    getUniform(name) {\n        return this.uniforms === undefined ? undefined : this.uniforms[name].value;\n    }\n    setUniform(name, value) {\n        if (this.uniforms === undefined) {\n            return;\n        }\n        const uObj = this.uniforms[name];\n        if (uObj.type === 'c') {\n            uObj.value.copy(value);\n        }\n        else if (value !== uObj.value) {\n            uObj.value = value;\n        }\n    }\n    updateMaterial(octree, visibleNodes, camera, renderer) {\n        const pixelRatio = renderer.getPixelRatio();\n        if (camera.type === PERSPECTIVE_CAMERA) {\n            this.fov = camera.fov * (Math.PI / 180);\n        }\n        else {\n            this.fov = Math.PI / 2; // will result in slope = 1 in the shader\n        }\n        const renderTarget = renderer.getRenderTarget();\n        if (renderTarget !== null) {\n            this.screenWidth = renderTarget.width;\n            this.screenHeight = renderTarget.height;\n        }\n        else {\n            this.screenWidth = renderer.domElement.clientWidth * pixelRatio;\n            this.screenHeight = renderer.domElement.clientHeight * pixelRatio;\n        }\n        if (this.useDrawingBufferSize) {\n            renderer.getDrawingBufferSize(PointCloudMaterial.helperVec2);\n            this.screenWidth = PointCloudMaterial.helperVec2.width;\n            this.screenHeight = PointCloudMaterial.helperVec2.height;\n        }\n        const maxScale = Math.max(octree.scale.x, octree.scale.y, octree.scale.z);\n        this.spacing = octree.pcoGeometry.spacing * maxScale;\n        this.octreeSize = octree.pcoGeometry.boundingBox.getSize(PointCloudMaterial.helperVec3).x;\n        if (this.pointSizeType === PointSizeType.ADAPTIVE ||\n            this.pointColorType === PointColorType.LOD) {\n            this.updateVisibilityTextureData(visibleNodes);\n        }\n    }\n    updateVisibilityTextureData(nodes) {\n        nodes.sort(byLevelAndIndex);\n        const data = new Uint8Array(nodes.length * 4);\n        const offsetsToChild = new Array(nodes.length).fill(Infinity);\n        this.visibleNodeTextureOffsets.clear();\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            this.visibleNodeTextureOffsets.set(node.name, i);\n            if (i > 0) {\n                const parentName = node.name.slice(0, -1);\n                const parentOffset = this.visibleNodeTextureOffsets.get(parentName);\n                const parentOffsetToChild = i - parentOffset;\n                offsetsToChild[parentOffset] = Math.min(offsetsToChild[parentOffset], parentOffsetToChild);\n                // tslint:disable:no-bitwise\n                const offset = parentOffset * 4;\n                data[offset] = data[offset] | (1 << node.index);\n                data[offset + 1] = offsetsToChild[parentOffset] >> 8;\n                data[offset + 2] = offsetsToChild[parentOffset] % 256;\n                // tslint:enable:no-bitwise\n            }\n            data[i * 4 + 3] = node.name.length;\n        }\n        const texture = this.visibleNodesTexture;\n        if (texture) {\n            texture.image.data.set(data);\n            texture.needsUpdate = true;\n        }\n    }\n    static makeOnBeforeRender(octree, node, pcIndex) {\n        return (_renderer, _scene, _camera, _geometry, material) => {\n            const pointCloudMaterial = material;\n            const materialUniforms = pointCloudMaterial.uniforms;\n            materialUniforms.level.value = node.level;\n            materialUniforms.isLeafNode.value = node.isLeafNode;\n            const vnStart = pointCloudMaterial.visibleNodeTextureOffsets.get(node.name);\n            if (vnStart !== undefined) {\n                materialUniforms.vnStart.value = vnStart;\n            }\n            materialUniforms.pcIndex.value =\n                pcIndex !== undefined ? pcIndex : octree.visibleNodes.indexOf(node);\n            // Note: when changing uniforms in onBeforeRender, the flag uniformsNeedUpdate has to be\n            // set to true to instruct ThreeJS to upload them. See also\n            // https://github.com/mrdoob/three.js/issues/9870#issuecomment-368750182.\n            // Remove the cast to any after updating to Three.JS >= r113\n            material /*ShaderMaterial*/.uniformsNeedUpdate = true;\n        };\n    }\n}\nPointCloudMaterial.helperVec3 = new external_three_.Vector3();\nPointCloudMaterial.helperVec2 = new external_three_.Vector2();\n__decorate([\n    uniform('bbSize')\n], PointCloudMaterial.prototype, \"bbSize\", void 0);\n__decorate([\n    uniform('clipExtent')\n], PointCloudMaterial.prototype, \"clipExtent\", void 0);\n__decorate([\n    uniform('depthMap')\n], PointCloudMaterial.prototype, \"depthMap\", void 0);\n__decorate([\n    uniform('fov')\n], PointCloudMaterial.prototype, \"fov\", void 0);\n__decorate([\n    uniform('heightMax')\n], PointCloudMaterial.prototype, \"heightMax\", void 0);\n__decorate([\n    uniform('heightMin')\n], PointCloudMaterial.prototype, \"heightMin\", void 0);\n__decorate([\n    uniform('intensityBrightness')\n], PointCloudMaterial.prototype, \"intensityBrightness\", void 0);\n__decorate([\n    uniform('intensityContrast')\n], PointCloudMaterial.prototype, \"intensityContrast\", void 0);\n__decorate([\n    uniform('intensityGamma')\n], PointCloudMaterial.prototype, \"intensityGamma\", void 0);\n__decorate([\n    uniform('intensityRange')\n], PointCloudMaterial.prototype, \"intensityRange\", void 0);\n__decorate([\n    uniform('maxSize')\n], PointCloudMaterial.prototype, \"maxSize\", void 0);\n__decorate([\n    uniform('minSize')\n], PointCloudMaterial.prototype, \"minSize\", void 0);\n__decorate([\n    uniform('octreeSize')\n], PointCloudMaterial.prototype, \"octreeSize\", void 0);\n__decorate([\n    uniform('opacity', true)\n], PointCloudMaterial.prototype, \"opacity\", void 0);\n__decorate([\n    uniform('rgbBrightness', true)\n], PointCloudMaterial.prototype, \"rgbBrightness\", void 0);\n__decorate([\n    uniform('rgbContrast', true)\n], PointCloudMaterial.prototype, \"rgbContrast\", void 0);\n__decorate([\n    uniform('rgbGamma', true)\n], PointCloudMaterial.prototype, \"rgbGamma\", void 0);\n__decorate([\n    uniform('screenHeight')\n], PointCloudMaterial.prototype, \"screenHeight\", void 0);\n__decorate([\n    uniform('screenWidth')\n], PointCloudMaterial.prototype, \"screenWidth\", void 0);\n__decorate([\n    uniform('size')\n], PointCloudMaterial.prototype, \"size\", void 0);\n__decorate([\n    uniform('spacing')\n], PointCloudMaterial.prototype, \"spacing\", void 0);\n__decorate([\n    uniform('transition')\n], PointCloudMaterial.prototype, \"transition\", void 0);\n__decorate([\n    uniform('uColor')\n], PointCloudMaterial.prototype, \"color\", void 0);\n__decorate([\n    uniform('wClassification')\n], PointCloudMaterial.prototype, \"weightClassification\", void 0);\n__decorate([\n    uniform('wElevation')\n], PointCloudMaterial.prototype, \"weightElevation\", void 0);\n__decorate([\n    uniform('wIntensity')\n], PointCloudMaterial.prototype, \"weightIntensity\", void 0);\n__decorate([\n    uniform('wReturnNumber')\n], PointCloudMaterial.prototype, \"weightReturnNumber\", void 0);\n__decorate([\n    uniform('wRGB')\n], PointCloudMaterial.prototype, \"weightRGB\", void 0);\n__decorate([\n    uniform('wSourceID')\n], PointCloudMaterial.prototype, \"weightSourceID\", void 0);\n__decorate([\n    uniform('opacityAttenuation')\n], PointCloudMaterial.prototype, \"opacityAttenuation\", void 0);\n__decorate([\n    uniform('filterByNormalThreshold')\n], PointCloudMaterial.prototype, \"filterByNormalThreshold\", void 0);\n__decorate([\n    uniform('highlightedPointCoordinate')\n], PointCloudMaterial.prototype, \"highlightedPointCoordinate\", void 0);\n__decorate([\n    uniform('highlightedPointColor')\n], PointCloudMaterial.prototype, \"highlightedPointColor\", void 0);\n__decorate([\n    uniform('enablePointHighlighting')\n], PointCloudMaterial.prototype, \"enablePointHighlighting\", void 0);\n__decorate([\n    uniform('highlightedPointScale')\n], PointCloudMaterial.prototype, \"highlightedPointScale\", void 0);\n__decorate([\n    uniform('normalFilteringMode')\n], PointCloudMaterial.prototype, \"normalFilteringMode\", void 0);\n__decorate([\n    uniform('backgroundMap')\n], PointCloudMaterial.prototype, \"backgroundMap\", void 0);\n__decorate([\n    uniform('pointCloudID')\n], PointCloudMaterial.prototype, \"pointCloudID\", void 0);\n__decorate([\n    uniform('pointCloudMixingMode')\n], PointCloudMaterial.prototype, \"pointCloudMixingMode\", void 0);\n__decorate([\n    uniform('stripeDistanceX')\n], PointCloudMaterial.prototype, \"stripeDistanceX\", void 0);\n__decorate([\n    uniform('stripeDistanceY')\n], PointCloudMaterial.prototype, \"stripeDistanceY\", void 0);\n__decorate([\n    uniform('stripeDivisorX')\n], PointCloudMaterial.prototype, \"stripeDivisorX\", void 0);\n__decorate([\n    uniform('stripeDivisorY')\n], PointCloudMaterial.prototype, \"stripeDivisorY\", void 0);\n__decorate([\n    uniform('pointCloudMixAngle')\n], PointCloudMaterial.prototype, \"pointCloudMixAngle\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useClipBox\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"weighted\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointColorType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointSizeType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"clipMode\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useEDL\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"shape\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"treeType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"pointOpacityType\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useFilterByNormal\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"useTextureBlending\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"usePointCloudMixing\", void 0);\n__decorate([\n    requiresShaderUpdate()\n], PointCloudMaterial.prototype, \"highlightPoint\", void 0);\nfunction makeUniform(type, value) {\n    return { type, value };\n}\nfunction getValid(a, b) {\n    return a === undefined ? b : a;\n}\n// tslint:disable:no-invalid-this\nfunction uniform(uniformName, requireSrcUpdate = false) {\n    return (target, propertyKey) => {\n        Object.defineProperty(target, propertyKey, {\n            get() {\n                return this.getUniform(uniformName);\n            },\n            set(value) {\n                if (value !== this.getUniform(uniformName)) {\n                    this.setUniform(uniformName, value);\n                    if (requireSrcUpdate) {\n                        this.updateShaderSource();\n                    }\n                }\n            },\n        });\n    };\n}\nfunction requiresShaderUpdate() {\n    return (target, propertyKey) => {\n        const fieldName = `_${propertyKey.toString()}`;\n        Object.defineProperty(target, propertyKey, {\n            get() {\n                return this[fieldName];\n            },\n            set(value) {\n                if (value !== this[fieldName]) {\n                    this[fieldName] = value;\n                    this.updateShaderSource();\n                }\n            },\n        });\n    };\n}\n\n;// CONCATENATED MODULE: ./src/materials/index.ts\n\n\n\n\n\n\n\n\n;// CONCATENATED MODULE: ./src/point-attributes.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\nvar PointAttributeName;\n(function (PointAttributeName) {\n    PointAttributeName[PointAttributeName[\"POSITION_CARTESIAN\"] = 0] = \"POSITION_CARTESIAN\";\n    PointAttributeName[PointAttributeName[\"COLOR_PACKED\"] = 1] = \"COLOR_PACKED\";\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_1\"] = 2] = \"COLOR_FLOATS_1\";\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_255\"] = 3] = \"COLOR_FLOATS_255\";\n    PointAttributeName[PointAttributeName[\"NORMAL_FLOATS\"] = 4] = \"NORMAL_FLOATS\";\n    PointAttributeName[PointAttributeName[\"FILLER\"] = 5] = \"FILLER\";\n    PointAttributeName[PointAttributeName[\"INTENSITY\"] = 6] = \"INTENSITY\";\n    PointAttributeName[PointAttributeName[\"CLASSIFICATION\"] = 7] = \"CLASSIFICATION\";\n    PointAttributeName[PointAttributeName[\"NORMAL_SPHEREMAPPED\"] = 8] = \"NORMAL_SPHEREMAPPED\";\n    PointAttributeName[PointAttributeName[\"NORMAL_OCT16\"] = 9] = \"NORMAL_OCT16\";\n    PointAttributeName[PointAttributeName[\"NORMAL\"] = 10] = \"NORMAL\";\n})(PointAttributeName || (PointAttributeName = {}));\nconst POINT_ATTRIBUTE_TYPES = {\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\n};\nfunction makePointAttribute(name, type, numElements) {\n    return {\n        name,\n        type,\n        numElements,\n        byteSize: numElements * type.size,\n    };\n}\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\nconst POINT_ATTRIBUTES = {\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n    RGBA_PACKED,\n    COLOR_PACKED: RGBA_PACKED,\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\n};\nclass PointAttributes {\n    constructor(pointAttributeNames = []) {\n        this.attributes = [];\n        this.byteSize = 0;\n        this.size = 0;\n        for (let i = 0; i < pointAttributeNames.length; i++) {\n            const pointAttributeName = pointAttributeNames[i];\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\n            this.attributes.push(pointAttribute);\n            this.byteSize += pointAttribute.byteSize;\n            this.size++;\n        }\n    }\n    add(pointAttribute) {\n        this.attributes.push(pointAttribute);\n        this.byteSize += pointAttribute.byteSize;\n        this.size++;\n    }\n    hasColors() {\n        return this.attributes.find(isColorAttribute) !== undefined;\n    }\n    hasNormals() {\n        return this.attributes.find(isNormalAttribute) !== undefined;\n    }\n}\nfunction isColorAttribute({ name }) {\n    return name === PointAttributeName.COLOR_PACKED;\n}\nfunction isNormalAttribute({ name }) {\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\n        name === PointAttributeName.NORMAL_FLOATS ||\n        name === PointAttributeName.NORMAL ||\n        name === PointAttributeName.NORMAL_OCT16);\n}\n\n;// CONCATENATED MODULE: ./src/utils/bounds.ts\n\n/**\n * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561\n */\nfunction computeTransformedBoundingBox(box, transform) {\n    return new external_three_.Box3().setFromPoints([\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\n        new external_three_.Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),\n    ]);\n}\nfunction createChildAABB(aabb, index) {\n    const min = aabb.min.clone();\n    const max = aabb.max.clone();\n    const size = new external_three_.Vector3().subVectors(max, min);\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0001) > 0) {\n        min.z += size.z / 2;\n    }\n    else {\n        max.z -= size.z / 2;\n    }\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0010) > 0) {\n        min.y += size.y / 2;\n    }\n    else {\n        max.y -= size.y / 2;\n    }\n    // tslint:disable-next-line:no-bitwise\n    if ((index & 0b0100) > 0) {\n        min.x += size.x / 2;\n    }\n    else {\n        max.x -= size.x / 2;\n    }\n    return new external_three_.Box3(min, max);\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry-node.ts\n/**\n * Adapted from Potree.js http://potree.org\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\n */\n\n\n\nconst NODE_STRIDE = 5;\nclass PointCloudOctreeGeometryNode extends external_three_.EventDispatcher {\n    constructor(name, pcoGeometry, boundingBox) {\n        super();\n        this.id = PointCloudOctreeGeometryNode.idCount++;\n        this.level = 0;\n        this.spacing = 0;\n        this.hasChildren = false;\n        this.children = [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n        ];\n        this.mean = new external_three_.Vector3();\n        this.numPoints = 0;\n        this.loaded = false;\n        this.loading = false;\n        this.failed = false;\n        this.parent = null;\n        this.oneTimeDisposeHandlers = [];\n        this.isLeafNode = true;\n        this.isTreeNode = false;\n        this.isGeometryNode = true;\n        this.name = name;\n        this.index = getIndexFromName(name);\n        this.pcoGeometry = pcoGeometry;\n        this.boundingBox = boundingBox;\n        this.tightBoundingBox = boundingBox.clone();\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n    }\n    dispose() {\n        if (!this.geometry || !this.parent) {\n            return;\n        }\n        this.geometry.dispose();\n        this.geometry = undefined;\n        this.loaded = false;\n        this.oneTimeDisposeHandlers.forEach(handler => handler());\n        this.oneTimeDisposeHandlers = [];\n    }\n    /**\n     * Gets the url of the binary file for this node.\n     */\n    getUrl() {\n        const geometry = this.pcoGeometry;\n        const version = geometry.loader.version;\n        const pathParts = [geometry.octreeDir];\n        if (geometry.loader && version.equalOrHigher('1.5')) {\n            pathParts.push(this.getHierarchyBaseUrl());\n            pathParts.push(this.name);\n        }\n        else if (version.equalOrHigher('1.4')) {\n            pathParts.push(this.name);\n        }\n        else if (version.upTo('1.3')) {\n            pathParts.push(this.name);\n        }\n        return pathParts.join('/');\n    }\n    /**\n     * Gets the url of the hierarchy file for this node.\n     */\n    getHierarchyUrl() {\n        return `${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`;\n    }\n    /**\n     * Adds the specified node as a child of the current node.\n     *\n     * @param child\n     *    The node which is to be added as a child.\n     */\n    addChild(child) {\n        this.children[child.index] = child;\n        this.isLeafNode = false;\n        child.parent = this;\n    }\n    /**\n     * Calls the specified callback for the current node (if includeSelf is set to true) and all its\n     * children.\n     *\n     * @param cb\n     *    The function which is to be called for each node.\n     */\n    traverse(cb, includeSelf = true) {\n        const stack = includeSelf ? [this] : [];\n        let current;\n        while ((current = stack.pop()) !== undefined) {\n            cb(current);\n            for (const child of current.children) {\n                if (child !== null) {\n                    stack.push(child);\n                }\n            }\n        }\n    }\n    load() {\n        if (!this.canLoad()) {\n            return Promise.resolve();\n        }\n        this.loading = true;\n        this.pcoGeometry.numNodesLoading++;\n        this.pcoGeometry.needsUpdate = true;\n        let promise;\n        if (this.pcoGeometry.loader.version.equalOrHigher('1.5') &&\n            this.level % this.pcoGeometry.hierarchyStepSize === 0 &&\n            this.hasChildren) {\n            promise = this.loadHierachyThenPoints();\n        }\n        else {\n            promise = this.loadPoints();\n        }\n        return promise.catch(reason => {\n            this.loading = false;\n            this.failed = true;\n            this.pcoGeometry.numNodesLoading--;\n            throw reason;\n        });\n    }\n    canLoad() {\n        return (!this.loading &&\n            !this.loaded &&\n            !this.pcoGeometry.disposed &&\n            !this.pcoGeometry.loader.disposed &&\n            this.pcoGeometry.numNodesLoading < this.pcoGeometry.maxNumNodesLoading);\n    }\n    loadPoints() {\n        this.pcoGeometry.needsUpdate = true;\n        return this.pcoGeometry.loader.load(this);\n    }\n    loadHierachyThenPoints() {\n        if (this.level % this.pcoGeometry.hierarchyStepSize !== 0) {\n            return Promise.resolve();\n        }\n        return Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl()))\n            .then(url => this.pcoGeometry.xhrRequest(url, { mode: 'cors' }))\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.arrayBuffer())\n            .then(buffer => handleEmptyBuffer(buffer))\n            .then(okBuffer => this.loadHierarchy(this, okBuffer));\n    }\n    /**\n     * Gets the url of the folder where the hierarchy is, relative to the octreeDir.\n     */\n    getHierarchyBaseUrl() {\n        const hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\n        const indices = this.name.substr(1);\n        const numParts = Math.floor(indices.length / hierarchyStepSize);\n        let path = 'r/';\n        for (let i = 0; i < numParts; i++) {\n            path += `${indices.substr(i * hierarchyStepSize, hierarchyStepSize)}/`;\n        }\n        return path.slice(0, -1);\n    }\n    // tslint:disable:no-bitwise\n    loadHierarchy(node, buffer) {\n        const view = new DataView(buffer);\n        const firstNodeData = this.getNodeData(node.name, 0, view);\n        node.numPoints = firstNodeData.numPoints;\n        // Nodes which need be visited.\n        const stack = [firstNodeData];\n        // Nodes which have already been decoded. We will take nodes from the stack and place them here.\n        const decoded = [];\n        let offset = NODE_STRIDE;\n        while (stack.length > 0) {\n            const stackNodeData = stack.shift();\n            // From the last bit, all the way to the 8th one from the right.\n            let mask = 1;\n            for (let i = 0; i < 8 && offset + 1 < buffer.byteLength; i++) {\n                if ((stackNodeData.children & mask) !== 0) {\n                    const nodeData = this.getNodeData(stackNodeData.name + i, offset, view);\n                    decoded.push(nodeData); // Node is decoded.\n                    stack.push(nodeData); // Need to check its children.\n                    offset += NODE_STRIDE; // Move over to the next node in the buffer.\n                }\n                mask = mask * 2;\n            }\n        }\n        node.pcoGeometry.needsUpdate = true;\n        // Map containing all the nodes.\n        const nodes = new Map();\n        nodes.set(node.name, node);\n        decoded.forEach(nodeData => this.addNode(nodeData, node.pcoGeometry, nodes));\n        node.loadPoints();\n    }\n    // tslint:enable:no-bitwise\n    getNodeData(name, offset, view) {\n        const children = view.getUint8(offset);\n        const numPoints = view.getUint32(offset + 1, true);\n        return { children: children, numPoints: numPoints, name };\n    }\n    addNode({ name, numPoints, children }, pco, nodes) {\n        const index = getIndexFromName(name);\n        const parentName = name.substring(0, name.length - 1);\n        const parentNode = nodes.get(parentName);\n        const level = name.length - 1;\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n        node.level = level;\n        node.numPoints = numPoints;\n        node.hasChildren = children > 0;\n        node.spacing = pco.spacing / Math.pow(2, level);\n        parentNode.addChild(node);\n        nodes.set(name, node);\n    }\n}\nPointCloudOctreeGeometryNode.idCount = 0;\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry.ts\n\nclass PointCloudOctreeGeometry {\n    constructor(loader, boundingBox, tightBoundingBox, offset, xhrRequest) {\n        this.loader = loader;\n        this.boundingBox = boundingBox;\n        this.tightBoundingBox = tightBoundingBox;\n        this.offset = offset;\n        this.xhrRequest = xhrRequest;\n        this.disposed = false;\n        this.needsUpdate = true;\n        this.octreeDir = '';\n        this.hierarchyStepSize = -1;\n        this.nodes = {};\n        this.numNodesLoading = 0;\n        this.maxNumNodesLoading = 3;\n        this.spacing = 0;\n        this.pointAttributes = new PointAttributes([]);\n        this.projection = null;\n        this.url = null;\n    }\n    dispose() {\n        this.loader.dispose();\n        this.root.traverse(node => node.dispose());\n        this.disposed = true;\n    }\n    addNodeLoadedCallback(callback) {\n        this.loader.callbacks.push(callback);\n    }\n    clearNodeLoadedCallbacks() {\n        this.loader.callbacks = [];\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-node.ts\n\nclass PointCloudOctreeNode extends external_three_.EventDispatcher {\n    constructor(geometryNode, sceneNode) {\n        super();\n        this.pcIndex = undefined;\n        this.boundingBoxNode = null;\n        this.loaded = true;\n        this.isTreeNode = true;\n        this.isGeometryNode = false;\n        this.geometryNode = geometryNode;\n        this.sceneNode = sceneNode;\n        this.children = geometryNode.children.slice();\n    }\n    dispose() {\n        this.geometryNode.dispose();\n    }\n    disposeSceneNode() {\n        const node = this.sceneNode;\n        if (node.geometry instanceof external_three_.BufferGeometry) {\n            const attributes = node.geometry.attributes;\n            // tslint:disable-next-line:forin\n            for (const key in attributes) {\n                if (key === 'position') {\n                    delete attributes[key].array;\n                }\n                delete attributes[key];\n            }\n            node.geometry.dispose();\n            node.geometry = undefined;\n        }\n    }\n    traverse(cb, includeSelf) {\n        this.geometryNode.traverse(cb, includeSelf);\n    }\n    get id() {\n        return this.geometryNode.id;\n    }\n    get name() {\n        return this.geometryNode.name;\n    }\n    get level() {\n        return this.geometryNode.level;\n    }\n    get isLeafNode() {\n        return this.geometryNode.isLeafNode;\n    }\n    get numPoints() {\n        return this.geometryNode.numPoints;\n    }\n    get index() {\n        return this.geometryNode.index;\n    }\n    get boundingSphere() {\n        return this.geometryNode.boundingSphere;\n    }\n    get boundingBox() {\n        return this.geometryNode.boundingBox;\n    }\n    get spacing() {\n        return this.geometryNode.spacing;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/math.ts\nfunction clamp(value, min, max) {\n    return Math.min(Math.max(min, value), max);\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-picker.ts\n\n\n\n\nclass PointCloudOctreePicker {\n    dispose() {\n        if (this.pickState) {\n            this.pickState.material.dispose();\n            this.pickState.renderTarget.dispose();\n        }\n    }\n    pick(renderer, camera, ray, octrees, params = {}) {\n        if (octrees.length === 0) {\n            return null;\n        }\n        const pickState = this.pickState\n            ? this.pickState\n            : (this.pickState = PointCloudOctreePicker.getPickState());\n        const pickMaterial = pickState.material;\n        const pixelRatio = renderer.getPixelRatio();\n        const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\n        const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\n        PointCloudOctreePicker.updatePickRenderTarget(this.pickState, width, height);\n        const pixelPosition = PointCloudOctreePicker.helperVec3; // Use helper vector to prevent extra allocations.\n        if (params.pixelPosition) {\n            pixelPosition.copy(params.pixelPosition);\n        }\n        else {\n            pixelPosition.addVectors(camera.position, ray.direction).project(camera);\n            pixelPosition.x = (pixelPosition.x + 1) * width * 0.5;\n            pixelPosition.y = (pixelPosition.y + 1) * height * 0.5;\n        }\n        const pickWndSize = Math.floor((params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio);\n        const halfPickWndSize = (pickWndSize - 1) / 2;\n        const x = Math.floor(clamp(pixelPosition.x - halfPickWndSize, 0, width));\n        const y = Math.floor(clamp(pixelPosition.y - halfPickWndSize, 0, height));\n        PointCloudOctreePicker.prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState);\n        const renderedNodes = PointCloudOctreePicker.render(renderer, camera, pickMaterial, octrees, ray, pickState, params);\n        // Cleanup\n        pickMaterial.clearVisibleNodeTextureOffsets();\n        // Read back image and decode hit point\n        const pixels = PointCloudOctreePicker.readPixels(renderer, x, y, pickWndSize);\n        const hit = PointCloudOctreePicker.findHit(pixels, pickWndSize);\n        return PointCloudOctreePicker.getPickPoint(hit, renderedNodes);\n    }\n    static prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState) {\n        // Render the intersected nodes onto the pick render target, clipping to a small pick window.\n        renderer.setScissor(x, y, pickWndSize, pickWndSize);\n        renderer.setScissorTest(true);\n        renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\n        renderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\n        renderer.state.setBlending(external_three_.NoBlending);\n        renderer.setRenderTarget(pickState.renderTarget);\n        // Save the current clear color and clear the renderer with black color and alpha 0.\n        renderer.getClearColor(this.clearColor);\n        const oldClearAlpha = renderer.getClearAlpha();\n        renderer.setClearColor(COLOR_BLACK, 0);\n        renderer.clear(true, true, true);\n        renderer.setClearColor(this.clearColor, oldClearAlpha);\n    }\n    static render(renderer, camera, pickMaterial, octrees, ray, pickState, params) {\n        const renderedNodes = [];\n        for (const octree of octrees) {\n            // Get all the octree nodes which intersect the picking ray. We only need to render those.\n            const nodes = PointCloudOctreePicker.nodesOnRay(octree, ray);\n            if (!nodes.length) {\n                continue;\n            }\n            PointCloudOctreePicker.updatePickMaterial(pickMaterial, octree.material, params);\n            pickMaterial.updateMaterial(octree, nodes, camera, renderer);\n            if (params.onBeforePickRender) {\n                params.onBeforePickRender(pickMaterial, pickState.renderTarget);\n            }\n            // Create copies of the nodes so we can render them differently than in the normal point cloud.\n            pickState.scene.children = PointCloudOctreePicker.createTempNodes(octree, nodes, pickMaterial, renderedNodes.length);\n            renderer.render(pickState.scene, camera);\n            nodes.forEach(node => renderedNodes.push({ node, octree }));\n        }\n        return renderedNodes;\n    }\n    static nodesOnRay(octree, ray) {\n        const nodesOnRay = [];\n        const rayClone = ray.clone();\n        for (const node of octree.visibleNodes) {\n            const sphere = PointCloudOctreePicker.helperSphere\n                .copy(node.boundingSphere)\n                .applyMatrix4(octree.matrixWorld);\n            if (rayClone.intersectsSphere(sphere)) {\n                nodesOnRay.push(node);\n            }\n        }\n        return nodesOnRay;\n    }\n    static readPixels(renderer, x, y, pickWndSize) {\n        // Read the pixel from the pick render target.\n        const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\n        renderer.readRenderTargetPixels(renderer.getRenderTarget(), x, y, pickWndSize, pickWndSize, pixels);\n        renderer.setScissorTest(false);\n        renderer.setRenderTarget(null);\n        return pixels;\n    }\n    static createTempNodes(octree, nodes, pickMaterial, nodeIndexOffset) {\n        const tempNodes = [];\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            const sceneNode = node.sceneNode;\n            const tempNode = new external_three_.Points(sceneNode.geometry, pickMaterial);\n            tempNode.matrix = sceneNode.matrix;\n            tempNode.matrixWorld = sceneNode.matrixWorld;\n            tempNode.matrixAutoUpdate = false;\n            tempNode.frustumCulled = false;\n            const nodeIndex = nodeIndexOffset + i + 1;\n            if (nodeIndex > 255) {\n                console.error('More than 255 nodes for pick are not supported.');\n            }\n            tempNode.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(octree, node, nodeIndex);\n            tempNodes.push(tempNode);\n        }\n        return tempNodes;\n    }\n    static updatePickMaterial(pickMaterial, nodeMaterial, params) {\n        pickMaterial.pointSizeType = nodeMaterial.pointSizeType;\n        pickMaterial.shape = nodeMaterial.shape;\n        pickMaterial.size = nodeMaterial.size;\n        pickMaterial.minSize = nodeMaterial.minSize;\n        pickMaterial.maxSize = nodeMaterial.maxSize;\n        pickMaterial.classification = nodeMaterial.classification;\n        pickMaterial.useFilterByNormal = nodeMaterial.useFilterByNormal;\n        pickMaterial.filterByNormalThreshold = nodeMaterial.filterByNormalThreshold;\n        if (params.pickOutsideClipRegion) {\n            pickMaterial.clipMode = ClipMode.DISABLED;\n        }\n        else {\n            pickMaterial.clipMode = nodeMaterial.clipMode;\n            pickMaterial.setClipBoxes(nodeMaterial.clipMode === ClipMode.CLIP_OUTSIDE ? nodeMaterial.clipBoxes : []);\n        }\n    }\n    static updatePickRenderTarget(pickState, width, height) {\n        if (pickState.renderTarget.width === width && pickState.renderTarget.height === height) {\n            return;\n        }\n        pickState.renderTarget.dispose();\n        pickState.renderTarget = PointCloudOctreePicker.makePickRenderTarget();\n        pickState.renderTarget.setSize(width, height);\n    }\n    static makePickRenderTarget() {\n        return new external_three_.WebGLRenderTarget(1, 1, {\n            minFilter: external_three_.LinearFilter,\n            magFilter: external_three_.NearestFilter,\n            format: external_three_.RGBAFormat,\n        });\n    }\n    static findHit(pixels, pickWndSize) {\n        const ibuffer = new Uint32Array(pixels.buffer);\n        // Find closest hit inside pixelWindow boundaries\n        let min = Number.MAX_VALUE;\n        let hit = null;\n        for (let u = 0; u < pickWndSize; u++) {\n            for (let v = 0; v < pickWndSize; v++) {\n                const offset = u + v * pickWndSize;\n                const distance = Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\n                const pcIndex = pixels[4 * offset + 3];\n                pixels[4 * offset + 3] = 0;\n                const pIndex = ibuffer[offset];\n                if (pcIndex > 0 && distance < min) {\n                    hit = {\n                        pIndex: pIndex,\n                        pcIndex: pcIndex - 1,\n                    };\n                    min = distance;\n                }\n            }\n        }\n        return hit;\n    }\n    static getPickPoint(hit, nodes) {\n        if (!hit) {\n            return null;\n        }\n        const point = {};\n        const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].node.sceneNode;\n        if (!points) {\n            return null;\n        }\n        point.pointCloud = nodes[hit.pcIndex].octree;\n        const attributes = points.geometry.attributes;\n        for (const property in attributes) {\n            if (!attributes.hasOwnProperty(property)) {\n                continue;\n            }\n            const values = attributes[property];\n            // tslint:disable-next-line:prefer-switch\n            if (property === 'position') {\n                PointCloudOctreePicker.addPositionToPickPoint(point, hit, values, points);\n            }\n            else if (property === 'normal') {\n                PointCloudOctreePicker.addNormalToPickPoint(point, hit, values, points);\n            }\n            else if (property === 'indices') {\n                // TODO\n            }\n            else {\n                if (values.itemSize === 1) {\n                    point[property] = values.array[hit.pIndex];\n                }\n                else {\n                    const value = [];\n                    for (let j = 0; j < values.itemSize; j++) {\n                        value.push(values.array[values.itemSize * hit.pIndex + j]);\n                    }\n                    point[property] = value;\n                }\n            }\n        }\n        return point;\n    }\n    static addPositionToPickPoint(point, hit, values, points) {\n        point.position = new external_three_.Vector3()\n            .fromBufferAttribute(values, hit.pIndex)\n            .applyMatrix4(points.matrixWorld);\n    }\n    static addNormalToPickPoint(point, hit, values, points) {\n        const normal = new external_three_.Vector3().fromBufferAttribute(values, hit.pIndex);\n        const normal4 = new external_three_.Vector4(normal.x, normal.y, normal.z, 0).applyMatrix4(points.matrixWorld);\n        normal.set(normal4.x, normal4.y, normal4.z);\n        point.normal = normal;\n    }\n    static getPickState() {\n        const scene = new external_three_.Scene();\n        scene.matrixAutoUpdate = false;\n        const material = new PointCloudMaterial();\n        material.pointColorType = PointColorType.POINT_INDEX;\n        return {\n            renderTarget: PointCloudOctreePicker.makePickRenderTarget(),\n            material: material,\n            scene: scene,\n        };\n    }\n}\nPointCloudOctreePicker.helperVec3 = new external_three_.Vector3();\nPointCloudOctreePicker.helperSphere = new external_three_.Sphere();\nPointCloudOctreePicker.clearColor = new external_three_.Color();\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry.ts\n\nclass OctreeGeometry {\n    constructor(loader, boundingBox) {\n        this.loader = loader;\n        this.boundingBox = boundingBox;\n        this.maxNumNodesLoading = 3;\n        this.numNodesLoading = 0;\n        this.needsUpdate = true;\n        this.disposed = false;\n        this.pointAttributes = null;\n        this.spacing = 0;\n        this.url = null;\n        this.tightBoundingBox = this.boundingBox.clone();\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.tightBoundingSphere = this.boundingSphere.clone();\n    }\n    dispose() {\n        this.root.traverse((node) => node.dispose());\n        this.disposed = true;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-tree.ts\n\nclass PointCloudTree extends external_three_.Object3D {\n    constructor() {\n        super(...arguments);\n        this.root = null;\n    }\n    initialized() {\n        return this.root !== null;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree.ts\n\n\n\n\n\n\n\n\nclass PointCloudOctree extends PointCloudTree {\n    constructor(potree, pcoGeometry, material) {\n        super();\n        this.disposed = false;\n        this.level = 0;\n        this.maxLevel = Infinity;\n        /**\n         * The minimum radius of a node's bounding sphere on the screen in order to be displayed.\n         */\n        this.minNodePixelSize = DEFAULT_MIN_NODE_PIXEL_SIZE;\n        this.root = null;\n        this.boundingBoxNodes = [];\n        this.visibleNodes = [];\n        this.visibleGeometry = [];\n        this.numVisiblePoints = 0;\n        this.showBoundingBox = false;\n        this.visibleBounds = new external_three_.Box3();\n        this.name = '';\n        this.potree = potree;\n        this.root = pcoGeometry.root;\n        this.pcoGeometry = pcoGeometry;\n        this.boundingBox = pcoGeometry.boundingBox;\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.position.copy(pcoGeometry.offset);\n        this.updateMatrix();\n        this.material = material || pcoGeometry instanceof OctreeGeometry ? new PointCloudMaterial({ colorRgba: true }) : new PointCloudMaterial();\n        this.initMaterial(this.material);\n    }\n    initMaterial(material) {\n        this.updateMatrixWorld(true);\n        const { min, max } = computeTransformedBoundingBox(this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(), this.matrixWorld);\n        const bWidth = max.z - min.z;\n        material.heightMin = min.z - 0.2 * bWidth;\n        material.heightMax = max.z + 0.2 * bWidth;\n    }\n    dispose() {\n        if (this.root) {\n            this.root.dispose();\n        }\n        this.pcoGeometry.root.traverse(n => this.potree.lru.remove(n));\n        this.pcoGeometry.dispose();\n        this.material.dispose();\n        this.visibleNodes = [];\n        this.visibleGeometry = [];\n        if (this.picker) {\n            this.picker.dispose();\n            this.picker = undefined;\n        }\n        this.disposed = true;\n    }\n    get pointSizeType() {\n        return this.material.pointSizeType;\n    }\n    set pointSizeType(value) {\n        this.material.pointSizeType = value;\n    }\n    toTreeNode(geometryNode, parent) {\n        const points = new external_three_.Points(geometryNode.geometry, this.material);\n        const node = new PointCloudOctreeNode(geometryNode, points);\n        points.name = geometryNode.name;\n        points.position.copy(geometryNode.boundingBox.min);\n        points.frustumCulled = false;\n        points.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(this, node);\n        if (parent) {\n            parent.sceneNode.add(points);\n            parent.children[geometryNode.index] = node;\n            geometryNode.oneTimeDisposeHandlers.push(() => {\n                node.disposeSceneNode();\n                parent.sceneNode.remove(node.sceneNode);\n                // Replace the tree node (rendered and in the GPU) with the geometry node.\n                parent.children[geometryNode.index] = geometryNode;\n            });\n        }\n        else {\n            this.root = node;\n            this.add(points);\n        }\n        return node;\n    }\n    updateVisibleBounds() {\n        const bounds = this.visibleBounds;\n        bounds.min.set(Infinity, Infinity, Infinity);\n        bounds.max.set(-Infinity, -Infinity, -Infinity);\n        for (const node of this.visibleNodes) {\n            if (node.isLeafNode) {\n                bounds.expandByPoint(node.boundingBox.min);\n                bounds.expandByPoint(node.boundingBox.max);\n            }\n        }\n    }\n    updateBoundingBoxes() {\n        if (!this.showBoundingBox || !this.parent) {\n            return;\n        }\n        let bbRoot = this.parent.getObjectByName('bbroot');\n        if (!bbRoot) {\n            bbRoot = new external_three_.Object3D();\n            bbRoot.name = 'bbroot';\n            this.parent.add(bbRoot);\n        }\n        const visibleBoxes = [];\n        for (const node of this.visibleNodes) {\n            if (node.boundingBoxNode !== undefined && node.isLeafNode) {\n                visibleBoxes.push(node.boundingBoxNode);\n            }\n        }\n        bbRoot.children = visibleBoxes;\n    }\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate === true) {\n            this.updateMatrix();\n        }\n        if (this.matrixWorldNeedsUpdate === true || force === true) {\n            if (!this.parent) {\n                this.matrixWorld.copy(this.matrix);\n            }\n            else {\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n            }\n            this.matrixWorldNeedsUpdate = false;\n            force = true;\n        }\n    }\n    hideDescendants(object) {\n        const toHide = [];\n        addVisibleChildren(object);\n        while (toHide.length > 0) {\n            const objToHide = toHide.shift();\n            objToHide.visible = false;\n            addVisibleChildren(objToHide);\n        }\n        function addVisibleChildren(obj) {\n            for (const child of obj.children) {\n                if (child.visible) {\n                    toHide.push(child);\n                }\n            }\n        }\n    }\n    moveToOrigin() {\n        this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\n        this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new external_three_.Vector3()));\n    }\n    moveToGroundPlane() {\n        this.position.y += -this.getBoundingBoxWorld().min.y;\n    }\n    getBoundingBoxWorld() {\n        this.updateMatrixWorld(true);\n        return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\n    }\n    getVisibleExtent() {\n        return this.visibleBounds.applyMatrix4(this.matrixWorld);\n    }\n    pick(renderer, camera, ray, params = {}) {\n        this.picker = this.picker || new PointCloudOctreePicker();\n        return this.picker.pick(renderer, camera, ray, [this], params);\n    }\n    get progress() {\n        return this.visibleGeometry.length === 0\n            ? 0\n            : this.visibleNodes.length / this.visibleGeometry.length;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/features.ts\nconst canvas = document.createElement('canvas');\nconst gl = canvas.getContext('webgl');\nconst FEATURES = {\n    SHADER_INTERPOLATION: hasExtension('EXT_frag_depth') && hasMinVaryingVectors(8),\n    SHADER_SPLATS: hasExtension('EXT_frag_depth') && hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n    SHADER_EDL: hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\n    precision: getPrecision(),\n};\nfunction hasExtension(ext) {\n    return gl !== null && Boolean(gl.getExtension(ext));\n}\nfunction hasMinVaryingVectors(value) {\n    return gl !== null && gl.getParameter(gl.MAX_VARYING_VECTORS) >= value;\n}\nfunction getPrecision() {\n    if (gl === null) {\n        return '';\n    }\n    const vsHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n    const vsMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n    const fsHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n    const fsMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n    const highpAvailable = vsHighpFloat && fsHighpFloat && vsHighpFloat.precision > 0 && fsHighpFloat.precision > 0;\n    const mediumpAvailable = vsMediumpFloat &&\n        fsMediumpFloat &&\n        vsMediumpFloat.precision > 0 &&\n        fsMediumpFloat.precision > 0;\n    return highpAvailable ? 'highp' : mediumpAvailable ? 'mediump' : 'lowp';\n}\n\n;// CONCATENATED MODULE: ./src/utils/async-blocking-queue.ts\nclass AsyncBlockingQueue {\n    constructor() {\n        this.resolvers = [];\n        this.promises = [];\n    }\n    enqueue(t) {\n        if (!this.resolvers.length) {\n            this.add();\n        }\n        const resolve = this.resolvers.shift();\n        resolve(t);\n    }\n    dequeue() {\n        if (!this.promises.length) {\n            this.add();\n        }\n        return this.promises.shift();\n    }\n    add() {\n        this.promises.push(new Promise(resolve => {\n            this.resolvers.push(resolve);\n        }));\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/worker-pool.ts\n\nclass AutoTerminatingWorker {\n    constructor(wrappedWorker, maxIdle) {\n        this.wrappedWorker = wrappedWorker;\n        this.maxIdle = maxIdle;\n        this.timeoutId = undefined;\n        this.terminated = false;\n    }\n    get worker() {\n        return this.wrappedWorker;\n    }\n    get isTerminated() {\n        return this.terminated;\n    }\n    markIdle() {\n        this.timeoutId = window.setTimeout(() => {\n            this.terminated = true;\n            this.wrappedWorker.terminate();\n        }, this.maxIdle);\n    }\n    markInUse() {\n        if (this.timeoutId) {\n            window.clearTimeout(this.timeoutId);\n        }\n    }\n}\nclass WorkerPool {\n    constructor(maxWorkers, workerType) {\n        this.maxWorkers = maxWorkers;\n        this.workerType = workerType;\n        this.pool = new AsyncBlockingQueue();\n        this.poolSize = 0;\n    }\n    /**\n     * Returns a worker promise which is resolved when one is available.\n     */\n    getWorker() {\n        // If the number of active workers is smaller than the maximum, return a new one.\n        // Otherwise, return a promise for worker from the pool.\n        if (this.poolSize < this.maxWorkers) {\n            this.poolSize++;\n            return Promise.resolve(new AutoTerminatingWorker(new this.workerType(), WorkerPool.POOL_MAX_IDLE));\n        }\n        else {\n            return this.pool.dequeue().then(worker => {\n                worker.markInUse();\n                // If the dequeued worker has been terminated, decrease the pool size and make a recursive call to get a new worker\n                if (worker.isTerminated) {\n                    this.poolSize--;\n                    return this.getWorker();\n                }\n                return worker;\n            });\n        }\n    }\n    /**\n     * Releases a Worker back into the pool\n     * @param worker\n     */\n    releaseWorker(worker) {\n        worker.markIdle();\n        this.pool.enqueue(worker);\n    }\n}\n/**\n * The maximum amount of idle time that can elapse before a worker from this pool is automatically terminated\n */\nWorkerPool.POOL_MAX_IDLE = 7000;\n\n;// CONCATENATED MODULE: ./src/version.ts\nclass Version {\n    constructor(version) {\n        this.versionMinor = 0;\n        this.version = version;\n        const vmLength = version.indexOf('.') === -1 ? version.length : version.indexOf('.');\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\n        if (isNaN(this.versionMinor)) {\n            this.versionMinor = 0;\n        }\n    }\n    newerThan(version) {\n        const v = new Version(version);\n        if (this.versionMajor > v.versionMajor) {\n            return true;\n        }\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    equalOrHigher(version) {\n        const v = new Version(version);\n        if (this.versionMajor > v.versionMajor) {\n            return true;\n        }\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    upTo(version) {\n        return !this.newerThan(version);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading/binary-loader.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\n\n\n\n\nclass BinaryLoader {\n    constructor({ getUrl = s => Promise.resolve(s), version, boundingBox, scale, xhrRequest, }) {\n        this.disposed = false;\n        if (typeof version === 'string') {\n            this.version = new Version(version);\n        }\n        else {\n            this.version = version;\n        }\n        this.xhrRequest = xhrRequest;\n        this.getUrl = getUrl;\n        this.boundingBox = boundingBox;\n        this.scale = scale;\n        this.callbacks = [];\n    }\n    dispose() {\n        this.disposed = true;\n    }\n    load(node) {\n        if (node.loaded || this.disposed) {\n            return Promise.resolve();\n        }\n        return Promise.resolve(this.getUrl(this.getNodeUrl(node)))\n            .then(url => this.xhrRequest(url, { mode: 'cors' }))\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.arrayBuffer())\n            .then(buffer => handleEmptyBuffer(buffer))\n            .then(okBuffer => {\n            return new Promise(resolve => this.parse(node, okBuffer, resolve));\n        });\n    }\n    getNodeUrl(node) {\n        let url = node.getUrl();\n        if (this.version.equalOrHigher('1.4')) {\n            url += '.bin';\n        }\n        return url;\n    }\n    parse(node, buffer, resolve) {\n        if (this.disposed) {\n            resolve();\n            return;\n        }\n        BinaryLoader.WORKER_POOL.getWorker().then(autoTerminatingWorker => {\n            const pointAttributes = node.pcoGeometry.pointAttributes;\n            const numPoints = buffer.byteLength / pointAttributes.byteSize;\n            if (this.version.upTo('1.5')) {\n                node.numPoints = numPoints;\n            }\n            autoTerminatingWorker.worker.onmessage = (e) => {\n                if (this.disposed) {\n                    resolve();\n                    BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n                    return;\n                }\n                const data = e.data;\n                const geometry = (node.geometry = node.geometry || new external_three_.BufferGeometry());\n                geometry.boundingBox = node.boundingBox;\n                this.addBufferAttributes(geometry, data.attributeBuffers);\n                this.addIndices(geometry, data.indices);\n                this.addNormalAttribute(geometry, numPoints);\n                node.mean = new external_three_.Vector3().fromArray(data.mean);\n                node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n                node.loaded = true;\n                node.loading = false;\n                node.failed = false;\n                node.pcoGeometry.numNodesLoading--;\n                node.pcoGeometry.needsUpdate = true;\n                this.callbacks.forEach(callback => callback(node));\n                resolve();\n                BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\n            };\n            const message = {\n                buffer,\n                pointAttributes,\n                version: this.version.version,\n                min: node.boundingBox.min.toArray(),\n                offset: node.pcoGeometry.offset.toArray(),\n                scale: this.scale,\n                spacing: node.spacing,\n                hasChildren: node.hasChildren,\n            };\n            autoTerminatingWorker.worker.postMessage(message, [message.buffer]);\n        });\n    }\n    getTightBoundingBox({ min, max }) {\n        const box = new external_three_.Box3(new external_three_.Vector3().fromArray(min), new external_three_.Vector3().fromArray(max));\n        box.max.sub(box.min);\n        box.min.set(0, 0, 0);\n        return box;\n    }\n    addBufferAttributes(geometry, buffers) {\n        Object.keys(buffers).forEach(property => {\n            const buffer = buffers[property].buffer;\n            if (this.isAttribute(property, PointAttributeName.POSITION_CARTESIAN)) {\n                geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.COLOR_PACKED)) {\n                geometry.setAttribute('color', new external_three_.BufferAttribute(new Uint8Array(buffer), 3, true));\n            }\n            else if (this.isAttribute(property, PointAttributeName.INTENSITY)) {\n                geometry.setAttribute('intensity', new external_three_.BufferAttribute(new Float32Array(buffer), 1));\n            }\n            else if (this.isAttribute(property, PointAttributeName.CLASSIFICATION)) {\n                geometry.setAttribute('classification', new external_three_.BufferAttribute(new Uint8Array(buffer), 1));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_SPHEREMAPPED)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_OCT16)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n            else if (this.isAttribute(property, PointAttributeName.NORMAL)) {\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n            }\n        });\n    }\n    addIndices(geometry, indices) {\n        const indicesAttribute = new external_three_.Uint8BufferAttribute(indices, 4);\n        indicesAttribute.normalized = true;\n        geometry.setAttribute('indices', indicesAttribute);\n    }\n    addNormalAttribute(geometry, numPoints) {\n        if (!geometry.getAttribute('normal')) {\n            const buffer = new Float32Array(numPoints * 3);\n            geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n        }\n    }\n    isAttribute(property, name) {\n        return parseInt(property, 10) === name;\n    }\n}\nBinaryLoader.WORKER_POOL = new WorkerPool(32, (__webpack_require__(91)/* [\"default\"] */ .A));\n\n;// CONCATENATED MODULE: ./src/loading/load-poc.ts\n// -------------------------------------------------------------------------------------------------\n// Converted to Typescript and adapted from https://github.com/potree/potree\n// -------------------------------------------------------------------------------------------------\n\n\n\n\n\n\n\n\n/**\n *\n * @param url\n *    The url of the point cloud file (usually cloud.js).\n * @param getUrl\n *    Function which receives the relative URL of a point cloud chunk file which is to be loaded\n *    and shoud return a new url (e.g. signed) in the form of a string or a promise.\n * @param xhrRequest An arrow function for a fetch request\n * @returns\n *    An observable which emits once when the first LOD of the point cloud is loaded.\n */\nfunction loadPOC(url, getUrl, xhrRequest) {\n    return Promise.resolve(getUrl(url)).then(transformedUrl => {\n        return xhrRequest(transformedUrl, { mode: 'cors' })\n            .then(res => handleFailedRequest(res))\n            .then(okRes => okRes.json())\n            .then(parse(transformedUrl, getUrl, xhrRequest));\n    });\n}\nfunction parse(url, getUrl, xhrRequest) {\n    return (data) => {\n        const { offset, boundingBox, tightBoundingBox } = getBoundingBoxes(data);\n        const loader = new BinaryLoader({\n            getUrl,\n            version: data.version,\n            boundingBox,\n            scale: data.scale,\n            xhrRequest,\n        });\n        const pco = new PointCloudOctreeGeometry(loader, boundingBox, tightBoundingBox, offset, xhrRequest);\n        pco.url = url;\n        pco.octreeDir = data.octreeDir;\n        pco.needsUpdate = true;\n        pco.spacing = data.spacing;\n        pco.hierarchyStepSize = data.hierarchyStepSize;\n        pco.projection = data.projection;\n        pco.offset = offset;\n        pco.pointAttributes = new PointAttributes(data.pointAttributes);\n        const nodes = {};\n        const version = new Version(data.version);\n        return loadRoot(pco, data, nodes, version).then(() => {\n            if (version.upTo('1.4')) {\n                loadRemainingHierarchy(pco, data, nodes);\n            }\n            pco.nodes = nodes;\n            return pco;\n        });\n    };\n}\nfunction getBoundingBoxes(data) {\n    const min = new external_three_.Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\n    const max = new external_three_.Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\n    const boundingBox = new external_three_.Box3(min, max);\n    const tightBoundingBox = boundingBox.clone();\n    const offset = min.clone();\n    if (data.tightBoundingBox) {\n        const { lx, ly, lz, ux, uy, uz } = data.tightBoundingBox;\n        tightBoundingBox.min.set(lx, ly, lz);\n        tightBoundingBox.max.set(ux, uy, uz);\n    }\n    boundingBox.min.sub(offset);\n    boundingBox.max.sub(offset);\n    tightBoundingBox.min.sub(offset);\n    tightBoundingBox.max.sub(offset);\n    return { offset, boundingBox, tightBoundingBox };\n}\nfunction loadRoot(pco, data, nodes, version) {\n    const name = 'r';\n    const root = new PointCloudOctreeGeometryNode(name, pco, pco.boundingBox);\n    root.hasChildren = true;\n    root.spacing = pco.spacing;\n    if (version.upTo('1.5')) {\n        root.numPoints = data.hierarchy[0][1];\n    }\n    else {\n        root.numPoints = 0;\n    }\n    pco.root = root;\n    nodes[name] = root;\n    return pco.root.load();\n}\nfunction loadRemainingHierarchy(pco, data, nodes) {\n    for (let i = 1; i < data.hierarchy.length; i++) {\n        const [name, numPoints] = data.hierarchy[i];\n        const { index, parentName, level } = parseName(name);\n        const parentNode = nodes[parentName];\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\n        node.level = level;\n        node.numPoints = numPoints;\n        node.spacing = pco.spacing / Math.pow(2, node.level);\n        nodes[name] = node;\n        parentNode.addChild(node);\n    }\n}\nfunction parseName(name) {\n    return {\n        index: getIndexFromName(name),\n        parentName: name.substring(0, name.length - 1),\n        level: name.length - 1,\n    };\n}\n\n;// CONCATENATED MODULE: ./src/loading/index.ts\n\n\n\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry-node.ts\n\nclass OctreeGeometryNode {\n    constructor(name, octreeGeometry, boundingBox) {\n        this.name = name;\n        this.octreeGeometry = octreeGeometry;\n        this.boundingBox = boundingBox;\n        this.loaded = false;\n        this.loading = false;\n        this.parent = null;\n        this.geometry = null;\n        this.hasChildren = false;\n        this.isLeafNode = true;\n        this.isTreeNode = false;\n        this.isGeometryNode = true;\n        this.children = [\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null,\n            null\n        ];\n        this.id = OctreeGeometryNode.IDCount++;\n        this.index = parseInt(name.charAt(name.length - 1));\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n        this.tightBoundingBox = boundingBox.clone();\n        this.numPoints = 0;\n        this.oneTimeDisposeHandlers = [];\n    }\n    getLevel() {\n        return this.level;\n    }\n    isLoaded() {\n        return this.loaded;\n    }\n    getBoundingSphere() {\n        return this.boundingSphere;\n    }\n    getBoundingBox() {\n        return this.boundingBox;\n    }\n    load() {\n        if (this.octreeGeometry.numNodesLoading >= this.octreeGeometry.maxNumNodesLoading) {\n            return;\n        }\n        if (this.octreeGeometry.loader) {\n            this.octreeGeometry.loader.load(this);\n        }\n    }\n    getNumPoints() {\n        return this.numPoints;\n    }\n    dispose() {\n        if (this.geometry && this.parent != null) {\n            this.geometry.dispose();\n            this.geometry = null;\n            this.loaded = false;\n            for (let i = 0; i < this.oneTimeDisposeHandlers.length; i++) {\n                const handler = this.oneTimeDisposeHandlers[i];\n                handler();\n            }\n            this.oneTimeDisposeHandlers = [];\n        }\n    }\n    traverse(cb, includeSelf = true) {\n        const stack = includeSelf ? [this] : [];\n        let current;\n        while ((current = stack.pop()) !== undefined) {\n            cb(current);\n            for (const child of current.children) {\n                if (child !== null) {\n                    stack.push(child);\n                }\n            }\n        }\n    }\n}\nOctreeGeometryNode.IDCount = 0;\nOctreeGeometryNode.IDCount = 0;\n\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\n/**\n * Some types of possible point attribute data formats\n *\n * @class\n */\nconst PointAttributeTypes = {\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\n};\nlet i = 0;\nfor (const obj in PointAttributeTypes) {\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\n    i++;\n}\n\nclass PointAttribute {\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\n        this.name = name;\n        this.type = type;\n        this.numElements = numElements;\n        this.range = range;\n        this.uri = uri;\n        this.byteSize = this.numElements * this.type.size;\n        this.description = '';\n    }\n}\n\nconst point_attributes_POINT_ATTRIBUTES = {\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\n};\nclass point_attributes_PointAttributes {\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\n        this.attributes = attributes;\n        this.byteSize = byteSize;\n        this.size = size;\n        this.vectors = vectors;\n        if (pointAttributes != null) {\n            for (let i = 0; i < pointAttributes.length; i++) {\n                const pointAttributeName = pointAttributes[i];\n                const pointAttribute = point_attributes_POINT_ATTRIBUTES[pointAttributeName];\n                this.attributes.push(pointAttribute);\n                this.byteSize += pointAttribute.byteSize;\n                this.size++;\n            }\n        }\n    }\n    add(pointAttribute) {\n        this.attributes.push(pointAttribute);\n        this.byteSize += pointAttribute.byteSize;\n        this.size++;\n    }\n    addVector(vector) {\n        this.vectors.push(vector);\n    }\n    hasNormals() {\n        for (const name in this.attributes) {\n            const pointAttribute = this.attributes[name];\n            if (pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_FLOATS ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL ||\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_OCT16) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getAttribute(attributeName) {\n        return this.attributes.find(attr => attr.name === attributeName);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/worker-pool.ts\n// Create enums for different types of workers\nvar WorkerType;\n(function (WorkerType) {\n    WorkerType[\"DECODER_WORKER\"] = \"DECODER_WORKER\";\n    WorkerType[\"DECODER_WORKER_GLTF\"] = \"DECODER_WORKER_GLTF\";\n})(WorkerType || (WorkerType = {}));\n// Worker JS names: 'BinaryDecoderWorker.js', 'DEMWorker.js', 'EptBinaryDecoderWorker.js', 'EptLaszipDecoderWorker.js',\n// EptZstandardDecoder_preamble.js', 'EptZstandardDecoderWorker.js', 'LASDecoderWorker.js', 'LASLAZWorker.js', 'LazLoaderWorker.js'\nfunction createWorker(type) {\n    // console.log(type)\n    switch (type) {\n        case WorkerType.DECODER_WORKER: {\n            const DecoderWorker = (__webpack_require__(300)/* [\"default\"] */ .A);\n            return new DecoderWorker();\n        }\n        case WorkerType.DECODER_WORKER_GLTF: {\n            const DecoderWorker_GLTF = (__webpack_require__(218)/* [\"default\"] */ .A);\n            return new DecoderWorker_GLTF();\n        }\n        default:\n            throw new Error('Unknown worker type');\n    }\n}\nclass worker_pool_WorkerPool {\n    constructor() {\n        // Workers will be an object that has a key for each worker type and the value is an array of Workers that can be empty\n        this.workers = { DECODER_WORKER: [], DECODER_WORKER_GLTF: [] };\n    }\n    getWorker(workerType) {\n        // Throw error if workerType is not recognized\n        if (this.workers[workerType] === undefined) {\n            throw new Error('Unknown worker type');\n        }\n        // Given a worker URL, if URL does not exist in the worker object, create a new array with the URL as a key\n        if (this.workers[workerType].length === 0) {\n            const worker = createWorker(workerType);\n            this.workers[workerType].push(worker);\n        }\n        const worker = this.workers[workerType].pop();\n        if (worker === undefined) { // Typescript needs this\n            throw new Error('No workers available');\n        }\n        // Return the last worker in the array and remove it from the array\n        return worker;\n    }\n    returnWorker(workerType, worker) {\n        this.workers[workerType].push(worker);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/utils.ts\nfunction extractBasePath(url) {\n    return url.substring(0, url.lastIndexOf('/') + 1);\n}\nfunction buildUrl(basePath, fileName) {\n    return `${basePath}${fileName}`;\n}\n\n;// CONCATENATED MODULE: ./src/loading2/octree-loader.ts\n\n\n\n\n\n\n\n// Buffer files for DEFAULT encoding\nconst HIERARCHY_FILE = 'hierarchy.bin';\nconst OCTREE_FILE = 'octree.bin';\n// Default buffer files for GLTF encoding\nconst GLTF_COLORS_FILE = 'colors.glbin';\nconst GLTF_POSITIONS_FILE = 'positions.glbin';\nclass NodeLoader {\n    constructor(getUrl, url, workerPool, metadata) {\n        this.getUrl = getUrl;\n        this.url = url;\n        this.workerPool = workerPool;\n        this.metadata = metadata;\n        this.hierarchyPath = '';\n        this.octreePath = '';\n        this.gltfColorsPath = '';\n        this.gltfPositionsPath = '';\n    }\n    async load(node) {\n        if (node.loaded || node.loading) {\n            return;\n        }\n        node.loading = true;\n        node.octreeGeometry.numNodesLoading++;\n        try {\n            if (node.nodeType === 2) {\n                await this.loadHierarchy(node);\n            }\n            const { byteOffset, byteSize } = node;\n            if (byteOffset === undefined || byteSize === undefined) {\n                throw new Error('byteOffset and byteSize are required');\n            }\n            let buffer;\n            if (this.metadata.encoding === \"GLTF\") {\n                const urlColors = await this.getUrl(this.gltfColorsPath);\n                const urlPositions = await this.getUrl(this.gltfPositionsPath);\n                if (byteSize === BigInt(0)) {\n                    buffer = new ArrayBuffer(0);\n                    console.warn(`loaded node with 0 bytes: ${node.name}`);\n                }\n                else {\n                    const firstPositions = byteOffset * 4n * 3n;\n                    const lastPositions = byteOffset * 4n * 3n + byteSize * 4n * 3n - 1n;\n                    const headersPositions = { Range: `bytes=${firstPositions}-${lastPositions}` };\n                    const responsePositions = await fetch(urlPositions, { headers: headersPositions });\n                    const bufferPositions = await responsePositions.arrayBuffer();\n                    const firstColors = byteOffset * 4n;\n                    const lastColors = byteOffset * 4n + byteSize * 4n - 1n;\n                    const headersColors = { Range: `bytes=${firstColors}-${lastColors}` };\n                    const responseColors = await fetch(urlColors, { headers: headersColors });\n                    const bufferColors = await responseColors.arrayBuffer();\n                    buffer = appendBuffer(bufferPositions, bufferColors);\n                }\n            }\n            else {\n                const urlOctree = await this.getUrl(this.octreePath);\n                const first = byteOffset;\n                const last = byteOffset + byteSize - BigInt(1);\n                if (byteSize === BigInt(0)) {\n                    buffer = new ArrayBuffer(0);\n                    console.warn(`loaded node with 0 bytes: ${node.name}`);\n                }\n                else {\n                    const headers = { Range: `bytes=${first}-${last}` };\n                    const response = await fetch(urlOctree, { headers });\n                    buffer = await response.arrayBuffer();\n                }\n            }\n            const workerType = this.metadata.encoding === 'GLTF' ? WorkerType.DECODER_WORKER_GLTF : WorkerType.DECODER_WORKER;\n            const worker = this.workerPool.getWorker(workerType);\n            worker.onmessage = (e) => {\n                const data = e.data;\n                const buffers = data.attributeBuffers;\n                this.workerPool.returnWorker(workerType, worker);\n                const geometry = new external_three_.BufferGeometry();\n                for (const property in buffers) {\n                    const buffer = buffers[property].buffer;\n                    if (property === 'position') {\n                        geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n                    }\n                    else if (property === 'rgba') {\n                        geometry.setAttribute('rgba', new external_three_.BufferAttribute(new Uint8Array(buffer), 4, true));\n                    }\n                    else if (property === 'NORMAL') {\n                        geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\n                    }\n                    else if (property === 'INDICES') {\n                        const bufferAttribute = new external_three_.BufferAttribute(new Uint8Array(buffer), 4);\n                        bufferAttribute.normalized = true;\n                        geometry.setAttribute('indices', bufferAttribute);\n                    }\n                    else {\n                        const bufferAttribute = new external_three_.BufferAttribute(new Float32Array(buffer), 1);\n                        const batchAttribute = buffers[property].attribute;\n                        bufferAttribute.potree = {\n                            offset: buffers[property].offset,\n                            scale: buffers[property].scale,\n                            preciseBuffer: buffers[property].preciseBuffer,\n                            range: batchAttribute.range\n                        };\n                        geometry.setAttribute(property, bufferAttribute);\n                    }\n                }\n                node.density = data.density;\n                node.geometry = geometry;\n                node.loaded = true;\n                node.loading = false;\n                node.octreeGeometry.numNodesLoading--;\n                node.octreeGeometry.needsUpdate = true;\n                node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\n            };\n            const pointAttributes = node.octreeGeometry.pointAttributes;\n            const scale = node.octreeGeometry.scale;\n            const box = node.boundingBox;\n            const min = node.octreeGeometry.offset.clone().add(box.min);\n            const size = box.max.clone().sub(box.min);\n            const max = min.clone().add(size);\n            const numPoints = node.numPoints;\n            const offset = node.octreeGeometry.loader.offset;\n            const message = {\n                name: node.name,\n                buffer: buffer,\n                pointAttributes: pointAttributes,\n                scale: scale,\n                min: min,\n                max: max,\n                size: size,\n                offset: offset,\n                numPoints: numPoints\n            };\n            worker.postMessage(message, [message.buffer]);\n        }\n        catch (e) {\n            node.loaded = false;\n            node.loading = false;\n            node.octreeGeometry.numNodesLoading--;\n        }\n    }\n    parseHierarchy(node, buffer) {\n        const view = new DataView(buffer);\n        const bytesPerNode = 22;\n        const numNodes = buffer.byteLength / bytesPerNode;\n        const octree = node.octreeGeometry;\n        const nodes = new Array(numNodes);\n        nodes[0] = node;\n        let nodePos = 1;\n        for (let i = 0; i < numNodes; i++) {\n            const current = nodes[i];\n            const type = view.getUint8(i * bytesPerNode + 0);\n            const childMask = view.getUint8(i * bytesPerNode + 1);\n            const numPoints = view.getUint32(i * bytesPerNode + 2, true);\n            const byteOffset = view.getBigInt64(i * bytesPerNode + 6, true);\n            const byteSize = view.getBigInt64(i * bytesPerNode + 14, true);\n            if (current.nodeType === 2) {\n                // replace proxy with real node\n                current.byteOffset = byteOffset;\n                current.byteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            else if (type === 2) {\n                // load proxy\n                current.hierarchyByteOffset = byteOffset;\n                current.hierarchyByteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            else {\n                // load real node\n                current.byteOffset = byteOffset;\n                current.byteSize = byteSize;\n                current.numPoints = numPoints;\n            }\n            current.nodeType = type;\n            if (current.nodeType === 2) {\n                continue;\n            }\n            for (let childIndex = 0; childIndex < 8; childIndex++) {\n                const childExists = (1 << childIndex & childMask) !== 0;\n                if (!childExists) {\n                    continue;\n                }\n                const childName = current.name + childIndex;\n                const childAABB = octree_loader_createChildAABB(current.boundingBox, childIndex);\n                const child = new OctreeGeometryNode(childName, octree, childAABB);\n                child.name = childName;\n                child.spacing = current.spacing / 2;\n                child.level = current.level + 1;\n                current.children[childIndex] = child;\n                child.parent = current;\n                nodes[nodePos] = child;\n                nodePos++;\n            }\n        }\n    }\n    async loadHierarchy(node) {\n        const { hierarchyByteOffset, hierarchyByteSize } = node;\n        if (hierarchyByteOffset === undefined || hierarchyByteSize === undefined) {\n            throw new Error(`hierarchyByteOffset and hierarchyByteSize are undefined for node ${node.name}`);\n        }\n        const hierarchyUrl = await this.getUrl(this.hierarchyPath);\n        const first = hierarchyByteOffset;\n        const last = first + hierarchyByteSize - BigInt(1);\n        const headers = { Range: `bytes=${first}-${last}` };\n        const response = await fetch(hierarchyUrl, { headers });\n        const buffer = await response.arrayBuffer();\n        this.parseHierarchy(node, buffer);\n    }\n    getTightBoundingBox({ min, max }) {\n        const box = new external_three_.Box3(new external_three_.Vector3().fromArray(min), new external_three_.Vector3().fromArray(max));\n        box.max.sub(box.min);\n        box.min.set(0, 0, 0);\n        return box;\n    }\n}\nconst tmpVec3 = new external_three_.Vector3();\nfunction octree_loader_createChildAABB(aabb, index) {\n    const min = aabb.min.clone();\n    const max = aabb.max.clone();\n    const size = tmpVec3.subVectors(max, min);\n    if ((index & 0b0001) > 0) {\n        min.z += size.z / 2;\n    }\n    else {\n        max.z -= size.z / 2;\n    }\n    if ((index & 0b0010) > 0) {\n        min.y += size.y / 2;\n    }\n    else {\n        max.y -= size.y / 2;\n    }\n    if ((index & 0b0100) > 0) {\n        min.x += size.x / 2;\n    }\n    else {\n        max.x -= size.x / 2;\n    }\n    return new external_three_.Box3(min, max);\n}\nfunction appendBuffer(buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n}\nconst typenameTypeattributeMap = {\n    double: PointAttributeTypes.DATA_TYPE_DOUBLE,\n    float: PointAttributeTypes.DATA_TYPE_FLOAT,\n    int8: PointAttributeTypes.DATA_TYPE_INT8,\n    uint8: PointAttributeTypes.DATA_TYPE_UINT8,\n    int16: PointAttributeTypes.DATA_TYPE_INT16,\n    uint16: PointAttributeTypes.DATA_TYPE_UINT16,\n    int32: PointAttributeTypes.DATA_TYPE_INT32,\n    uint32: PointAttributeTypes.DATA_TYPE_UINT32,\n    int64: PointAttributeTypes.DATA_TYPE_INT64,\n    uint64: PointAttributeTypes.DATA_TYPE_UINT64\n};\nclass OctreeLoader {\n    constructor(getUrl, url) {\n        this.workerPool = new worker_pool_WorkerPool();\n        this.basePath = '';\n        this.hierarchyPath = '';\n        this.octreePath = '';\n        this.gltfColorsPath = '';\n        this.gltfPositionsPath = '';\n        this.getUrl = getUrl;\n        this.basePath = extractBasePath(url);\n        this.hierarchyPath = buildUrl(this.basePath, HIERARCHY_FILE);\n        this.octreePath = buildUrl(this.basePath, OCTREE_FILE);\n        // We default to the known naming convention for glTF datasets\n        this.gltfColorsPath = buildUrl(this.basePath, GLTF_COLORS_FILE);\n        this.gltfPositionsPath = buildUrl(this.basePath, GLTF_POSITIONS_FILE);\n    }\n    static parseAttributes(jsonAttributes) {\n        const attributes = new point_attributes_PointAttributes();\n        const replacements = { rgb: 'rgba' };\n        for (const jsonAttribute of jsonAttributes) {\n            const { name, numElements, min, max, bufferView } = jsonAttribute;\n            const type = typenameTypeattributeMap[jsonAttribute.type];\n            const potreeAttributeName = replacements[name] ? replacements[name] : name;\n            const attribute = new PointAttribute(potreeAttributeName, type, numElements);\n            if (bufferView) {\n                attribute.uri = bufferView.uri;\n            }\n            if (numElements === 1 && min && max) {\n                attribute.range = [min[0], max[0]];\n            }\n            else {\n                attribute.range = [min, max];\n            }\n            if (name === 'gps-time') { // HACK: Guard against bad gpsTime range in metadata, see potree/potree#909\n                if (typeof attribute.range[0] === 'number' && attribute.range[0] === attribute.range[1]) {\n                    attribute.range[1] += 1;\n                }\n            }\n            attribute.initialRange = attribute.range;\n            attributes.add(attribute);\n        }\n        {\n            const hasNormals = attributes.attributes.find((a) => a.name === 'NormalX') !== undefined &&\n                attributes.attributes.find((a) => a.name === 'NormalY') !== undefined &&\n                attributes.attributes.find((a) => a.name === 'NormalZ') !== undefined;\n            if (hasNormals) {\n                const vector = {\n                    name: 'NORMAL',\n                    attributes: ['NormalX', 'NormalY', 'NormalZ']\n                };\n                attributes.addVector(vector);\n            }\n        }\n        return attributes;\n    }\n    async load(url, xhrRequest) {\n        const metadata = await this.fetchMetadata(url, xhrRequest);\n        const attributes = OctreeLoader.parseAttributes(metadata.attributes);\n        this.applyCustomBufferURI(metadata.encoding, attributes);\n        const loader = this.createLoader(url, metadata, attributes);\n        const boundingBox = this.createBoundingBox(metadata);\n        const offset = this.getOffset(boundingBox);\n        const octree = this.initializeOctree(loader, url, metadata, boundingBox, offset, attributes);\n        const root = this.initializeRootNode(octree, boundingBox, metadata);\n        octree.root = root;\n        loader.load(root);\n        return { geometry: octree };\n    }\n    async fetchMetadata(url, xhrRequest) {\n        const response = await xhrRequest(url);\n        return response.json();\n    }\n    applyCustomBufferURI(encoding, attributes) {\n        // Only datasets with GLTF encoding support custom buffer URIs -\n        // as opposed to datasets with DEFAULT encoding coming from PotreeConverter\n        if (encoding === 'GLTF') {\n            this.gltfPositionsPath = attributes.getAttribute(\"position\")?.uri ?? this.gltfPositionsPath;\n            this.gltfColorsPath = attributes.getAttribute(\"rgba\")?.uri ?? this.gltfColorsPath;\n        }\n    }\n    createLoader(url, metadata, attributes) {\n        const loader = new NodeLoader(this.getUrl, url, this.workerPool, metadata);\n        loader.attributes = attributes;\n        loader.scale = metadata.scale;\n        loader.offset = metadata.offset;\n        loader.hierarchyPath = this.hierarchyPath;\n        loader.octreePath = this.octreePath;\n        loader.gltfColorsPath = this.gltfColorsPath;\n        loader.gltfPositionsPath = this.gltfPositionsPath;\n        return loader;\n    }\n    createBoundingBox(metadata) {\n        const min = new external_three_.Vector3(...metadata.boundingBox.min);\n        const max = new external_three_.Vector3(...metadata.boundingBox.max);\n        const boundingBox = new external_three_.Box3(min, max);\n        return boundingBox;\n    }\n    getOffset(boundingBox) {\n        const offset = boundingBox.min.clone();\n        boundingBox.min.sub(offset);\n        boundingBox.max.sub(offset);\n        return offset;\n    }\n    initializeOctree(loader, url, metadata, boundingBox, offset, attributes) {\n        const octree = new OctreeGeometry(loader, boundingBox);\n        octree.url = url;\n        octree.spacing = metadata.spacing;\n        octree.scale = metadata.scale;\n        octree.projection = metadata.projection;\n        octree.boundingBox = boundingBox;\n        octree.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n        octree.tightBoundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\n        octree.tightBoundingBox = this.getTightBoundingBox(metadata);\n        octree.offset = offset;\n        octree.pointAttributes = attributes;\n        return octree;\n    }\n    initializeRootNode(octree, boundingBox, metadata) {\n        const root = new OctreeGeometryNode('r', octree, boundingBox);\n        root.level = 0;\n        root.nodeType = 2;\n        root.hierarchyByteOffset = BigInt(0);\n        root.hierarchyByteSize = BigInt(metadata.hierarchy.firstChunkSize);\n        root.spacing = octree.spacing;\n        root.byteOffset = BigInt(0);\n        return root;\n    }\n    getTightBoundingBox(metadata) {\n        const positionAttribute = metadata.attributes.find((attr) => attr.name === 'position');\n        if (!positionAttribute || !positionAttribute.min || !positionAttribute.max) {\n            console.warn('Position attribute (min, max) not found. Falling back to boundingBox for tightBoundingBox');\n            return new external_three_.Box3(new external_three_.Vector3(...metadata.boundingBox.min), new external_three_.Vector3(...metadata.boundingBox.max));\n        }\n        const offset = metadata.boundingBox.min;\n        const tightBoundingBox = new external_three_.Box3(new external_three_.Vector3(positionAttribute.min[0] - offset[0], positionAttribute.min[1] - offset[1], positionAttribute.min[2] - offset[2]), new external_three_.Vector3(positionAttribute.max[0] - offset[0], positionAttribute.max[1] - offset[1], positionAttribute.max[2] - offset[2]));\n        return tightBoundingBox;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/load-octree.ts\n\nasync function loadOctree(url, getUrl, xhrRequest) {\n    const trueUrl = await getUrl(url);\n    const loader = new OctreeLoader(getUrl, url);\n    const { geometry } = await loader.load(trueUrl, xhrRequest);\n    return geometry;\n}\n\n;// CONCATENATED MODULE: ./src/type-predicates.ts\nfunction isGeometryNode(node) {\n    return node !== undefined && node !== null && node.isGeometryNode;\n}\nfunction isTreeNode(node) {\n    return node !== undefined && node !== null && node.isTreeNode;\n}\n\n;// CONCATENATED MODULE: ./src/utils/binary-heap.js\n/**\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\n *\n */\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n  pop: function pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n  remove: function remove(node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  },\n  size: function size() {\n    return this.content.length;\n  },\n  bubbleUp: function bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n  sinkDown: function sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n};\n;// CONCATENATED MODULE: ./src/utils/box3-helper.ts\n\n/**\n *\n * code adapted from three.js BoxHelper.js\n * https://github.com/mrdoob/three.js/blob/dev/src/helpers/BoxHelper.js\n *\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / http://github.com/Mugen87\n * @author mschuetz / http://potree.org\n */\nclass Box3Helper extends external_three_.LineSegments {\n    constructor(box, color = new external_three_.Color(0xffff00)) {\n        // prettier-ignore\n        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n        // prettier-ignore\n        const positions = new Float32Array([\n            box.min.x, box.min.y, box.min.z,\n            box.max.x, box.min.y, box.min.z,\n            box.max.x, box.min.y, box.max.z,\n            box.min.x, box.min.y, box.max.z,\n            box.min.x, box.max.y, box.min.z,\n            box.max.x, box.max.y, box.min.z,\n            box.max.x, box.max.y, box.max.z,\n            box.min.x, box.max.y, box.max.z\n        ]);\n        const geometry = new external_three_.BufferGeometry();\n        geometry.setIndex(new external_three_.BufferAttribute(indices, 1));\n        geometry.setAttribute('position', new external_three_.BufferAttribute(positions, 3));\n        const material = new external_three_.LineBasicMaterial({ color: color });\n        super(geometry, material);\n    }\n}\n\n;// CONCATENATED MODULE: ./src/utils/lru.ts\nclass LRUItem {\n    constructor(node) {\n        this.node = node;\n        this.next = null;\n        this.previous = null;\n    }\n}\n/**\n * A doubly-linked-list of the least recently used elements.\n */\nclass LRU {\n    constructor(pointBudget = 1000000) {\n        this.pointBudget = pointBudget;\n        // the least recently used item\n        this.first = null;\n        // the most recently used item\n        this.last = null;\n        this.numPoints = 0;\n        this.items = new Map();\n    }\n    get size() {\n        return this.items.size;\n    }\n    has(node) {\n        return this.items.has(node.id);\n    }\n    /**\n     * Makes the specified the most recently used item. if the list does not contain node, it will\n     * be added.\n     */\n    touch(node) {\n        if (!node.loaded) {\n            return;\n        }\n        const item = this.items.get(node.id);\n        if (item) {\n            this.touchExisting(item);\n        }\n        else {\n            this.addNew(node);\n        }\n    }\n    addNew(node) {\n        const item = new LRUItem(node);\n        item.previous = this.last;\n        this.last = item;\n        if (item.previous) {\n            item.previous.next = item;\n        }\n        if (!this.first) {\n            this.first = item;\n        }\n        this.items.set(node.id, item);\n        this.numPoints += node.numPoints;\n    }\n    touchExisting(item) {\n        if (!item.previous) {\n            // handle touch on first element\n            if (item.next) {\n                this.first = item.next;\n                this.first.previous = null;\n                item.previous = this.last;\n                item.next = null;\n                this.last = item;\n                if (item.previous) {\n                    item.previous.next = item;\n                }\n            }\n        }\n        else if (!item.next) {\n            // handle touch on last element\n        }\n        else {\n            // handle touch on any other element\n            item.previous.next = item.next;\n            item.next.previous = item.previous;\n            item.previous = this.last;\n            item.next = null;\n            this.last = item;\n            if (item.previous) {\n                item.previous.next = item;\n            }\n        }\n    }\n    remove(node) {\n        const item = this.items.get(node.id);\n        if (!item) {\n            return;\n        }\n        if (this.items.size === 1) {\n            this.first = null;\n            this.last = null;\n        }\n        else {\n            if (!item.previous) {\n                this.first = item.next;\n                this.first.previous = null;\n            }\n            if (!item.next) {\n                this.last = item.previous;\n                this.last.next = null;\n            }\n            if (item.previous && item.next) {\n                item.previous.next = item.next;\n                item.next.previous = item.previous;\n            }\n        }\n        this.items.delete(node.id);\n        this.numPoints -= node.numPoints;\n    }\n    getLRUItem() {\n        return this.first ? this.first.node : undefined;\n    }\n    freeMemory() {\n        if (this.items.size <= 1) {\n            return;\n        }\n        while (this.numPoints > this.pointBudget * 2) {\n            const node = this.getLRUItem();\n            if (node) {\n                this.disposeSubtree(node);\n            }\n        }\n    }\n    disposeSubtree(node) {\n        // Collect all the nodes which are to be disposed and removed.\n        const nodesToDispose = [node];\n        node.traverse(n => {\n            if (n.loaded) {\n                nodesToDispose.push(n);\n            }\n        });\n        // Dispose of all the nodes in one go.\n        for (const n of nodesToDispose) {\n            n.dispose();\n            this.remove(n);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./src/potree.ts\n\n\n\n\n\n\n\n\n\n\n\n\nclass QueueItem {\n    constructor(pointCloudIndex, weight, node, parent) {\n        this.pointCloudIndex = pointCloudIndex;\n        this.weight = weight;\n        this.node = node;\n        this.parent = parent;\n    }\n}\nconst GEOMETRY_LOADERS = {\n    v1: loadPOC,\n    v2: loadOctree\n};\nclass Potree {\n    constructor(version = \"v1\") {\n        this._pointBudget = DEFAULT_POINT_BUDGET;\n        this._rendererSize = new external_three_.Vector2();\n        this.maxNumNodesLoading = MAX_NUM_NODES_LOADING;\n        this.features = FEATURES;\n        this.lru = new LRU(this._pointBudget);\n        this.updateVisibilityStructures = (() => {\n            const frustumMatrix = new external_three_.Matrix4();\n            const inverseWorldMatrix = new external_three_.Matrix4();\n            const cameraMatrix = new external_three_.Matrix4();\n            return (pointClouds, camera) => {\n                const frustums = [];\n                const cameraPositions = [];\n                const priorityQueue = new BinaryHeap(x => 1 / x.weight);\n                for (let i = 0; i < pointClouds.length; i++) {\n                    const pointCloud = pointClouds[i];\n                    if (!pointCloud.initialized()) {\n                        continue;\n                    }\n                    pointCloud.numVisiblePoints = 0;\n                    pointCloud.visibleNodes = [];\n                    pointCloud.visibleGeometry = [];\n                    camera.updateMatrixWorld(false);\n                    // Furstum in object space.\n                    const inverseViewMatrix = camera.matrixWorldInverse;\n                    const worldMatrix = pointCloud.matrixWorld;\n                    frustumMatrix\n                        .identity()\n                        .multiply(camera.projectionMatrix)\n                        .multiply(inverseViewMatrix)\n                        .multiply(worldMatrix);\n                    frustums.push(new external_three_.Frustum().setFromProjectionMatrix(frustumMatrix));\n                    // Camera position in object space\n                    inverseWorldMatrix.copy(worldMatrix).invert();\n                    cameraMatrix\n                        .identity()\n                        .multiply(inverseWorldMatrix)\n                        .multiply(camera.matrixWorld);\n                    cameraPositions.push(new external_three_.Vector3().setFromMatrixPosition(cameraMatrix));\n                    if (pointCloud.visible && pointCloud.root !== null) {\n                        const weight = Number.MAX_VALUE;\n                        priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\n                    }\n                    // Hide any previously visible nodes. We will later show only the needed ones.\n                    if (isTreeNode(pointCloud.root)) {\n                        pointCloud.hideDescendants(pointCloud.root.sceneNode);\n                    }\n                    for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\n                        boundingBoxNode.visible = false;\n                    }\n                }\n                return { frustums, cameraPositions, priorityQueue };\n            };\n        })();\n        this.loadGeometry = GEOMETRY_LOADERS[version];\n    }\n    loadPointCloud(url, getUrl, xhrRequest = (input, init) => fetch(input, init)) {\n        return this.loadGeometry(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));\n    }\n    updatePointClouds(pointClouds, camera, renderer) {\n        const result = this.updateVisibility(pointClouds, camera, renderer);\n        for (let i = 0; i < pointClouds.length; i++) {\n            const pointCloud = pointClouds[i];\n            if (pointCloud.disposed) {\n                continue;\n            }\n            pointCloud.material.updateMaterial(pointCloud, pointCloud.visibleNodes, camera, renderer);\n            pointCloud.updateVisibleBounds();\n            pointCloud.updateBoundingBoxes();\n        }\n        this.lru.freeMemory();\n        return result;\n    }\n    static pick(pointClouds, renderer, camera, ray, params = {}) {\n        Potree.picker = Potree.picker || new PointCloudOctreePicker();\n        return Potree.picker.pick(renderer, camera, ray, pointClouds, params);\n    }\n    get pointBudget() {\n        return this._pointBudget;\n    }\n    set pointBudget(value) {\n        if (value !== this._pointBudget) {\n            this._pointBudget = value;\n            this.lru.pointBudget = value;\n            this.lru.freeMemory();\n        }\n    }\n    static set maxLoaderWorkers(value) {\n        BinaryLoader.WORKER_POOL.maxWorkers = value;\n    }\n    static get maxLoaderWorkers() {\n        return BinaryLoader.WORKER_POOL.maxWorkers;\n    }\n    updateVisibility(pointClouds, camera, renderer) {\n        let numVisiblePoints = 0;\n        const visibleNodes = [];\n        const unloadedGeometry = [];\n        // calculate object space frustum and cam pos and setup priority queue\n        const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(pointClouds, camera);\n        let loadedToGPUThisFrame = 0;\n        let exceededMaxLoadsToGPU = false;\n        let nodeLoadFailed = false;\n        let queueItem;\n        while ((queueItem = priorityQueue.pop()) !== undefined) {\n            let node = queueItem.node;\n            // If we will end up with too many points, we stop right away.\n            if (numVisiblePoints + node.numPoints > this.pointBudget) {\n                break;\n            }\n            const pointCloudIndex = queueItem.pointCloudIndex;\n            const pointCloud = pointClouds[pointCloudIndex];\n            const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\n            if (node.level > maxLevel ||\n                !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\n                this.shouldClip(pointCloud, node.boundingBox)) {\n                continue;\n            }\n            numVisiblePoints += node.numPoints;\n            pointCloud.numVisiblePoints += node.numPoints;\n            const parentNode = queueItem.parent;\n            if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\n                if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\n                    node = pointCloud.toTreeNode(node, parentNode);\n                    loadedToGPUThisFrame++;\n                }\n                else if (!node.failed) {\n                    if (node.loaded && loadedToGPUThisFrame >= MAX_LOADS_TO_GPU) {\n                        exceededMaxLoadsToGPU = true;\n                    }\n                    unloadedGeometry.push(node);\n                    pointCloud.visibleGeometry.push(node);\n                }\n                else {\n                    nodeLoadFailed = true;\n                    continue;\n                }\n            }\n            if (isTreeNode(node)) {\n                this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\n                pointCloud.visibleGeometry.push(node.geometryNode);\n            }\n            const halfHeight = 0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\n            this.updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPositions[pointCloudIndex], camera, halfHeight);\n        } // end priority queue loop\n        const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\n        const nodeLoadPromises = [];\n        for (let i = 0; i < numNodesToLoad; i++) {\n            nodeLoadPromises.push(unloadedGeometry[i].load());\n        }\n        return {\n            visibleNodes: visibleNodes,\n            numVisiblePoints: numVisiblePoints,\n            exceededMaxLoadsToGPU: exceededMaxLoadsToGPU,\n            nodeLoadFailed: nodeLoadFailed,\n            nodeLoadPromises: nodeLoadPromises,\n        };\n    }\n    updateTreeNodeVisibility(pointCloud, node, visibleNodes) {\n        this.lru.touch(node.geometryNode);\n        const sceneNode = node.sceneNode;\n        sceneNode.visible = true;\n        sceneNode.material = pointCloud.material;\n        sceneNode.updateMatrix();\n        sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\n        visibleNodes.push(node);\n        pointCloud.visibleNodes.push(node);\n        this.updateBoundingBoxVisibility(pointCloud, node);\n    }\n    updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPosition, camera, halfHeight) {\n        const children = node.children;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            if (child === null) {\n                continue;\n            }\n            const sphere = child.boundingSphere;\n            const distance = sphere.center.distanceTo(cameraPosition);\n            const radius = sphere.radius;\n            let projectionFactor = 0.0;\n            if (camera.type === PERSPECTIVE_CAMERA) {\n                const perspective = camera;\n                const fov = (perspective.fov * Math.PI) / 180.0;\n                const slope = Math.tan(fov / 2.0);\n                projectionFactor = halfHeight / (slope * distance);\n            }\n            else {\n                const orthographic = camera;\n                projectionFactor = (2 * halfHeight) / (orthographic.top - orthographic.bottom);\n            }\n            const screenPixelRadius = radius * projectionFactor;\n            // Don't add the node if it'll be too small on the screen.\n            if (screenPixelRadius < pointCloud.minNodePixelSize) {\n                continue;\n            }\n            // Nodes which are larger will have priority in loading/displaying.\n            const weight = distance < radius ? Number.MAX_VALUE : screenPixelRadius + 1 / distance;\n            priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\n        }\n    }\n    updateBoundingBoxVisibility(pointCloud, node) {\n        if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\n            const boxHelper = new Box3Helper(node.boundingBox);\n            boxHelper.matrixAutoUpdate = false;\n            pointCloud.boundingBoxNodes.push(boxHelper);\n            node.boundingBoxNode = boxHelper;\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n        }\n        else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\n            node.boundingBoxNode.visible = true;\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\n        }\n        else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\n            node.boundingBoxNode.visible = false;\n        }\n    }\n    shouldClip(pointCloud, boundingBox) {\n        const material = pointCloud.material;\n        if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\n            return false;\n        }\n        const box2 = boundingBox.clone();\n        pointCloud.updateMatrixWorld(true);\n        box2.applyMatrix4(pointCloud.matrixWorld);\n        const clipBoxes = material.clipBoxes;\n        for (let i = 0; i < clipBoxes.length; i++) {\n            const clipMatrixWorld = clipBoxes[i].matrix;\n            const clipBoxWorld = new external_three_.Box3(new external_three_.Vector3(-0.5, -0.5, -0.5), new external_three_.Vector3(0.5, 0.5, 0.5)).applyMatrix4(clipMatrixWorld);\n            if (box2.intersectsBox(clipBoxWorld)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n;// CONCATENATED MODULE: ./src/loading2/index.ts\n\n\n;// CONCATENATED MODULE: ./src/index.ts\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0RBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hIQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbFFBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvYmx1ci1tYXRlcmlhbC50cz81NzM5Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvY2xpcHBpbmcudHM/MWY5NiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2VudW1zLnRzPzk2NDIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2NvbnN0YW50cy50cz9jM2I0Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy91dGlscy50cz81NjIyIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvY2xhc3NpZmljYXRpb24udHM/ZmEzYyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2dyYWRpZW50cy9ncmF5c2NhbGUudHM/OTJkOCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2dyYWRpZW50cy9pbmZlcm5vLnRzPzkwMzMiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvcGxhc21hLnRzP2NlYmYiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvcmFpbmJvdy50cz9iMTJhIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3NwZWN0cmFsLnRzP2IwYTIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvdmlkcmlzLnRzPzdjZmQiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMveWVsbG93LWdyZWVuLnRzP2QyMDciLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvaW5kZXgudHM/MmM4ZSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL3RleHR1cmUtZ2VuZXJhdGlvbi50cz8xZWU3Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvcG9pbnQtY2xvdWQtbWF0ZXJpYWwudHM/OTU0MCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2luZGV4LnRzPzkwMjkiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWF0dHJpYnV0ZXMudHM/ZTAzMiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdXRpbHMvYm91bmRzLnRzP2Q1MGUiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeS1ub2RlLnRzPzE4ZWEiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeS50cz85ZjgwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtbm9kZS50cz9kYTE3Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9tYXRoLnRzPzYxZjgiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLW9jdHJlZS1waWNrZXIudHM/MWUzYyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvb2N0cmVlLWdlb21ldHJ5LnRzPzJhNTUiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLXRyZWUudHM/MTU0YyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvcG9pbnQtY2xvdWQtb2N0cmVlLnRzPzM5Y2EiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2ZlYXR1cmVzLnRzPzI4YzAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2FzeW5jLWJsb2NraW5nLXF1ZXVlLnRzPzNiMzMiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL3dvcmtlci1wb29sLnRzPzM2YmYiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3ZlcnNpb24udHM/MTAyOSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZy9iaW5hcnktbG9hZGVyLnRzP2NkMzQiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcvbG9hZC1wb2MudHM/M2Q2MiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZy9pbmRleC50cz8xYTRiIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi9vY3RyZWUtZ2VvbWV0cnktbm9kZS50cz8zOWMwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi9wb2ludC1hdHRyaWJ1dGVzLnRzP2RjZTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL3dvcmtlci1wb29sLnRzPzBmYWYiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL3V0aWxzLnRzP2JjZTEiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL29jdHJlZS1sb2FkZXIudHM/ZjY5MCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvbG9hZC1vY3RyZWUudHM/NDMxMCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdHlwZS1wcmVkaWNhdGVzLnRzPzMxNDMiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2JpbmFyeS1oZWFwLmpzPzI0NTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2JveDMtaGVscGVyLnRzPzcxYTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2xydS50cz84ZTBlIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb3RyZWUudHM/OWQ5NyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvaW5kZXgudHM/MGVlYSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvaW5kZXgudHM/ZTk0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTaGFkZXJNYXRlcmlhbCB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjbGFzcyBCbHVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2JsdXIudmVydCcpO1xuICAgICAgICB0aGlzLmZyYWdtZW50U2hhZGVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2JsdXIuZnJhZycpO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgICAgc2NyZWVuV2lkdGg6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMCB9LFxuICAgICAgICAgICAgc2NyZWVuSGVpZ2h0OiB7IHR5cGU6ICdmJywgdmFsdWU6IDAgfSxcbiAgICAgICAgICAgIG1hcDogeyB0eXBlOiAndCcsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiZXhwb3J0IHZhciBDbGlwTW9kZTtcbihmdW5jdGlvbiAoQ2xpcE1vZGUpIHtcbiAgICBDbGlwTW9kZVtDbGlwTW9kZVtcIkRJU0FCTEVEXCJdID0gMF0gPSBcIkRJU0FCTEVEXCI7XG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX09VVFNJREVcIl0gPSAxXSA9IFwiQ0xJUF9PVVRTSURFXCI7XG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJISUdITElHSFRfSU5TSURFXCJdID0gMl0gPSBcIkhJR0hMSUdIVF9JTlNJREVcIjtcbiAgICBDbGlwTW9kZVtDbGlwTW9kZVtcIkNMSVBfSE9SSVpPTlRBTExZXCJdID0gM10gPSBcIkNMSVBfSE9SSVpPTlRBTExZXCI7XG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX1ZFUlRJQ0FMTFlcIl0gPSA0XSA9IFwiQ0xJUF9WRVJUSUNBTExZXCI7XG59KShDbGlwTW9kZSB8fCAoQ2xpcE1vZGUgPSB7fSkpO1xuIiwiZXhwb3J0IHZhciBQb2ludFNpemVUeXBlO1xuKGZ1bmN0aW9uIChQb2ludFNpemVUeXBlKSB7XG4gICAgUG9pbnRTaXplVHlwZVtQb2ludFNpemVUeXBlW1wiRklYRURcIl0gPSAwXSA9IFwiRklYRURcIjtcbiAgICBQb2ludFNpemVUeXBlW1BvaW50U2l6ZVR5cGVbXCJBVFRFTlVBVEVEXCJdID0gMV0gPSBcIkFUVEVOVUFURURcIjtcbiAgICBQb2ludFNpemVUeXBlW1BvaW50U2l6ZVR5cGVbXCJBREFQVElWRVwiXSA9IDJdID0gXCJBREFQVElWRVwiO1xufSkoUG9pbnRTaXplVHlwZSB8fCAoUG9pbnRTaXplVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFBvaW50U2hhcGU7XG4oZnVuY3Rpb24gKFBvaW50U2hhcGUpIHtcbiAgICBQb2ludFNoYXBlW1BvaW50U2hhcGVbXCJTUVVBUkVcIl0gPSAwXSA9IFwiU1FVQVJFXCI7XG4gICAgUG9pbnRTaGFwZVtQb2ludFNoYXBlW1wiQ0lSQ0xFXCJdID0gMV0gPSBcIkNJUkNMRVwiO1xuICAgIFBvaW50U2hhcGVbUG9pbnRTaGFwZVtcIlBBUkFCT0xPSURcIl0gPSAyXSA9IFwiUEFSQUJPTE9JRFwiO1xufSkoUG9pbnRTaGFwZSB8fCAoUG9pbnRTaGFwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFRyZWVUeXBlO1xuKGZ1bmN0aW9uIChUcmVlVHlwZSkge1xuICAgIFRyZWVUeXBlW1RyZWVUeXBlW1wiT0NUUkVFXCJdID0gMF0gPSBcIk9DVFJFRVwiO1xuICAgIFRyZWVUeXBlW1RyZWVUeXBlW1wiS0RUUkVFXCJdID0gMV0gPSBcIktEVFJFRVwiO1xufSkoVHJlZVR5cGUgfHwgKFRyZWVUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgUG9pbnRPcGFjaXR5VHlwZTtcbihmdW5jdGlvbiAoUG9pbnRPcGFjaXR5VHlwZSkge1xuICAgIFBvaW50T3BhY2l0eVR5cGVbUG9pbnRPcGFjaXR5VHlwZVtcIkZJWEVEXCJdID0gMF0gPSBcIkZJWEVEXCI7XG4gICAgUG9pbnRPcGFjaXR5VHlwZVtQb2ludE9wYWNpdHlUeXBlW1wiQVRURU5VQVRFRFwiXSA9IDFdID0gXCJBVFRFTlVBVEVEXCI7XG59KShQb2ludE9wYWNpdHlUeXBlIHx8IChQb2ludE9wYWNpdHlUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgUG9pbnRDb2xvclR5cGU7XG4oZnVuY3Rpb24gKFBvaW50Q29sb3JUeXBlKSB7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJSR0JcIl0gPSAwXSA9IFwiUkdCXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJDT0xPUlwiXSA9IDFdID0gXCJDT0xPUlwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiREVQVEhcIl0gPSAyXSA9IFwiREVQVEhcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkhFSUdIVFwiXSA9IDNdID0gXCJIRUlHSFRcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkVMRVZBVElPTlwiXSA9IDNdID0gXCJFTEVWQVRJT05cIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIklOVEVOU0lUWVwiXSA9IDRdID0gXCJJTlRFTlNJVFlcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIklOVEVOU0lUWV9HUkFESUVOVFwiXSA9IDVdID0gXCJJTlRFTlNJVFlfR1JBRElFTlRcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkxPRFwiXSA9IDZdID0gXCJMT0RcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkxFVkVMX09GX0RFVEFJTFwiXSA9IDZdID0gXCJMRVZFTF9PRl9ERVRBSUxcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIlBPSU5UX0lOREVYXCJdID0gN10gPSBcIlBPSU5UX0lOREVYXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJDTEFTU0lGSUNBVElPTlwiXSA9IDhdID0gXCJDTEFTU0lGSUNBVElPTlwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiUkVUVVJOX05VTUJFUlwiXSA9IDldID0gXCJSRVRVUk5fTlVNQkVSXCI7XG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJTT1VSQ0VcIl0gPSAxMF0gPSBcIlNPVVJDRVwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiTk9STUFMXCJdID0gMTFdID0gXCJOT1JNQUxcIjtcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIlBIT05HXCJdID0gMTJdID0gXCJQSE9OR1wiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiUkdCX0hFSUdIVFwiXSA9IDEzXSA9IFwiUkdCX0hFSUdIVFwiO1xuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiQ09NUE9TSVRFXCJdID0gNTBdID0gXCJDT01QT1NJVEVcIjtcbn0pKFBvaW50Q29sb3JUeXBlIHx8IChQb2ludENvbG9yVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIE5vcm1hbEZpbHRlcmluZ01vZGU7XG4oZnVuY3Rpb24gKE5vcm1hbEZpbHRlcmluZ01vZGUpIHtcbiAgICBOb3JtYWxGaWx0ZXJpbmdNb2RlW05vcm1hbEZpbHRlcmluZ01vZGVbXCJBQlNPTFVURV9OT1JNQUxfRklMVEVSSU5HX01PREVcIl0gPSAxXSA9IFwiQUJTT0xVVEVfTk9STUFMX0ZJTFRFUklOR19NT0RFXCI7XG4gICAgTm9ybWFsRmlsdGVyaW5nTW9kZVtOb3JtYWxGaWx0ZXJpbmdNb2RlW1wiTEVTU19FUVVBTF9OT1JNQUxfRklMVEVSSU5HX01PREVcIl0gPSAyXSA9IFwiTEVTU19FUVVBTF9OT1JNQUxfRklMVEVSSU5HX01PREVcIjtcbiAgICBOb3JtYWxGaWx0ZXJpbmdNb2RlW05vcm1hbEZpbHRlcmluZ01vZGVbXCJHUkVBVEVSX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiXSA9IDNdID0gXCJHUkVBVEVSX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiO1xufSkoTm9ybWFsRmlsdGVyaW5nTW9kZSB8fCAoTm9ybWFsRmlsdGVyaW5nTW9kZSA9IHt9KSk7XG5leHBvcnQgdmFyIFBvaW50Q2xvdWRNaXhpbmdNb2RlO1xuKGZ1bmN0aW9uIChQb2ludENsb3VkTWl4aW5nTW9kZSkge1xuICAgIFBvaW50Q2xvdWRNaXhpbmdNb2RlW1BvaW50Q2xvdWRNaXhpbmdNb2RlW1wiQ0hFQ0tCT0FSRFwiXSA9IDFdID0gXCJDSEVDS0JPQVJEXCI7XG4gICAgUG9pbnRDbG91ZE1peGluZ01vZGVbUG9pbnRDbG91ZE1peGluZ01vZGVbXCJTVFJJUEVTXCJdID0gMl0gPSBcIlNUUklQRVNcIjtcbn0pKFBvaW50Q2xvdWRNaXhpbmdNb2RlIHx8IChQb2ludENsb3VkTWl4aW5nTW9kZSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBDb2xvciwgVmVjdG9yNCB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JHQl9CUklHSFRORVNTID0gMDtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JHQl9DT05UUkFTVCA9IDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9SR0JfR0FNTUEgPSAxO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUFYX1BPSU5UX1NJWkUgPSA1MDtcbmV4cG9ydCBjb25zdCBERUZBVUxUX01JTl9OT0RFX1BJWEVMX1NJWkUgPSA1MDtcbmV4cG9ydCBjb25zdCBERUZBVUxUX01JTl9QT0lOVF9TSVpFID0gMjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BJQ0tfV0lORE9XX1NJWkUgPSAxNTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPSU5UX0JVREdFVCA9IDEwMDAwMDA7XG5leHBvcnQgY29uc3QgTUFYX0xPQURTX1RPX0dQVSA9IDI7XG5leHBvcnQgY29uc3QgTUFYX05VTV9OT0RFU19MT0FESU5HID0gNDtcbmV4cG9ydCBjb25zdCBQRVJTUEVDVElWRV9DQU1FUkEgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuZXhwb3J0IGNvbnN0IENPTE9SX0JMQUNLID0gbmV3IENvbG9yKDAsIDAsIDApO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfSElHSExJR0hUX0NPTE9SID0gbmV3IFZlY3RvcjQoMSwgMCwgMCwgMSk7XG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KG5hbWUuY2hhckF0KG5hbWUubGVuZ3RoIC0gMSksIDEwKTtcbn1cbi8qKlxuICogV2hlbiBwYXNzZWQgdG8gYFtdLnNvcnRgLCBzb3J0cyB0aGUgYXJyYXkgYnkgbGV2ZWwgYW5kIGluZGV4OiByLCByMCwgcjMsIHI0LCByMDEsIHIwNywgcjMwLCAuLi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5TGV2ZWxBbmRJbmRleChhLCBiKSB7XG4gICAgY29uc3QgbmEgPSBhLm5hbWU7XG4gICAgY29uc3QgbmIgPSBiLm5hbWU7XG4gICAgaWYgKG5hLmxlbmd0aCAhPT0gbmIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuYS5sZW5ndGggLSBuYi5sZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5hIDwgbmIpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYSA+IG5iKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzcG9uc2UpIHtcbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVFbXB0eUJ1ZmZlcihidWZmZXIpIHtcbiAgICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBFcnJvcignRW1wdHkgYnVmZmVyJyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG4iLCJpbXBvcnQgeyBWZWN0b3I0IH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ0xBU1NJRklDQVRJT04gPSB7XG4gICAgMDogbmV3IFZlY3RvcjQoMC41LCAwLjUsIDAuNSwgMS4wKSxcbiAgICAxOiBuZXcgVmVjdG9yNCgwLjUsIDAuNSwgMC41LCAxLjApLFxuICAgIDI6IG5ldyBWZWN0b3I0KDAuNjMsIDAuMzIsIDAuMTgsIDEuMCksXG4gICAgMzogbmV3IFZlY3RvcjQoMC4wLCAxLjAsIDAuMCwgMS4wKSxcbiAgICA0OiBuZXcgVmVjdG9yNCgwLjAsIDAuOCwgMC4wLCAxLjApLFxuICAgIDU6IG5ldyBWZWN0b3I0KDAuMCwgMC42LCAwLjAsIDEuMCksXG4gICAgNjogbmV3IFZlY3RvcjQoMS4wLCAwLjY2LCAwLjAsIDEuMCksXG4gICAgNzogbmV3IFZlY3RvcjQoMS4wLCAwLCAxLjAsIDEuMCksXG4gICAgODogbmV3IFZlY3RvcjQoMS4wLCAwLCAwLjAsIDEuMCksXG4gICAgOTogbmV3IFZlY3RvcjQoMC4wLCAwLjAsIDEuMCwgMS4wKSxcbiAgICAxMjogbmV3IFZlY3RvcjQoMS4wLCAxLjAsIDAuMCwgMS4wKSxcbiAgICBERUZBVUxUOiBuZXcgVmVjdG9yNCgwLjMsIDAuNiwgMC42LCAwLjUpLFxufTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNvbnN0IEdSQVlTQ0FMRSA9IFtcbiAgICBbMCwgbmV3IENvbG9yKDAsIDAsIDApXSxcbiAgICBbMSwgbmV3IENvbG9yKDEsIDEsIDEpXSxcbl07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBJTkZFUk5PID0gW1xuICAgIFswLjAsIG5ldyBDb2xvcigwLjA3NywgMC4wNDIsIDAuMjA2KV0sXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMjI1LCAwLjAzNiwgMC4zODgpXSxcbiAgICBbMC4yLCBuZXcgQ29sb3IoMC4zNzMsIDAuMDc0LCAwLjQzMildLFxuICAgIFswLjMsIG5ldyBDb2xvcigwLjUyMiwgMC4xMjgsIDAuNDIpXSxcbiAgICBbMC40LCBuZXcgQ29sb3IoMC42NjUsIDAuMTgyLCAwLjM3KV0sXG4gICAgWzAuNSwgbmV3IENvbG9yKDAuNzk3LCAwLjI1NSwgMC4yODcpXSxcbiAgICBbMC42LCBuZXcgQ29sb3IoMC45MDIsIDAuMzY0LCAwLjE4NCldLFxuICAgIFswLjcsIG5ldyBDb2xvcigwLjk2OSwgMC41MTYsIDAuMDYzKV0sXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuOTg4LCAwLjY4MywgMC4wNzIpXSxcbiAgICBbMC45LCBuZXcgQ29sb3IoMC45NjEsIDAuODU5LCAwLjI5OCldLFxuICAgIFsxLjAsIG5ldyBDb2xvcigwLjk4OCwgMC45OTgsIDAuNjQ1KV0sXG5dO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgUExBU01BID0gW1xuICAgIFswLjAsIG5ldyBDb2xvcigwLjI0MSwgMC4wMTUsIDAuNjEpXSxcbiAgICBbMC4xLCBuZXcgQ29sb3IoMC4zODcsIDAuMDAxLCAwLjY1NCldLFxuICAgIFswLjIsIG5ldyBDb2xvcigwLjUyNCwgMC4wMjUsIDAuNjUzKV0sXG4gICAgWzAuMywgbmV3IENvbG9yKDAuNjUxLCAwLjEyNSwgMC41OTYpXSxcbiAgICBbMC40LCBuZXcgQ29sb3IoMC43NTIsIDAuMjI3LCAwLjUxMyldLFxuICAgIFswLjUsIG5ldyBDb2xvcigwLjgzNywgMC4zMjksIDAuNDMxKV0sXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuOTA3LCAwLjQzNSwgMC4zNTMpXSxcbiAgICBbMC43LCBuZXcgQ29sb3IoMC45NjMsIDAuNTU0LCAwLjI3MildLFxuICAgIFswLjgsIG5ldyBDb2xvcigwLjk5MiwgMC42ODEsIDAuMTk1KV0sXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuOTg3LCAwLjgyMiwgMC4xNDQpXSxcbiAgICBbMS4wLCBuZXcgQ29sb3IoMC45NCwgMC45NzUsIDAuMTMxKV0sXG5dO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY29uc3QgUkFJTkJPVyA9IFtcbiAgICBbMCwgbmV3IENvbG9yKDAuMjc4LCAwLCAwLjcxNCldLFxuICAgIFsxIC8gNiwgbmV3IENvbG9yKDAsIDAsIDEpXSxcbiAgICBbMiAvIDYsIG5ldyBDb2xvcigwLCAxLCAxKV0sXG4gICAgWzMgLyA2LCBuZXcgQ29sb3IoMCwgMSwgMCldLFxuICAgIFs0IC8gNiwgbmV3IENvbG9yKDEsIDEsIDApXSxcbiAgICBbNSAvIDYsIG5ldyBDb2xvcigxLCAwLjY0LCAwKV0sXG4gICAgWzEsIG5ldyBDb2xvcigxLCAwLCAwKV0sXG5dO1xuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XG4vLyBGcm9tIGNocm9tYSBzcGVjdHJhbCBodHRwOi8vZ2thLmdpdGh1Yi5pby9jaHJvbWEuanMvXG5leHBvcnQgY29uc3QgU1BFQ1RSQUwgPSBbXG4gICAgWzAsIG5ldyBDb2xvcigwLjM2ODYsIDAuMzA5OCwgMC42MzUzKV0sXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMTk2MSwgMC41MzMzLCAwLjc0MTIpXSxcbiAgICBbMC4yLCBuZXcgQ29sb3IoMC40LCAwLjc2MDgsIDAuNjQ3MSldLFxuICAgIFswLjMsIG5ldyBDb2xvcigwLjY3MDYsIDAuODY2NywgMC42NDMxKV0sXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuOTAyLCAwLjk2MDgsIDAuNTk2MSldLFxuICAgIFswLjUsIG5ldyBDb2xvcigxLjAsIDEuMCwgMC43NDkpXSxcbiAgICBbMC42LCBuZXcgQ29sb3IoMC45OTYxLCAwLjg3ODQsIDAuNTQ1MSldLFxuICAgIFswLjcsIG5ldyBDb2xvcigwLjk5MjIsIDAuNjgyNCwgMC4zODA0KV0sXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuOTU2OSwgMC40Mjc1LCAwLjI2MjcpXSxcbiAgICBbMC45LCBuZXcgQ29sb3IoMC44MzUzLCAwLjI0MzEsIDAuMzA5OCldLFxuICAgIFsxLCBuZXcgQ29sb3IoMC42MTk2LCAwLjAwMzksIDAuMjU4OCldLFxuXTtcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNvbnN0IFZJUklESVMgPSBbXG4gICAgWzAuMCwgbmV3IENvbG9yKDAuMjY3LCAwLjAwNSwgMC4zMjkpXSxcbiAgICBbMC4xLCBuZXcgQ29sb3IoMC4yODMsIDAuMTQxLCAwLjQ1OCldLFxuICAgIFswLjIsIG5ldyBDb2xvcigwLjI1NCwgMC4yNjUsIDAuNTMpXSxcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC4yMDcsIDAuMzcyLCAwLjU1MyldLFxuICAgIFswLjQsIG5ldyBDb2xvcigwLjE2NCwgMC40NzEsIDAuNTU4KV0sXG4gICAgWzAuNSwgbmV3IENvbG9yKDAuMTI4LCAwLjU2NywgMC41NTEpXSxcbiAgICBbMC42LCBuZXcgQ29sb3IoMC4xMzUsIDAuNjU5LCAwLjUxOCldLFxuICAgIFswLjcsIG5ldyBDb2xvcigwLjI2NywgMC43NDksIDAuNDQxKV0sXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuNDc4LCAwLjgyMSwgMC4zMTgpXSxcbiAgICBbMC45LCBuZXcgQ29sb3IoMC43NDEsIDAuODczLCAwLjE1KV0sXG4gICAgWzEuMCwgbmV3IENvbG9yKDAuOTkzLCAwLjkwNiwgMC4xNDQpXSxcbl07XG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjb25zdCBZRUxMT1dfR1JFRU4gPSBbXG4gICAgWzAsIG5ldyBDb2xvcigwLjE2NDcsIDAuMjgyNCwgMC4zNDUxKV0sXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMTMzOCwgMC4zNTU1LCAwLjQyMjcpXSxcbiAgICBbMC4yLCBuZXcgQ29sb3IoMC4wNjEsIDAuNDMxOSwgMC40ODY0KV0sXG4gICAgWzAuMywgbmV3IENvbG9yKDAuMCwgMC41MDk5LCAwLjUzMTkpXSxcbiAgICBbMC40LCBuZXcgQ29sb3IoMC4wLCAwLjU4ODEsIDAuNTU2OSldLFxuICAgIFswLjUsIG5ldyBDb2xvcigwLjEzNywgMC42NjUsIDAuNTYxNCldLFxuICAgIFswLjYsIG5ldyBDb2xvcigwLjI5MDYsIDAuNzM5NSwgMC41NDc3KV0sXG4gICAgWzAuNywgbmV3IENvbG9yKDAuNDQ1MywgMC44MDk5LCAwLjUyMDEpXSxcbiAgICBbMC44LCBuZXcgQ29sb3IoMC42MTAyLCAwLjg3NDgsIDAuNDg1KV0sXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuNzg4MywgMC45MzIzLCAwLjQ1MTQpXSxcbiAgICBbMSwgbmV3IENvbG9yKDAuOTgwNCwgMC45ODA0LCAwLjQzMTQpXSxcbl07XG4iLCJleHBvcnQgKiBmcm9tICcuL2dyYXlzY2FsZSc7XG5leHBvcnQgKiBmcm9tICcuL2luZmVybm8nO1xuZXhwb3J0ICogZnJvbSAnLi9wbGFzbWEnO1xuZXhwb3J0ICogZnJvbSAnLi9yYWluYm93JztcbmV4cG9ydCAqIGZyb20gJy4vc3BlY3RyYWwnO1xuZXhwb3J0ICogZnJvbSAnLi92aWRyaXMnO1xuZXhwb3J0ICogZnJvbSAnLi95ZWxsb3ctZ3JlZW4nO1xuIiwiaW1wb3J0IHsgQ2FudmFzVGV4dHVyZSwgRGF0YVRleHR1cmUsIExpbmVhckZpbHRlciwgTmVhcmVzdEZpbHRlciwgUkdCQUZvcm1hdCwgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVEYXRhVGV4dHVyZSh3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgIGNvbnN0IHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHNpemUpO1xuICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKGNvbG9yLnIgKiAyNTUpO1xuICAgIGNvbnN0IGcgPSBNYXRoLmZsb29yKGNvbG9yLmcgKiAyNTUpO1xuICAgIGNvbnN0IGIgPSBNYXRoLmZsb29yKGNvbG9yLmIgKiAyNTUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGRhdGFbaSAqIDNdID0gcjtcbiAgICAgICAgZGF0YVtpICogMyArIDFdID0gZztcbiAgICAgICAgZGF0YVtpICogMyArIDJdID0gYjtcbiAgICB9XG4gICAgY29uc3QgdGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBSR0JBRm9ybWF0KTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUoZ3JhZGllbnQpIHtcbiAgICBjb25zdCBzaXplID0gNjQ7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gc2l6ZTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgY29udGV4dC5yZWN0KDAsIDAsIHNpemUsIHNpemUpO1xuICAgIGNvbnN0IGN0eEdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBzaXplLCBzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyYWRpZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBncmFkaWVudFtpXTtcbiAgICAgICAgY3R4R3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0ZXBbMF0sIGAjJHtzdGVwWzFdLmdldEhleFN0cmluZygpfWApO1xuICAgIH1cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eEdyYWRpZW50O1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgQ2FudmFzVGV4dHVyZShjYW52YXMpO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xuICAgIC8vIHRleHR1cmVJbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG4gICAgcmV0dXJuIHRleHR1cmU7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDbGFzc2lmaWNhdGlvblRleHR1cmUoY2xhc3NpZmljYXRpb24pIHtcbiAgICBjb25zdCB3aWR0aCA9IDI1NjtcbiAgICBjb25zdCBoZWlnaHQgPSAyNTY7XG4gICAgY29uc3Qgc2l6ZSA9IHdpZHRoICogaGVpZ2h0O1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSg0ICogc2l6ZSk7XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB4ICsgd2lkdGggKiB5O1xuICAgICAgICAgICAgbGV0IGNvbG9yO1xuICAgICAgICAgICAgaWYgKGNsYXNzaWZpY2F0aW9uW3hdKSB7XG4gICAgICAgICAgICAgICAgY29sb3IgPSBjbGFzc2lmaWNhdGlvblt4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsYXNzaWZpY2F0aW9uW3ggJSAzMl0pIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYXNzaWZpY2F0aW9uW3ggJSAzMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYXNzaWZpY2F0aW9uLkRFRkFVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhWzQgKiBpICsgMF0gPSAyNTUgKiBjb2xvci54O1xuICAgICAgICAgICAgZGF0YVs0ICogaSArIDFdID0gMjU1ICogY29sb3IueTtcbiAgICAgICAgICAgIGRhdGFbNCAqIGkgKyAyXSA9IDI1NSAqIGNvbG9yLno7XG4gICAgICAgICAgICBkYXRhWzQgKiBpICsgM10gPSAyNTUgKiBjb2xvci53O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSBuZXcgRGF0YVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgUkdCQUZvcm1hdCk7XG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuIiwidmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuaW1wb3J0IHsgQWRkaXRpdmVCbGVuZGluZywgQ29sb3IsIExlc3NFcXVhbERlcHRoLCBOZWFyZXN0RmlsdGVyLCBOb0JsZW5kaW5nLCBSYXdTaGFkZXJNYXRlcmlhbCwgVGV4dHVyZSwgVmVjdG9yMiwgVmVjdG9yMywgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBERUZBVUxUX0hJR0hMSUdIVF9DT0xPUiwgREVGQVVMVF9NQVhfUE9JTlRfU0laRSwgREVGQVVMVF9NSU5fUE9JTlRfU0laRSwgREVGQVVMVF9SR0JfQlJJR0hUTkVTUywgREVGQVVMVF9SR0JfQ09OVFJBU1QsIERFRkFVTFRfUkdCX0dBTU1BLCBQRVJTUEVDVElWRV9DQU1FUkEsIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGJ5TGV2ZWxBbmRJbmRleCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IERFRkFVTFRfQ0xBU1NJRklDQVRJT04gfSBmcm9tICcuL2NsYXNzaWZpY2F0aW9uJztcbmltcG9ydCB7IENsaXBNb2RlIH0gZnJvbSAnLi9jbGlwcGluZyc7XG5pbXBvcnQgeyBOb3JtYWxGaWx0ZXJpbmdNb2RlLCBQb2ludENsb3VkTWl4aW5nTW9kZSwgUG9pbnRDb2xvclR5cGUsIFBvaW50T3BhY2l0eVR5cGUsIFBvaW50U2hhcGUsIFBvaW50U2l6ZVR5cGUsIFRyZWVUeXBlLCB9IGZyb20gJy4vZW51bXMnO1xuaW1wb3J0IHsgU1BFQ1RSQUwgfSBmcm9tICcuL2dyYWRpZW50cyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUNsYXNzaWZpY2F0aW9uVGV4dHVyZSwgZ2VuZXJhdGVEYXRhVGV4dHVyZSwgZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUsIH0gZnJvbSAnLi90ZXh0dXJlLWdlbmVyYXRpb24nO1xuY29uc3QgVFJFRV9UWVBFX0RFRlMgPSB7XG4gICAgW1RyZWVUeXBlLk9DVFJFRV06ICd0cmVlX3R5cGVfb2N0cmVlJyxcbiAgICBbVHJlZVR5cGUuS0RUUkVFXTogJ3RyZWVfdHlwZV9rZHRyZWUnLFxufTtcbmNvbnN0IFNJWkVfVFlQRV9ERUZTID0ge1xuICAgIFtQb2ludFNpemVUeXBlLkZJWEVEXTogJ2ZpeGVkX3BvaW50X3NpemUnLFxuICAgIFtQb2ludFNpemVUeXBlLkFUVEVOVUFURURdOiAnYXR0ZW51YXRlZF9wb2ludF9zaXplJyxcbiAgICBbUG9pbnRTaXplVHlwZS5BREFQVElWRV06ICdhZGFwdGl2ZV9wb2ludF9zaXplJyxcbn07XG5jb25zdCBPUEFDSVRZX0RFRlMgPSB7XG4gICAgW1BvaW50T3BhY2l0eVR5cGUuQVRURU5VQVRFRF06ICdhdHRlbnVhdGVkX29wYWNpdHknLFxuICAgIFtQb2ludE9wYWNpdHlUeXBlLkZJWEVEXTogJ2ZpeGVkX29wYWNpdHknLFxufTtcbmNvbnN0IFNIQVBFX0RFRlMgPSB7XG4gICAgW1BvaW50U2hhcGUuU1FVQVJFXTogJ3NxdWFyZV9wb2ludF9zaGFwZScsXG4gICAgW1BvaW50U2hhcGUuQ0lSQ0xFXTogJ2NpcmNsZV9wb2ludF9zaGFwZScsXG4gICAgW1BvaW50U2hhcGUuUEFSQUJPTE9JRF06ICdwYXJhYm9sb2lkX3BvaW50X3NoYXBlJyxcbn07XG5jb25zdCBDT0xPUl9ERUZTID0ge1xuICAgIFtQb2ludENvbG9yVHlwZS5SR0JdOiAnY29sb3JfdHlwZV9yZ2InLFxuICAgIFtQb2ludENvbG9yVHlwZS5DT0xPUl06ICdjb2xvcl90eXBlX2NvbG9yJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuREVQVEhdOiAnY29sb3JfdHlwZV9kZXB0aCcsXG4gICAgW1BvaW50Q29sb3JUeXBlLkhFSUdIVF06ICdjb2xvcl90eXBlX2hlaWdodCcsXG4gICAgW1BvaW50Q29sb3JUeXBlLklOVEVOU0lUWV06ICdjb2xvcl90eXBlX2ludGVuc2l0eScsXG4gICAgW1BvaW50Q29sb3JUeXBlLklOVEVOU0lUWV9HUkFESUVOVF06ICdjb2xvcl90eXBlX2ludGVuc2l0eV9ncmFkaWVudCcsXG4gICAgW1BvaW50Q29sb3JUeXBlLkxPRF06ICdjb2xvcl90eXBlX2xvZCcsXG4gICAgW1BvaW50Q29sb3JUeXBlLlBPSU5UX0lOREVYXTogJ2NvbG9yX3R5cGVfcG9pbnRfaW5kZXgnLFxuICAgIFtQb2ludENvbG9yVHlwZS5DTEFTU0lGSUNBVElPTl06ICdjb2xvcl90eXBlX2NsYXNzaWZpY2F0aW9uJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuUkVUVVJOX05VTUJFUl06ICdjb2xvcl90eXBlX3JldHVybl9udW1iZXInLFxuICAgIFtQb2ludENvbG9yVHlwZS5TT1VSQ0VdOiAnY29sb3JfdHlwZV9zb3VyY2UnLFxuICAgIFtQb2ludENvbG9yVHlwZS5OT1JNQUxdOiAnY29sb3JfdHlwZV9ub3JtYWwnLFxuICAgIFtQb2ludENvbG9yVHlwZS5QSE9OR106ICdjb2xvcl90eXBlX3Bob25nJyxcbiAgICBbUG9pbnRDb2xvclR5cGUuUkdCX0hFSUdIVF06ICdjb2xvcl90eXBlX3JnYl9oZWlnaHQnLFxuICAgIFtQb2ludENvbG9yVHlwZS5DT01QT1NJVEVdOiAnY29sb3JfdHlwZV9jb21wb3NpdGUnLFxufTtcbmNvbnN0IENMSVBfTU9ERV9ERUZTID0ge1xuICAgIFtDbGlwTW9kZS5ESVNBQkxFRF06ICdjbGlwX2Rpc2FibGVkJyxcbiAgICBbQ2xpcE1vZGUuQ0xJUF9PVVRTSURFXTogJ2NsaXBfb3V0c2lkZScsXG4gICAgW0NsaXBNb2RlLkhJR0hMSUdIVF9JTlNJREVdOiAnY2xpcF9oaWdobGlnaHRfaW5zaWRlJyxcbiAgICBbQ2xpcE1vZGUuQ0xJUF9IT1JJWk9OVEFMTFldOiAnY2xpcF9ob3Jpem9udGFsbHknLFxuICAgIFtDbGlwTW9kZS5DTElQX1ZFUlRJQ0FMTFldOiAnY2xpcF92ZXJ0aWNhbGx5Jyxcbn07XG5leHBvcnQgY2xhc3MgUG9pbnRDbG91ZE1hdGVyaWFsIGV4dGVuZHMgUmF3U2hhZGVyTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIHRoZSBkcmF3aW5nIGJ1ZmZlciBzaXplIGluc3RlYWQgb2YgdGhlIGRvbSBjbGllbnQgd2lkdGggYW5kIGhlaWdodCB3aGVuIHBhc3NpbmcgdGhlIHNjcmVlbiBoZWlnaHQgYW5kIHNjcmVlbiB3aWR0aCB1bmlmb3JtcyB0byB0aGVcbiAgICAgICAgICogc2hhZGVyLiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgaGF2ZSBvZmZzY3JlZW4gY2FudmFzZXMgKHdoaWNoIGluIHNvbWUgYnJvd3NlcnMgcmV0dXJuIDAgYXMgY2xpZW50IHdpZHRoIGFuZCBjbGllbnQgaGVpZ2h0KS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlRHJhd2luZ0J1ZmZlclNpemUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5saWdodHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb2cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb2xvclJnYmEgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5udW1DbGlwQm94ZXMgPSAwO1xuICAgICAgICB0aGlzLmNsaXBCb3hlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlVGV4dHVyZU9mZnNldHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2dyYWRpZW50ID0gU1BFQ1RSQUw7XG4gICAgICAgIHRoaXMuZ3JhZGllbnRUZXh0dXJlID0gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUodGhpcy5fZ3JhZGllbnQpO1xuICAgICAgICB0aGlzLl9jbGFzc2lmaWNhdGlvbiA9IERFRkFVTFRfQ0xBU1NJRklDQVRJT047XG4gICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlID0gZ2VuZXJhdGVDbGFzc2lmaWNhdGlvblRleHR1cmUodGhpcy5fY2xhc3NpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xuICAgICAgICAgICAgYmJTaXplOiBtYWtlVW5pZm9ybSgnZnYnLCBbMCwgMCwgMF0pLFxuICAgICAgICAgICAgYmxlbmREZXB0aFN1cHBsZW1lbnQ6IG1ha2VVbmlmb3JtKCdmJywgMC4wKSxcbiAgICAgICAgICAgIGJsZW5kSGFyZG5lc3M6IG1ha2VVbmlmb3JtKCdmJywgMi4wKSxcbiAgICAgICAgICAgIGNsYXNzaWZpY2F0aW9uTFVUOiBtYWtlVW5pZm9ybSgndCcsIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlIHx8IG5ldyBUZXh0dXJlKCkpLFxuICAgICAgICAgICAgY2xpcEJveENvdW50OiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgY2xpcEJveGVzOiBtYWtlVW5pZm9ybSgnTWF0cml4NGZ2JywgW10pLFxuICAgICAgICAgICAgY2xpcEV4dGVudDogbWFrZVVuaWZvcm0oJ2Z2JywgWzAuMCwgMC4wLCAxLjAsIDEuMF0pLFxuICAgICAgICAgICAgZGVwdGhNYXA6IG1ha2VVbmlmb3JtKCd0JywgbnVsbCksXG4gICAgICAgICAgICBkaWZmdXNlOiBtYWtlVW5pZm9ybSgnZnYnLCBbMSwgMSwgMV0pLFxuICAgICAgICAgICAgZm92OiBtYWtlVW5pZm9ybSgnZicsIDEuMCksXG4gICAgICAgICAgICBncmFkaWVudDogbWFrZVVuaWZvcm0oJ3QnLCB0aGlzLmdyYWRpZW50VGV4dHVyZSB8fCBuZXcgVGV4dHVyZSgpKSxcbiAgICAgICAgICAgIGhlaWdodE1heDogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxuICAgICAgICAgICAgaGVpZ2h0TWluOiBtYWtlVW5pZm9ybSgnZicsIDAuMCksXG4gICAgICAgICAgICBpbnRlbnNpdHlCcmlnaHRuZXNzOiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgaW50ZW5zaXR5Q29udHJhc3Q6IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICBpbnRlbnNpdHlHYW1tYTogbWFrZVVuaWZvcm0oJ2YnLCAxKSxcbiAgICAgICAgICAgIGludGVuc2l0eVJhbmdlOiBtYWtlVW5pZm9ybSgnZnYnLCBbMCwgNjUwMDBdKSxcbiAgICAgICAgICAgIGlzTGVhZk5vZGU6IG1ha2VVbmlmb3JtKCdiJywgMCksXG4gICAgICAgICAgICBsZXZlbDogbWFrZVVuaWZvcm0oJ2YnLCAwLjApLFxuICAgICAgICAgICAgbWF4U2l6ZTogbWFrZVVuaWZvcm0oJ2YnLCBERUZBVUxUX01BWF9QT0lOVF9TSVpFKSxcbiAgICAgICAgICAgIG1pblNpemU6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9NSU5fUE9JTlRfU0laRSksXG4gICAgICAgICAgICBvY3RyZWVTaXplOiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgb3BhY2l0eTogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxuICAgICAgICAgICAgcGNJbmRleDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIHJnYkJyaWdodG5lc3M6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9SR0JfQlJJR0hUTkVTUyksXG4gICAgICAgICAgICByZ2JDb250cmFzdDogbWFrZVVuaWZvcm0oJ2YnLCBERUZBVUxUX1JHQl9DT05UUkFTVCksXG4gICAgICAgICAgICByZ2JHYW1tYTogbWFrZVVuaWZvcm0oJ2YnLCBERUZBVUxUX1JHQl9HQU1NQSksXG4gICAgICAgICAgICBzY3JlZW5IZWlnaHQ6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcbiAgICAgICAgICAgIHNjcmVlbldpZHRoOiBtYWtlVW5pZm9ybSgnZicsIDEuMCksXG4gICAgICAgICAgICBzaXplOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxuICAgICAgICAgICAgc3BhY2luZzogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxuICAgICAgICAgICAgdG9Nb2RlbDogbWFrZVVuaWZvcm0oJ01hdHJpeDRmJywgW10pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbjogbWFrZVVuaWZvcm0oJ2YnLCAwLjUpLFxuICAgICAgICAgICAgdUNvbG9yOiBtYWtlVW5pZm9ybSgnYycsIG5ldyBDb2xvcigweGZmZmZmZikpLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdmlzaWJsZU5vZGVzOiBtYWtlVW5pZm9ybSgndCcsIHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZSB8fCBuZXcgVGV4dHVyZSgpKSxcbiAgICAgICAgICAgIHZuU3RhcnQ6IG1ha2VVbmlmb3JtKCdmJywgMC4wKSxcbiAgICAgICAgICAgIHdDbGFzc2lmaWNhdGlvbjogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIHdFbGV2YXRpb246IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICB3SW50ZW5zaXR5OiBtYWtlVW5pZm9ybSgnZicsIDApLFxuICAgICAgICAgICAgd1JldHVybk51bWJlcjogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIHdSR0I6IG1ha2VVbmlmb3JtKCdmJywgMSksXG4gICAgICAgICAgICB3U291cmNlSUQ6IG1ha2VVbmlmb3JtKCdmJywgMCksXG4gICAgICAgICAgICBvcGFjaXR5QXR0ZW51YXRpb246IG1ha2VVbmlmb3JtKCdmJywgMSksXG4gICAgICAgICAgICBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlOiBtYWtlVW5pZm9ybSgnZnYnLCBuZXcgVmVjdG9yMygpKSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkUG9pbnRDb2xvcjogbWFrZVVuaWZvcm0oJ2Z2JywgREVGQVVMVF9ISUdITElHSFRfQ09MT1IuY2xvbmUoKSksXG4gICAgICAgICAgICBlbmFibGVQb2ludEhpZ2hsaWdodGluZzogbWFrZVVuaWZvcm0oJ2InLCB0cnVlKSxcbiAgICAgICAgICAgIGhpZ2hsaWdodGVkUG9pbnRTY2FsZTogbWFrZVVuaWZvcm0oJ2YnLCAyLjApLFxuICAgICAgICAgICAgYmFja2dyb3VuZE1hcDogbWFrZVVuaWZvcm0oJ3QnLCBudWxsKSxcbiAgICAgICAgICAgIG5vcm1hbEZpbHRlcmluZ01vZGU6IG1ha2VVbmlmb3JtKCdpJywgTm9ybWFsRmlsdGVyaW5nTW9kZS5BQlNPTFVURV9OT1JNQUxfRklMVEVSSU5HX01PREUpLFxuICAgICAgICAgICAgcG9pbnRDbG91ZElEOiBtYWtlVW5pZm9ybSgnZicsIDIpLFxuICAgICAgICAgICAgcG9pbnRDbG91ZE1peGluZ01vZGU6IG1ha2VVbmlmb3JtKCdpJywgUG9pbnRDbG91ZE1peGluZ01vZGUuQ0hFQ0tCT0FSRCksXG4gICAgICAgICAgICBzdHJpcGVEaXN0YW5jZVg6IG1ha2VVbmlmb3JtKCdmJywgNSksXG4gICAgICAgICAgICBzdHJpcGVEaXN0YW5jZVk6IG1ha2VVbmlmb3JtKCdmJywgNSksXG4gICAgICAgICAgICBzdHJpcGVEaXZpc29yWDogbWFrZVVuaWZvcm0oJ2YnLCAyKSxcbiAgICAgICAgICAgIHN0cmlwZURpdmlzb3JZOiBtYWtlVW5pZm9ybSgnZicsIDIpLFxuICAgICAgICAgICAgcG9pbnRDbG91ZE1peEFuZ2xlOiBtYWtlVW5pZm9ybSgnZicsIDMxKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51c2VDbGlwQm94ID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2VpZ2h0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wb2ludENvbG9yVHlwZSA9IFBvaW50Q29sb3JUeXBlLlJHQjtcbiAgICAgICAgdGhpcy5wb2ludFNpemVUeXBlID0gUG9pbnRTaXplVHlwZS5BREFQVElWRTtcbiAgICAgICAgdGhpcy5jbGlwTW9kZSA9IENsaXBNb2RlLkRJU0FCTEVEO1xuICAgICAgICB0aGlzLnVzZUVETCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNoYXBlID0gUG9pbnRTaGFwZS5TUVVBUkU7XG4gICAgICAgIHRoaXMudHJlZVR5cGUgPSBUcmVlVHlwZS5PQ1RSRUU7XG4gICAgICAgIHRoaXMucG9pbnRPcGFjaXR5VHlwZSA9IFBvaW50T3BhY2l0eVR5cGUuRklYRUQ7XG4gICAgICAgIHRoaXMudXNlRmlsdGVyQnlOb3JtYWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VUZXh0dXJlQmxlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51c2VQb2ludENsb3VkTWl4aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0UG9pbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IHsgdHlwZTogJ2Z2JywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICBjb2xvcjogeyB0eXBlOiAnZnYnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgICAgIG5vcm1hbDogeyB0eXBlOiAnZnYnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgICAgIGludGVuc2l0eTogeyB0eXBlOiAnZicsIHZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgY2xhc3NpZmljYXRpb246IHsgdHlwZTogJ2YnLCB2YWx1ZTogW10gfSxcbiAgICAgICAgICAgIHJldHVybk51bWJlcjogeyB0eXBlOiAnZicsIHZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgbnVtYmVyT2ZSZXR1cm5zOiB7IHR5cGU6ICdmJywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICBwb2ludFNvdXJjZUlEOiB7IHR5cGU6ICdmJywgdmFsdWU6IFtdIH0sXG4gICAgICAgICAgICBpbmRpY2VzOiB7IHR5cGU6ICdmdicsIHZhbHVlOiBbXSB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0ZXggPSAodGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlID0gZ2VuZXJhdGVEYXRhVGV4dHVyZSgyMDQ4LCAxLCBuZXcgQ29sb3IoMHhmZmZmZmYpKSk7XG4gICAgICAgIHRleC5taW5GaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xuICAgICAgICB0ZXgubWFnRmlsdGVyID0gTmVhcmVzdEZpbHRlcjtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd2aXNpYmxlTm9kZXMnLCB0ZXgpO1xuICAgICAgICB0aGlzLnRyZWVUeXBlID0gZ2V0VmFsaWQocGFyYW1ldGVycy50cmVlVHlwZSwgVHJlZVR5cGUuT0NUUkVFKTtcbiAgICAgICAgdGhpcy5zaXplID0gZ2V0VmFsaWQocGFyYW1ldGVycy5zaXplLCAxLjApO1xuICAgICAgICB0aGlzLm1pblNpemUgPSBnZXRWYWxpZChwYXJhbWV0ZXJzLm1pblNpemUsIDIuMCk7XG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IGdldFZhbGlkKHBhcmFtZXRlcnMubWF4U2l6ZSwgNTAuMCk7XG4gICAgICAgIHRoaXMuY29sb3JSZ2JhID0gQm9vbGVhbihwYXJhbWV0ZXJzLmNvbG9yUmdiYSk7XG4gICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb24gPSBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMubm9ybWFsID0gWzAsIDAsIDBdO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMuY2xhc3NpZmljYXRpb24gPSBbMCwgMCwgMF07XG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy5pbmRpY2VzID0gWzAsIDAsIDAsIDBdO1xuICAgICAgICB0aGlzLnZlcnRleENvbG9ycyA9IHRydWU7XG4gICAgICAgIHRoaXMudXBkYXRlU2hhZGVyU291cmNlKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnRUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50VGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50VGV4dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVOb2Rlc1RleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJWaXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzKCk7XG4gICAgICAgIGlmICh0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVwdGhNYXApIHtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhNYXAuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5kZXB0aE1hcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kTWFwKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXAuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kTWFwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyVmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cygpIHtcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLmNsZWFyKCk7XG4gICAgfVxuICAgIHVwZGF0ZVNoYWRlclNvdXJjZSgpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSB0aGlzLmFwcGx5RGVmaW5lcyhyZXF1aXJlKCcuL3NoYWRlcnMvcG9pbnRjbG91ZC52ZXJ0JykuZGVmYXVsdCk7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmFwcGx5RGVmaW5lcyhyZXF1aXJlKCcuL3NoYWRlcnMvcG9pbnRjbG91ZC5mcmFnJykuZGVmYXVsdCk7XG4gICAgICAgIGlmICh0aGlzLm9wYWNpdHkgPT09IDEuMCkge1xuICAgICAgICAgICAgdGhpcy5ibGVuZGluZyA9IE5vQmxlbmRpbmc7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9wYWNpdHkgPCAxLjAgJiYgIXRoaXMudXNlRURMKSB7XG4gICAgICAgICAgICB0aGlzLmJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcbiAgICAgICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhGdW5jID0gTGVzc0VxdWFsRGVwdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIGFwcGx5RGVmaW5lcyhzaGFkZXJTcmMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGAjZGVmaW5lICR7dmFsdWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lKFRSRUVfVFlQRV9ERUZTW3RoaXMudHJlZVR5cGVdKTtcbiAgICAgICAgZGVmaW5lKFNJWkVfVFlQRV9ERUZTW3RoaXMucG9pbnRTaXplVHlwZV0pO1xuICAgICAgICBkZWZpbmUoU0hBUEVfREVGU1t0aGlzLnNoYXBlXSk7XG4gICAgICAgIGRlZmluZShDT0xPUl9ERUZTW3RoaXMucG9pbnRDb2xvclR5cGVdKTtcbiAgICAgICAgZGVmaW5lKENMSVBfTU9ERV9ERUZTW3RoaXMuY2xpcE1vZGVdKTtcbiAgICAgICAgZGVmaW5lKE9QQUNJVFlfREVGU1t0aGlzLnBvaW50T3BhY2l0eVR5cGVdKTtcbiAgICAgICAgLy8gV2Ugb25seSBwZXJmb3JtIGdhbW1hIGFuZCBicmlnaHRuZXNzL2NvbnRyYXN0IGNhbGN1bGF0aW9ucyBwZXIgcG9pbnQgaWYgdmFsdWVzIGFyZSBzcGVjaWZpZWQuXG4gICAgICAgIGlmICh0aGlzLnJnYkdhbW1hICE9PSBERUZBVUxUX1JHQl9HQU1NQSB8fFxuICAgICAgICAgICAgdGhpcy5yZ2JCcmlnaHRuZXNzICE9PSBERUZBVUxUX1JHQl9CUklHSFRORVNTIHx8XG4gICAgICAgICAgICB0aGlzLnJnYkNvbnRyYXN0ICE9PSBERUZBVUxUX1JHQl9DT05UUkFTVCkge1xuICAgICAgICAgICAgZGVmaW5lKCd1c2VfcmdiX2dhbW1hX2NvbnRyYXN0X2JyaWdodG5lc3MnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VGaWx0ZXJCeU5vcm1hbCkge1xuICAgICAgICAgICAgZGVmaW5lKCd1c2VfZmlsdGVyX2J5X25vcm1hbCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZUVETCkge1xuICAgICAgICAgICAgZGVmaW5lKCd1c2VfZWRsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWQpIHtcbiAgICAgICAgICAgIGRlZmluZSgnd2VpZ2h0ZWRfc3BsYXRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubnVtQ2xpcEJveGVzID4gMCkge1xuICAgICAgICAgICAgZGVmaW5lKCd1c2VfY2xpcF9ib3gnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQb2ludCkge1xuICAgICAgICAgICAgZGVmaW5lKCdoaWdobGlnaHRfcG9pbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VUZXh0dXJlQmxlbmRpbmcpIHtcbiAgICAgICAgICAgIGRlZmluZSgndXNlX3RleHR1cmVfYmxlbmRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51c2VQb2ludENsb3VkTWl4aW5nKSB7XG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV9wb2ludF9jbG91ZF9taXhpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb2xvclJnYmEpIHtcbiAgICAgICAgICAgIGRlZmluZSgnY29sb3JfcmdiYScpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZSgnTUFYX1BPSU5UX0xJR0hUUyAwJyk7XG4gICAgICAgIGRlZmluZSgnTUFYX0RJUl9MSUdIVFMgMCcpO1xuICAgICAgICBwYXJ0cy5wdXNoKHNoYWRlclNyYyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgc2V0UG9pbnRDbG91ZE1peGluZ01vZGUobW9kZSkge1xuICAgICAgICB0aGlzLnBvaW50Q2xvdWRNaXhpbmdNb2RlID0gbW9kZTtcbiAgICB9XG4gICAgZ2V0UG9pbnRDbG91ZE1peGluZ01vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvaW50Q2xvdWRNaXhpbmdNb2RlID09PSBQb2ludENsb3VkTWl4aW5nTW9kZS5TVFJJUEVTKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnRDbG91ZE1peGluZ01vZGUuU1RSSVBFUztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUG9pbnRDbG91ZE1peGluZ01vZGUuQ0hFQ0tCT0FSRDtcbiAgICB9XG4gICAgc2V0Q2xpcEJveGVzKGNsaXBCb3hlcykge1xuICAgICAgICBpZiAoIWNsaXBCb3hlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpcEJveGVzID0gY2xpcEJveGVzO1xuICAgICAgICBjb25zdCBkb1VwZGF0ZSA9IHRoaXMubnVtQ2xpcEJveGVzICE9PSBjbGlwQm94ZXMubGVuZ3RoICYmIChjbGlwQm94ZXMubGVuZ3RoID09PSAwIHx8IHRoaXMubnVtQ2xpcEJveGVzID09PSAwKTtcbiAgICAgICAgdGhpcy5udW1DbGlwQm94ZXMgPSBjbGlwQm94ZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2NsaXBCb3hDb3VudCcsIHRoaXMubnVtQ2xpcEJveGVzKTtcbiAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlclNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaXBCb3hlc0xlbmd0aCA9IHRoaXMubnVtQ2xpcEJveGVzICogMTY7XG4gICAgICAgIGNvbnN0IGNsaXBCb3hlc0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjbGlwQm94ZXNMZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubnVtQ2xpcEJveGVzOyBpKyspIHtcbiAgICAgICAgICAgIGNsaXBCb3hlc0FycmF5LnNldChjbGlwQm94ZXNbaV0uaW52ZXJzZS5lbGVtZW50cywgMTYgKiBpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaXBCb3hlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oY2xpcEJveGVzQXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgY2xpcEJveGVzQXJyYXlbaV0gPSBJbmZpbml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2NsaXBCb3hlcycsIGNsaXBCb3hlc0FycmF5KTtcbiAgICB9XG4gICAgZ2V0IGdyYWRpZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhZGllbnQ7XG4gICAgfVxuICAgIHNldCBncmFkaWVudCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fZ3JhZGllbnQgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9ncmFkaWVudCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFRleHR1cmUgPSBnZW5lcmF0ZUdyYWRpZW50VGV4dHVyZSh0aGlzLl9ncmFkaWVudCk7XG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2dyYWRpZW50JywgdGhpcy5ncmFkaWVudFRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjbGFzc2lmaWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzaWZpY2F0aW9uO1xuICAgIH1cbiAgICBzZXQgY2xhc3NpZmljYXRpb24odmFsdWUpIHtcbiAgICAgICAgY29uc3QgY29weSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHZhbHVlW2tleV0uY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaXNFcXVhbCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NpZmljYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaXNFcXVhbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXNFcXVhbCA9IE9iamVjdC5rZXlzKGNvcHkpLmxlbmd0aCA9PT0gT2JqZWN0LmtleXModGhpcy5fY2xhc3NpZmljYXRpb24pLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvcHkpKSB7XG4gICAgICAgICAgICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgdGhpcy5fY2xhc3NpZmljYXRpb25ba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzRXF1YWwgPSBpc0VxdWFsICYmIGNvcHlba2V5XS5lcXVhbHModGhpcy5fY2xhc3NpZmljYXRpb25ba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0VxdWFsKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGFzc2lmaWNhdGlvbiA9IGNvcHk7XG4gICAgICAgICAgICB0aGlzLnJlY29tcHV0ZUNsYXNzaWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjb21wdXRlQ2xhc3NpZmljYXRpb24oKSB7XG4gICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlID0gZ2VuZXJhdGVDbGFzc2lmaWNhdGlvblRleHR1cmUodGhpcy5fY2xhc3NpZmljYXRpb24pO1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2NsYXNzaWZpY2F0aW9uTFVUJywgdGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUpO1xuICAgIH1cbiAgICBnZXQgZWxldmF0aW9uUmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5oZWlnaHRNaW4sIHRoaXMuaGVpZ2h0TWF4XTtcbiAgICB9XG4gICAgc2V0IGVsZXZhdGlvblJhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVpZ2h0TWluID0gdmFsdWVbMF07XG4gICAgICAgIHRoaXMuaGVpZ2h0TWF4ID0gdmFsdWVbMV07XG4gICAgfVxuICAgIGdldFVuaWZvcm0obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3JtcyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZTtcbiAgICB9XG4gICAgc2V0VW5pZm9ybShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy51bmlmb3JtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdU9iaiA9IHRoaXMudW5pZm9ybXNbbmFtZV07XG4gICAgICAgIGlmICh1T2JqLnR5cGUgPT09ICdjJykge1xuICAgICAgICAgICAgdU9iai52YWx1ZS5jb3B5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdU9iai52YWx1ZSkge1xuICAgICAgICAgICAgdU9iai52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU1hdGVyaWFsKG9jdHJlZSwgdmlzaWJsZU5vZGVzLCBjYW1lcmEsIHJlbmRlcmVyKSB7XG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XG4gICAgICAgIGlmIChjYW1lcmEudHlwZSA9PT0gUEVSU1BFQ1RJVkVfQ0FNRVJBKSB7XG4gICAgICAgICAgICB0aGlzLmZvdiA9IGNhbWVyYS5mb3YgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZvdiA9IE1hdGguUEkgLyAyOyAvLyB3aWxsIHJlc3VsdCBpbiBzbG9wZSA9IDEgaW4gdGhlIHNoYWRlclxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpO1xuICAgICAgICBpZiAocmVuZGVyVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNjcmVlbldpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5IZWlnaHQgPSByZW5kZXJUYXJnZXQuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5XaWR0aCA9IHJlbmRlcmVyLmRvbUVsZW1lbnQuY2xpZW50V2lkdGggKiBwaXhlbFJhdGlvO1xuICAgICAgICAgICAgdGhpcy5zY3JlZW5IZWlnaHQgPSByZW5kZXJlci5kb21FbGVtZW50LmNsaWVudEhlaWdodCAqIHBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudXNlRHJhd2luZ0J1ZmZlclNpemUpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmdldERyYXdpbmdCdWZmZXJTaXplKFBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMyKTtcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuV2lkdGggPSBQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMi53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuSGVpZ2h0ID0gUG9pbnRDbG91ZE1hdGVyaWFsLmhlbHBlclZlYzIuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1heFNjYWxlID0gTWF0aC5tYXgob2N0cmVlLnNjYWxlLngsIG9jdHJlZS5zY2FsZS55LCBvY3RyZWUuc2NhbGUueik7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IG9jdHJlZS5wY29HZW9tZXRyeS5zcGFjaW5nICogbWF4U2NhbGU7XG4gICAgICAgIHRoaXMub2N0cmVlU2l6ZSA9IG9jdHJlZS5wY29HZW9tZXRyeS5ib3VuZGluZ0JveC5nZXRTaXplKFBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMzKS54O1xuICAgICAgICBpZiAodGhpcy5wb2ludFNpemVUeXBlID09PSBQb2ludFNpemVUeXBlLkFEQVBUSVZFIHx8XG4gICAgICAgICAgICB0aGlzLnBvaW50Q29sb3JUeXBlID09PSBQb2ludENvbG9yVHlwZS5MT0QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eVRleHR1cmVEYXRhKHZpc2libGVOb2Rlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmlzaWJpbGl0eVRleHR1cmVEYXRhKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLnNvcnQoYnlMZXZlbEFuZEluZGV4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KG5vZGVzLmxlbmd0aCAqIDQpO1xuICAgICAgICBjb25zdCBvZmZzZXRzVG9DaGlsZCA9IG5ldyBBcnJheShub2Rlcy5sZW5ndGgpLmZpbGwoSW5maW5pdHkpO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlVGV4dHVyZU9mZnNldHMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLnNldChub2RlLm5hbWUsIGkpO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IG5vZGUubmFtZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2Zmc2V0ID0gdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLmdldChwYXJlbnROYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRPZmZzZXRUb0NoaWxkID0gaSAtIHBhcmVudE9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXRzVG9DaGlsZFtwYXJlbnRPZmZzZXRdID0gTWF0aC5taW4ob2Zmc2V0c1RvQ2hpbGRbcGFyZW50T2Zmc2V0XSwgcGFyZW50T2Zmc2V0VG9DaGlsZCk7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHBhcmVudE9mZnNldCAqIDQ7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXRdID0gZGF0YVtvZmZzZXRdIHwgKDEgPDwgbm9kZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IG9mZnNldHNUb0NoaWxkW3BhcmVudE9mZnNldF0gPj4gODtcbiAgICAgICAgICAgICAgICBkYXRhW29mZnNldCArIDJdID0gb2Zmc2V0c1RvQ2hpbGRbcGFyZW50T2Zmc2V0XSAlIDI1NjtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFbaSAqIDQgKyAzXSA9IG5vZGUubmFtZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZTtcbiAgICAgICAgaWYgKHRleHR1cmUpIHtcbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UuZGF0YS5zZXQoZGF0YSk7XG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgbWFrZU9uQmVmb3JlUmVuZGVyKG9jdHJlZSwgbm9kZSwgcGNJbmRleCkge1xuICAgICAgICByZXR1cm4gKF9yZW5kZXJlciwgX3NjZW5lLCBfY2FtZXJhLCBfZ2VvbWV0cnksIG1hdGVyaWFsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb2ludENsb3VkTWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsVW5pZm9ybXMgPSBwb2ludENsb3VkTWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgICAgICAgICBtYXRlcmlhbFVuaWZvcm1zLmxldmVsLnZhbHVlID0gbm9kZS5sZXZlbDtcbiAgICAgICAgICAgIG1hdGVyaWFsVW5pZm9ybXMuaXNMZWFmTm9kZS52YWx1ZSA9IG5vZGUuaXNMZWFmTm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHZuU3RhcnQgPSBwb2ludENsb3VkTWF0ZXJpYWwudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5nZXQobm9kZS5uYW1lKTtcbiAgICAgICAgICAgIGlmICh2blN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXRlcmlhbFVuaWZvcm1zLnZuU3RhcnQudmFsdWUgPSB2blN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0ZXJpYWxVbmlmb3Jtcy5wY0luZGV4LnZhbHVlID1cbiAgICAgICAgICAgICAgICBwY0luZGV4ICE9PSB1bmRlZmluZWQgPyBwY0luZGV4IDogb2N0cmVlLnZpc2libGVOb2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgICAgLy8gTm90ZTogd2hlbiBjaGFuZ2luZyB1bmlmb3JtcyBpbiBvbkJlZm9yZVJlbmRlciwgdGhlIGZsYWcgdW5pZm9ybXNOZWVkVXBkYXRlIGhhcyB0byBiZVxuICAgICAgICAgICAgLy8gc2V0IHRvIHRydWUgdG8gaW5zdHJ1Y3QgVGhyZWVKUyB0byB1cGxvYWQgdGhlbS4gU2VlIGFsc29cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzk4NzAjaXNzdWVjb21tZW50LTM2ODc1MDE4Mi5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgY2FzdCB0byBhbnkgYWZ0ZXIgdXBkYXRpbmcgdG8gVGhyZWUuSlMgPj0gcjExM1xuICAgICAgICAgICAgbWF0ZXJpYWwgLypTaGFkZXJNYXRlcmlhbCovLnVuaWZvcm1zTmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfVxufVxuUG9pbnRDbG91ZE1hdGVyaWFsLmhlbHBlclZlYzMgPSBuZXcgVmVjdG9yMygpO1xuUG9pbnRDbG91ZE1hdGVyaWFsLmhlbHBlclZlYzIgPSBuZXcgVmVjdG9yMigpO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnYmJTaXplJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiYmJTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdjbGlwRXh0ZW50Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiY2xpcEV4dGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnZGVwdGhNYXAnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJkZXB0aE1hcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnZm92Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZm92XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdoZWlnaHRNYXgnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJoZWlnaHRNYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2hlaWdodE1pbicpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhlaWdodE1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnaW50ZW5zaXR5QnJpZ2h0bmVzcycpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImludGVuc2l0eUJyaWdodG5lc3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ludGVuc2l0eUNvbnRyYXN0Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5Q29udHJhc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ludGVuc2l0eUdhbW1hJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5R2FtbWFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ludGVuc2l0eVJhbmdlJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5UmFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ21heFNpemUnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdtaW5TaXplJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwibWluU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnb2N0cmVlU2l6ZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIm9jdHJlZVNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ29wYWNpdHknLCB0cnVlKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdyZ2JCcmlnaHRuZXNzJywgdHJ1ZSlcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwicmdiQnJpZ2h0bmVzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgncmdiQ29udHJhc3QnLCB0cnVlKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJyZ2JDb250cmFzdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgncmdiR2FtbWEnLCB0cnVlKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJyZ2JHYW1tYVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc2NyZWVuSGVpZ2h0Jylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic2NyZWVuSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdzY3JlZW5XaWR0aCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNjcmVlbldpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdzaXplJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc3BhY2luZycpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3RyYW5zaXRpb24nKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ0cmFuc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCd1Q29sb3InKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnd0NsYXNzaWZpY2F0aW9uJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0Q2xhc3NpZmljYXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dFbGV2YXRpb24nKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRFbGV2YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dJbnRlbnNpdHknKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRJbnRlbnNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dSZXR1cm5OdW1iZXInKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRSZXR1cm5OdW1iZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dSR0InKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRSR0JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3dTb3VyY2VJRCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIndlaWdodFNvdXJjZUlEXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdvcGFjaXR5QXR0ZW51YXRpb24nKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJvcGFjaXR5QXR0ZW51YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2ZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZmlsdGVyQnlOb3JtYWxUaHJlc2hvbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2hpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ2hpZ2hsaWdodGVkUG9pbnRDb2xvcicpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhpZ2hsaWdodGVkUG9pbnRDb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnZW5hYmxlUG9pbnRIaWdobGlnaHRpbmcnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJlbmFibGVQb2ludEhpZ2hsaWdodGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnaGlnaGxpZ2h0ZWRQb2ludFNjYWxlJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0ZWRQb2ludFNjYWxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdub3JtYWxGaWx0ZXJpbmdNb2RlJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwibm9ybWFsRmlsdGVyaW5nTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnYmFja2dyb3VuZE1hcCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImJhY2tncm91bmRNYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3BvaW50Q2xvdWRJRCcpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q2xvdWRJRFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgncG9pbnRDbG91ZE1peGluZ01vZGUnKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludENsb3VkTWl4aW5nTW9kZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgdW5pZm9ybSgnc3RyaXBlRGlzdGFuY2VYJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGlzdGFuY2VYXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICB1bmlmb3JtKCdzdHJpcGVEaXN0YW5jZVknKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJzdHJpcGVEaXN0YW5jZVlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3N0cmlwZURpdmlzb3JYJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGl2aXNvclhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3N0cmlwZURpdmlzb3JZJylcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGl2aXNvcllcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHVuaWZvcm0oJ3BvaW50Q2xvdWRNaXhBbmdsZScpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q2xvdWRNaXhBbmdsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ1c2VDbGlwQm94XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIndlaWdodGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q29sb3JUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50U2l6ZVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiY2xpcE1vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlRURMXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNoYXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInRyZWVUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50T3BhY2l0eVR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlRmlsdGVyQnlOb3JtYWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlVGV4dHVyZUJsZW5kaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInVzZVBvaW50Q2xvdWRNaXhpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0UG9pbnRcIiwgdm9pZCAwKTtcbmZ1bmN0aW9uIG1ha2VVbmlmb3JtKHR5cGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIHsgdHlwZSwgdmFsdWUgfTtcbn1cbmZ1bmN0aW9uIGdldFZhbGlkKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gdW5kZWZpbmVkID8gYiA6IGE7XG59XG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1pbnZhbGlkLXRoaXNcbmZ1bmN0aW9uIHVuaWZvcm0odW5pZm9ybU5hbWUsIHJlcXVpcmVTcmNVcGRhdGUgPSBmYWxzZSkge1xuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVuaWZvcm0odW5pZm9ybU5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5nZXRVbmlmb3JtKHVuaWZvcm1OYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0odW5pZm9ybU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVpcmVTcmNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyU291cmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVxdWlyZXNTaGFkZXJVcGRhdGUoKSB7XG4gICAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGBfJHtwcm9wZXJ0eUtleS50b1N0cmluZygpfWA7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGROYW1lXTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXNbZmllbGROYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ZpZWxkTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9ibHVyLW1hdGVyaWFsJztcbmV4cG9ydCAqIGZyb20gJy4vY2xpcHBpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9lbnVtcyc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLW1hdGVyaWFsJztcbmV4cG9ydCAqIGZyb20gJy4vdGV4dHVyZS1nZW5lcmF0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9ncmFkaWVudHMnO1xuIiwiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ29udmVydGVkIHRvIFR5cGVzY3JpcHQgYW5kIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IHZhciBQb2ludEF0dHJpYnV0ZU5hbWU7XG4oZnVuY3Rpb24gKFBvaW50QXR0cmlidXRlTmFtZSkge1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJQT1NJVElPTl9DQVJURVNJQU5cIl0gPSAwXSA9IFwiUE9TSVRJT05fQ0FSVEVTSUFOXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNPTE9SX1BBQ0tFRFwiXSA9IDFdID0gXCJDT0xPUl9QQUNLRURcIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiQ09MT1JfRkxPQVRTXzFcIl0gPSAyXSA9IFwiQ09MT1JfRkxPQVRTXzFcIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiQ09MT1JfRkxPQVRTXzI1NVwiXSA9IDNdID0gXCJDT0xPUl9GTE9BVFNfMjU1XCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIk5PUk1BTF9GTE9BVFNcIl0gPSA0XSA9IFwiTk9STUFMX0ZMT0FUU1wiO1xuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJGSUxMRVJcIl0gPSA1XSA9IFwiRklMTEVSXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIklOVEVOU0lUWVwiXSA9IDZdID0gXCJJTlRFTlNJVFlcIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiQ0xBU1NJRklDQVRJT05cIl0gPSA3XSA9IFwiQ0xBU1NJRklDQVRJT05cIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiTk9STUFMX1NQSEVSRU1BUFBFRFwiXSA9IDhdID0gXCJOT1JNQUxfU1BIRVJFTUFQUEVEXCI7XG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIk5PUk1BTF9PQ1QxNlwiXSA9IDldID0gXCJOT1JNQUxfT0NUMTZcIjtcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiTk9STUFMXCJdID0gMTBdID0gXCJOT1JNQUxcIjtcbn0pKFBvaW50QXR0cmlidXRlTmFtZSB8fCAoUG9pbnRBdHRyaWJ1dGVOYW1lID0ge30pKTtcbmV4cG9ydCBjb25zdCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMgPSB7XG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBzaXplOiA4IH0sXG4gICAgREFUQV9UWVBFX0ZMT0FUOiB7IG9yZGluYWw6IDEsIHNpemU6IDQgfSxcbiAgICBEQVRBX1RZUEVfSU5UODogeyBvcmRpbmFsOiAyLCBzaXplOiAxIH0sXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIHNpemU6IDEgfSxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgc2l6ZTogMiB9LFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgc2l6ZTogMiB9LFxuICAgIERBVEFfVFlQRV9JTlQzMjogeyBvcmRpbmFsOiA2LCBzaXplOiA0IH0sXG4gICAgREFUQV9UWVBFX1VJTlQzMjogeyBvcmRpbmFsOiA3LCBzaXplOiA0IH0sXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIHNpemU6IDggfSxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIHNpemU6IDggfSxcbn07XG5mdW5jdGlvbiBtYWtlUG9pbnRBdHRyaWJ1dGUobmFtZSwgdHlwZSwgbnVtRWxlbWVudHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICBudW1FbGVtZW50cyxcbiAgICAgICAgYnl0ZVNpemU6IG51bUVsZW1lbnRzICogdHlwZS5zaXplLFxuICAgIH07XG59XG5jb25zdCBSR0JBX1BBQ0tFRCA9IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDQpO1xuZXhwb3J0IGNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLlBPU0lUSU9OX0NBUlRFU0lBTiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXG4gICAgUkdCQV9QQUNLRUQsXG4gICAgQ09MT1JfUEFDS0VEOiBSR0JBX1BBQ0tFRCxcbiAgICBSR0JfUEFDS0VEOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9JTlQ4LCAzKSxcbiAgICBOT1JNQUxfRkxPQVRTOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9GTE9BVFMsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxuICAgIEZJTExFUl8xQjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5GSUxMRVIsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxuICAgIElOVEVOU0lUWTogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5JTlRFTlNJVFksIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcbiAgICBDTEFTU0lGSUNBVElPTjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfU1BIRVJFTUFQUEVELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcbiAgICBOT1JNQUxfT0NUMTY6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2LCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcbiAgICBOT1JNQUw6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbn07XG5leHBvcnQgY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEF0dHJpYnV0ZU5hbWVzID0gW10pIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSAwO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50QXR0cmlidXRlTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlTmFtZSA9IHBvaW50QXR0cmlidXRlTmFtZXNbaV07XG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQocG9pbnRBdHRyaWJ1dGUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICB9XG4gICAgaGFzQ29sb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoaXNDb2xvckF0dHJpYnV0ZSkgIT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzTm9ybWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGlzTm9ybWFsQXR0cmlidXRlKSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29sb3JBdHRyaWJ1dGUoeyBuYW1lIH0pIHtcbiAgICByZXR1cm4gbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRDtcbn1cbmZ1bmN0aW9uIGlzTm9ybWFsQXR0cmlidXRlKHsgbmFtZSB9KSB7XG4gICAgcmV0dXJuIChuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX1NQSEVSRU1BUFBFRCB8fFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX0ZMT0FUUyB8fFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMIHx8XG4gICAgICAgIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYpO1xufVxuIiwiaW1wb3J0IHsgQm94MywgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbi8qKlxuICogYWRhcHRlZCBmcm9tIG1obHVza2EgYXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTU2MVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3goYm94LCB0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IEJveDMoKS5zZXRGcm9tUG9pbnRzKFtcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1pbi54LCBib3gubWluLnksIGJveC5taW4ueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5taW4ueCwgYm94Lm1pbi55LCBib3gubWluLnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1pbi54LCBib3gubWF4LnksIGJveC5taW4ueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5taW4ueCwgYm94Lm1pbi55LCBib3gubWF4LnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5tYXgueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICAgICAgbmV3IFZlY3RvcjMoYm94Lm1heC54LCBib3gubWF4LnksIGJveC5taW4ueikuYXBwbHlNYXRyaXg0KHRyYW5zZm9ybSksXG4gICAgICAgIG5ldyBWZWN0b3IzKGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWF4LnopLmFwcGx5TWF0cml4NCh0cmFuc2Zvcm0pLFxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcbiAgICBdKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGlsZEFBQkIoYWFiYiwgaW5kZXgpIHtcbiAgICBjb25zdCBtaW4gPSBhYWJiLm1pbi5jbG9uZSgpO1xuICAgIGNvbnN0IG1heCA9IGFhYmIubWF4LmNsb25lKCk7XG4gICAgY29uc3Qgc2l6ZSA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhtYXgsIG1pbik7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWJpdHdpc2VcbiAgICBpZiAoKGluZGV4ICYgMGIwMDAxKSA+IDApIHtcbiAgICAgICAgbWluLnogKz0gc2l6ZS56IC8gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heC56IC09IHNpemUueiAvIDI7XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgaWYgKChpbmRleCAmIDBiMDAxMCkgPiAwKSB7XG4gICAgICAgIG1pbi55ICs9IHNpemUueSAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXgueSAtPSBzaXplLnkgLyAyO1xuICAgIH1cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxuICAgIGlmICgoaW5kZXggJiAwYjAxMDApID4gMCkge1xuICAgICAgICBtaW4ueCArPSBzaXplLnggLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF4LnggLT0gc2l6ZS54IC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCb3gzKG1pbiwgbWF4KTtcbn1cbiIsIi8qKlxuICogQWRhcHRlZCBmcm9tIFBvdHJlZS5qcyBodHRwOi8vcG90cmVlLm9yZ1xuICogUG90cmVlIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlL2Jsb2IvMS41L0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgRXZlbnREaXNwYXRjaGVyLCBTcGhlcmUsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBjcmVhdGVDaGlsZEFBQkIgfSBmcm9tICcuL3V0aWxzL2JvdW5kcyc7XG5pbXBvcnQgeyBnZXRJbmRleEZyb21OYW1lLCBoYW5kbGVFbXB0eUJ1ZmZlciwgaGFuZGxlRmFpbGVkUmVxdWVzdCB9IGZyb20gJy4vdXRpbHMvdXRpbHMnO1xuY29uc3QgTk9ERV9TVFJJREUgPSA1O1xuZXhwb3J0IGNsYXNzIFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBjb0dlb21ldHJ5LCBib3VuZGluZ0JveCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlkID0gUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZS5pZENvdW50Kys7XG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSAwO1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5tZWFuID0gbmV3IFZlY3RvcjMoKTtcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgPSAwO1xuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZVRpbWVEaXNwb3NlSGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5pc0xlYWZOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1RyZWVOb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNHZW9tZXRyeU5vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluZGV4ID0gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKTtcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeSA9IHBjb0dlb21ldHJ5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMudGlnaHRCb3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2VvbWV0cnkgfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcigpKTtcbiAgICAgICAgdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVybCBvZiB0aGUgYmluYXJ5IGZpbGUgZm9yIHRoaXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRVcmwoKSB7XG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5wY29HZW9tZXRyeTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGdlb21ldHJ5LmxvYWRlci52ZXJzaW9uO1xuICAgICAgICBjb25zdCBwYXRoUGFydHMgPSBbZ2VvbWV0cnkub2N0cmVlRGlyXTtcbiAgICAgICAgaWYgKGdlb21ldHJ5LmxvYWRlciAmJiB2ZXJzaW9uLmVxdWFsT3JIaWdoZXIoJzEuNScpKSB7XG4gICAgICAgICAgICBwYXRoUGFydHMucHVzaCh0aGlzLmdldEhpZXJhcmNoeUJhc2VVcmwoKSk7XG4gICAgICAgICAgICBwYXRoUGFydHMucHVzaCh0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZlcnNpb24uZXF1YWxPckhpZ2hlcignMS40JykpIHtcbiAgICAgICAgICAgIHBhdGhQYXJ0cy5wdXNoKHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmVyc2lvbi51cFRvKCcxLjMnKSkge1xuICAgICAgICAgICAgcGF0aFBhcnRzLnB1c2godGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aFBhcnRzLmpvaW4oJy8nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdXJsIG9mIHRoZSBoaWVyYXJjaHkgZmlsZSBmb3IgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIGdldEhpZXJhcmNoeVVybCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucGNvR2VvbWV0cnkub2N0cmVlRGlyfS8ke3RoaXMuZ2V0SGllcmFyY2h5QmFzZVVybCgpfS8ke3RoaXMubmFtZX0uaHJjYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgc3BlY2lmaWVkIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNoaWxkXG4gICAgICogICAgVGhlIG5vZGUgd2hpY2ggaXMgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZC5cbiAgICAgKi9cbiAgICBhZGRDaGlsZChjaGlsZCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2NoaWxkLmluZGV4XSA9IGNoaWxkO1xuICAgICAgICB0aGlzLmlzTGVhZk5vZGUgPSBmYWxzZTtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIHNwZWNpZmllZCBjYWxsYmFjayBmb3IgdGhlIGN1cnJlbnQgbm9kZSAoaWYgaW5jbHVkZVNlbGYgaXMgc2V0IHRvIHRydWUpIGFuZCBhbGwgaXRzXG4gICAgICogY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2JcbiAgICAgKiAgICBUaGUgZnVuY3Rpb24gd2hpY2ggaXMgdG8gYmUgY2FsbGVkIGZvciBlYWNoIG5vZGUuXG4gICAgICovXG4gICAgdHJhdmVyc2UoY2IsIGluY2x1ZGVTZWxmID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBzdGFjayA9IGluY2x1ZGVTZWxmID8gW3RoaXNdIDogW107XG4gICAgICAgIGxldCBjdXJyZW50O1xuICAgICAgICB3aGlsZSAoKGN1cnJlbnQgPSBzdGFjay5wb3AoKSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2IoY3VycmVudCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGN1cnJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5Mb2FkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5Lm51bU5vZGVzTG9hZGluZysrO1xuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICh0aGlzLnBjb0dlb21ldHJ5LmxvYWRlci52ZXJzaW9uLmVxdWFsT3JIaWdoZXIoJzEuNScpICYmXG4gICAgICAgICAgICB0aGlzLmxldmVsICUgdGhpcy5wY29HZW9tZXRyeS5oaWVyYXJjaHlTdGVwU2l6ZSA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5oYXNDaGlsZHJlbikge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMubG9hZEhpZXJhY2h5VGhlblBvaW50cygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMubG9hZFBvaW50cygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucGNvR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nLS07XG4gICAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYW5Mb2FkKCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmxvYWRpbmcgJiZcbiAgICAgICAgICAgICF0aGlzLmxvYWRlZCAmJlxuICAgICAgICAgICAgIXRoaXMucGNvR2VvbWV0cnkuZGlzcG9zZWQgJiZcbiAgICAgICAgICAgICF0aGlzLnBjb0dlb21ldHJ5LmxvYWRlci5kaXNwb3NlZCAmJlxuICAgICAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcgPCB0aGlzLnBjb0dlb21ldHJ5Lm1heE51bU5vZGVzTG9hZGluZyk7XG4gICAgfVxuICAgIGxvYWRQb2ludHMoKSB7XG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcy5wY29HZW9tZXRyeS5sb2FkZXIubG9hZCh0aGlzKTtcbiAgICB9XG4gICAgbG9hZEhpZXJhY2h5VGhlblBvaW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMubGV2ZWwgJSB0aGlzLnBjb0dlb21ldHJ5LmhpZXJhcmNoeVN0ZXBTaXplICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnBjb0dlb21ldHJ5LmxvYWRlci5nZXRVcmwodGhpcy5nZXRIaWVyYXJjaHlVcmwoKSkpXG4gICAgICAgICAgICAudGhlbih1cmwgPT4gdGhpcy5wY29HZW9tZXRyeS54aHJSZXF1ZXN0KHVybCwgeyBtb2RlOiAnY29ycycgfSkpXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gaGFuZGxlRmFpbGVkUmVxdWVzdChyZXMpKVxuICAgICAgICAgICAgLnRoZW4ob2tSZXMgPT4gb2tSZXMuYXJyYXlCdWZmZXIoKSlcbiAgICAgICAgICAgIC50aGVuKGJ1ZmZlciA9PiBoYW5kbGVFbXB0eUJ1ZmZlcihidWZmZXIpKVxuICAgICAgICAgICAgLnRoZW4ob2tCdWZmZXIgPT4gdGhpcy5sb2FkSGllcmFyY2h5KHRoaXMsIG9rQnVmZmVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVybCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBoaWVyYXJjaHkgaXMsIHJlbGF0aXZlIHRvIHRoZSBvY3RyZWVEaXIuXG4gICAgICovXG4gICAgZ2V0SGllcmFyY2h5QmFzZVVybCgpIHtcbiAgICAgICAgY29uc3QgaGllcmFyY2h5U3RlcFNpemUgPSB0aGlzLnBjb0dlb21ldHJ5LmhpZXJhcmNoeVN0ZXBTaXplO1xuICAgICAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5uYW1lLnN1YnN0cigxKTtcbiAgICAgICAgY29uc3QgbnVtUGFydHMgPSBNYXRoLmZsb29yKGluZGljZXMubGVuZ3RoIC8gaGllcmFyY2h5U3RlcFNpemUpO1xuICAgICAgICBsZXQgcGF0aCA9ICdyLyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGFydHM7IGkrKykge1xuICAgICAgICAgICAgcGF0aCArPSBgJHtpbmRpY2VzLnN1YnN0cihpICogaGllcmFyY2h5U3RlcFNpemUsIGhpZXJhcmNoeVN0ZXBTaXplKX0vYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcbiAgICBsb2FkSGllcmFyY2h5KG5vZGUsIGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKG5vZGUubmFtZSwgMCwgdmlldyk7XG4gICAgICAgIG5vZGUubnVtUG9pbnRzID0gZmlyc3ROb2RlRGF0YS5udW1Qb2ludHM7XG4gICAgICAgIC8vIE5vZGVzIHdoaWNoIG5lZWQgYmUgdmlzaXRlZC5cbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbZmlyc3ROb2RlRGF0YV07XG4gICAgICAgIC8vIE5vZGVzIHdoaWNoIGhhdmUgYWxyZWFkeSBiZWVuIGRlY29kZWQuIFdlIHdpbGwgdGFrZSBub2RlcyBmcm9tIHRoZSBzdGFjayBhbmQgcGxhY2UgdGhlbSBoZXJlLlxuICAgICAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgICAgIGxldCBvZmZzZXQgPSBOT0RFX1NUUklERTtcbiAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrTm9kZURhdGEgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgLy8gRnJvbSB0aGUgbGFzdCBiaXQsIGFsbCB0aGUgd2F5IHRvIHRoZSA4dGggb25lIGZyb20gdGhlIHJpZ2h0LlxuICAgICAgICAgICAgbGV0IG1hc2sgPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4ICYmIG9mZnNldCArIDEgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKChzdGFja05vZGVEYXRhLmNoaWxkcmVuICYgbWFzaykgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKHN0YWNrTm9kZURhdGEubmFtZSArIGksIG9mZnNldCwgdmlldyk7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZWQucHVzaChub2RlRGF0YSk7IC8vIE5vZGUgaXMgZGVjb2RlZC5cbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlRGF0YSk7IC8vIE5lZWQgdG8gY2hlY2sgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gTk9ERV9TVFJJREU7IC8vIE1vdmUgb3ZlciB0byB0aGUgbmV4dCBub2RlIGluIHRoZSBidWZmZXIuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrICogMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgLy8gTWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBub2Rlcy5cbiAgICAgICAgY29uc3Qgbm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIG5vZGVzLnNldChub2RlLm5hbWUsIG5vZGUpO1xuICAgICAgICBkZWNvZGVkLmZvckVhY2gobm9kZURhdGEgPT4gdGhpcy5hZGROb2RlKG5vZGVEYXRhLCBub2RlLnBjb0dlb21ldHJ5LCBub2RlcykpO1xuICAgICAgICBub2RlLmxvYWRQb2ludHMoKTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmVuYWJsZTpuby1iaXR3aXNlXG4gICAgZ2V0Tm9kZURhdGEobmFtZSwgb2Zmc2V0LCB2aWV3KSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlldy5nZXRVaW50OChvZmZzZXQpO1xuICAgICAgICBjb25zdCBudW1Qb2ludHMgPSB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHsgY2hpbGRyZW46IGNoaWxkcmVuLCBudW1Qb2ludHM6IG51bVBvaW50cywgbmFtZSB9O1xuICAgIH1cbiAgICBhZGROb2RlKHsgbmFtZSwgbnVtUG9pbnRzLCBjaGlsZHJlbiB9LCBwY28sIG5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKTtcbiAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2Rlcy5nZXQocGFyZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IGxldmVsID0gbmFtZS5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGNyZWF0ZUNoaWxkQUFCQihwYXJlbnROb2RlLmJvdW5kaW5nQm94LCBpbmRleCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZShuYW1lLCBwY28sIGJvdW5kaW5nQm94KTtcbiAgICAgICAgbm9kZS5sZXZlbCA9IGxldmVsO1xuICAgICAgICBub2RlLm51bVBvaW50cyA9IG51bVBvaW50cztcbiAgICAgICAgbm9kZS5oYXNDaGlsZHJlbiA9IGNoaWxkcmVuID4gMDtcbiAgICAgICAgbm9kZS5zcGFjaW5nID0gcGNvLnNwYWNpbmcgLyBNYXRoLnBvdygyLCBsZXZlbCk7XG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XG4gICAgICAgIG5vZGVzLnNldChuYW1lLCBub2RlKTtcbiAgICB9XG59XG5Qb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlLmlkQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgUG9pbnRBdHRyaWJ1dGVzIH0gZnJvbSAnLi9wb2ludC1hdHRyaWJ1dGVzJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKGxvYWRlciwgYm91bmRpbmdCb3gsIHRpZ2h0Qm91bmRpbmdCb3gsIG9mZnNldCwgeGhyUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLnRpZ2h0Qm91bmRpbmdCb3ggPSB0aWdodEJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy54aHJSZXF1ZXN0ID0geGhyUmVxdWVzdDtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vY3RyZWVEaXIgPSAnJztcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlTdGVwU2l6ZSA9IC0xO1xuICAgICAgICB0aGlzLm5vZGVzID0ge307XG4gICAgICAgIHRoaXMubnVtTm9kZXNMb2FkaW5nID0gMDtcbiAgICAgICAgdGhpcy5tYXhOdW1Ob2Rlc0xvYWRpbmcgPSAzO1xuICAgICAgICB0aGlzLnNwYWNpbmcgPSAwO1xuICAgICAgICB0aGlzLnBvaW50QXR0cmlidXRlcyA9IG5ldyBQb2ludEF0dHJpYnV0ZXMoW10pO1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnVybCA9IG51bGw7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5yb290LnRyYXZlcnNlKG5vZGUgPT4gbm9kZS5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgYWRkTm9kZUxvYWRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgY2xlYXJOb2RlTG9hZGVkQ2FsbGJhY2tzKCkge1xuICAgICAgICB0aGlzLmxvYWRlci5jYWxsYmFja3MgPSBbXTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBCdWZmZXJHZW9tZXRyeSwgRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNsYXNzIFBvaW50Q2xvdWRPY3RyZWVOb2RlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeU5vZGUsIHNjZW5lTm9kZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBjSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3hOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzVHJlZU5vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnlOb2RlID0gZ2VvbWV0cnlOb2RlO1xuICAgICAgICB0aGlzLnNjZW5lTm9kZSA9IHNjZW5lTm9kZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGdlb21ldHJ5Tm9kZS5jaGlsZHJlbi5zbGljZSgpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmdlb21ldHJ5Tm9kZS5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGRpc3Bvc2VTY2VuZU5vZGUoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnNjZW5lTm9kZTtcbiAgICAgICAgaWYgKG5vZGUuZ2VvbWV0cnkgaW5zdGFuY2VvZiBCdWZmZXJHZW9tZXRyeSkge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XS5hcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgbm9kZS5nZW9tZXRyeSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmF2ZXJzZShjYiwgaW5jbHVkZVNlbGYpIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyeU5vZGUudHJhdmVyc2UoY2IsIGluY2x1ZGVTZWxmKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaWQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUubmFtZTtcbiAgICB9XG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUubGV2ZWw7XG4gICAgfVxuICAgIGdldCBpc0xlYWZOb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaXNMZWFmTm9kZTtcbiAgICB9XG4gICAgZ2V0IG51bVBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLm51bVBvaW50cztcbiAgICB9XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaW5kZXg7XG4gICAgfVxuICAgIGdldCBib3VuZGluZ1NwaGVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmJvdW5kaW5nU3BoZXJlO1xuICAgIH1cbiAgICBnZXQgYm91bmRpbmdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5ib3VuZGluZ0JveDtcbiAgICB9XG4gICAgZ2V0IHNwYWNpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5zcGFjaW5nO1xuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCk7XG59XG4iLCJpbXBvcnQgeyBDb2xvciwgTGluZWFyRmlsdGVyLCBOZWFyZXN0RmlsdGVyLCBOb0JsZW5kaW5nLCBQb2ludHMsIFJHQkFGb3JtYXQsIFNjZW5lLCBTcGhlcmUsIFZlY3RvcjMsIFZlY3RvcjQsIFdlYkdMUmVuZGVyVGFyZ2V0LCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENPTE9SX0JMQUNLLCBERUZBVUxUX1BJQ0tfV0lORE9XX1NJWkUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDbGlwTW9kZSwgUG9pbnRDbG91ZE1hdGVyaWFsLCBQb2ludENvbG9yVHlwZSB9IGZyb20gJy4vbWF0ZXJpYWxzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi91dGlscy9tYXRoJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlUGlja2VyIHtcbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5waWNrU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucGlja1N0YXRlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGlja1N0YXRlLnJlbmRlclRhcmdldC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIG9jdHJlZXMsIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmIChvY3RyZWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlja1N0YXRlID0gdGhpcy5waWNrU3RhdGVcbiAgICAgICAgICAgID8gdGhpcy5waWNrU3RhdGVcbiAgICAgICAgICAgIDogKHRoaXMucGlja1N0YXRlID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5nZXRQaWNrU3RhdGUoKSk7XG4gICAgICAgIGNvbnN0IHBpY2tNYXRlcmlhbCA9IHBpY2tTdGF0ZS5tYXRlcmlhbDtcbiAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHJlbmRlcmVyLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmNlaWwocmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRXaWR0aCAqIHBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci51cGRhdGVQaWNrUmVuZGVyVGFyZ2V0KHRoaXMucGlja1N0YXRlLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgcGl4ZWxQb3NpdGlvbiA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuaGVscGVyVmVjMzsgLy8gVXNlIGhlbHBlciB2ZWN0b3IgdG8gcHJldmVudCBleHRyYSBhbGxvY2F0aW9ucy5cbiAgICAgICAgaWYgKHBhcmFtcy5waXhlbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uLmNvcHkocGFyYW1zLnBpeGVsUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbi5hZGRWZWN0b3JzKGNhbWVyYS5wb3NpdGlvbiwgcmF5LmRpcmVjdGlvbikucHJvamVjdChjYW1lcmEpO1xuICAgICAgICAgICAgcGl4ZWxQb3NpdGlvbi54ID0gKHBpeGVsUG9zaXRpb24ueCArIDEpICogd2lkdGggKiAwLjU7XG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uLnkgPSAocGl4ZWxQb3NpdGlvbi55ICsgMSkgKiBoZWlnaHQgKiAwLjU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlja1duZFNpemUgPSBNYXRoLmZsb29yKChwYXJhbXMucGlja1dpbmRvd1NpemUgfHwgREVGQVVMVF9QSUNLX1dJTkRPV19TSVpFKSAqIHBpeGVsUmF0aW8pO1xuICAgICAgICBjb25zdCBoYWxmUGlja1duZFNpemUgPSAocGlja1duZFNpemUgLSAxKSAvIDI7XG4gICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKGNsYW1wKHBpeGVsUG9zaXRpb24ueCAtIGhhbGZQaWNrV25kU2l6ZSwgMCwgd2lkdGgpKTtcbiAgICAgICAgY29uc3QgeSA9IE1hdGguZmxvb3IoY2xhbXAocGl4ZWxQb3NpdGlvbi55IC0gaGFsZlBpY2tXbmRTaXplLCAwLCBoZWlnaHQpKTtcbiAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5wcmVwYXJlUmVuZGVyKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSwgcGlja01hdGVyaWFsLCBwaWNrU3RhdGUpO1xuICAgICAgICBjb25zdCByZW5kZXJlZE5vZGVzID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5yZW5kZXIocmVuZGVyZXIsIGNhbWVyYSwgcGlja01hdGVyaWFsLCBvY3RyZWVzLCByYXksIHBpY2tTdGF0ZSwgcGFyYW1zKTtcbiAgICAgICAgLy8gQ2xlYW51cFxuICAgICAgICBwaWNrTWF0ZXJpYWwuY2xlYXJWaXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzKCk7XG4gICAgICAgIC8vIFJlYWQgYmFjayBpbWFnZSBhbmQgZGVjb2RlIGhpdCBwb2ludFxuICAgICAgICBjb25zdCBwaXhlbHMgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLnJlYWRQaXhlbHMocmVuZGVyZXIsIHgsIHksIHBpY2tXbmRTaXplKTtcbiAgICAgICAgY29uc3QgaGl0ID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5maW5kSGl0KHBpeGVscywgcGlja1duZFNpemUpO1xuICAgICAgICByZXR1cm4gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5nZXRQaWNrUG9pbnQoaGl0LCByZW5kZXJlZE5vZGVzKTtcbiAgICB9XG4gICAgc3RhdGljIHByZXBhcmVSZW5kZXIocmVuZGVyZXIsIHgsIHksIHBpY2tXbmRTaXplLCBwaWNrTWF0ZXJpYWwsIHBpY2tTdGF0ZSkge1xuICAgICAgICAvLyBSZW5kZXIgdGhlIGludGVyc2VjdGVkIG5vZGVzIG9udG8gdGhlIHBpY2sgcmVuZGVyIHRhcmdldCwgY2xpcHBpbmcgdG8gYSBzbWFsbCBwaWNrIHdpbmRvdy5cbiAgICAgICAgcmVuZGVyZXIuc2V0U2Npc3Nvcih4LCB5LCBwaWNrV25kU2l6ZSwgcGlja1duZFNpemUpO1xuICAgICAgICByZW5kZXJlci5zZXRTY2lzc29yVGVzdCh0cnVlKTtcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRUZXN0KHBpY2tNYXRlcmlhbC5kZXB0aFRlc3QpO1xuICAgICAgICByZW5kZXJlci5zdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2socGlja01hdGVyaWFsLmRlcHRoV3JpdGUpO1xuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZGluZyhOb0JsZW5kaW5nKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQpO1xuICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGNsZWFyIGNvbG9yIGFuZCBjbGVhciB0aGUgcmVuZGVyZXIgd2l0aCBibGFjayBjb2xvciBhbmQgYWxwaGEgMC5cbiAgICAgICAgcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IpO1xuICAgICAgICBjb25zdCBvbGRDbGVhckFscGhhID0gcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xuICAgICAgICByZW5kZXJlci5zZXRDbGVhckNvbG9yKENPTE9SX0JMQUNLLCAwKTtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIHJlbmRlcmVyLnNldENsZWFyQ29sb3IodGhpcy5jbGVhckNvbG9yLCBvbGRDbGVhckFscGhhKTtcbiAgICB9XG4gICAgc3RhdGljIHJlbmRlcihyZW5kZXJlciwgY2FtZXJhLCBwaWNrTWF0ZXJpYWwsIG9jdHJlZXMsIHJheSwgcGlja1N0YXRlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZWROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG9jdHJlZSBvZiBvY3RyZWVzKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBvY3RyZWUgbm9kZXMgd2hpY2ggaW50ZXJzZWN0IHRoZSBwaWNraW5nIHJheS4gV2Ugb25seSBuZWVkIHRvIHJlbmRlciB0aG9zZS5cbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5ub2Rlc09uUmF5KG9jdHJlZSwgcmF5KTtcbiAgICAgICAgICAgIGlmICghbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQb2ludENsb3VkT2N0cmVlUGlja2VyLnVwZGF0ZVBpY2tNYXRlcmlhbChwaWNrTWF0ZXJpYWwsIG9jdHJlZS5tYXRlcmlhbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBpY2tNYXRlcmlhbC51cGRhdGVNYXRlcmlhbChvY3RyZWUsIG5vZGVzLCBjYW1lcmEsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMub25CZWZvcmVQaWNrUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLm9uQmVmb3JlUGlja1JlbmRlcihwaWNrTWF0ZXJpYWwsIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ3JlYXRlIGNvcGllcyBvZiB0aGUgbm9kZXMgc28gd2UgY2FuIHJlbmRlciB0aGVtIGRpZmZlcmVudGx5IHRoYW4gaW4gdGhlIG5vcm1hbCBwb2ludCBjbG91ZC5cbiAgICAgICAgICAgIHBpY2tTdGF0ZS5zY2VuZS5jaGlsZHJlbiA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuY3JlYXRlVGVtcE5vZGVzKG9jdHJlZSwgbm9kZXMsIHBpY2tNYXRlcmlhbCwgcmVuZGVyZWROb2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHBpY2tTdGF0ZS5zY2VuZSwgY2FtZXJhKTtcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiByZW5kZXJlZE5vZGVzLnB1c2goeyBub2RlLCBvY3RyZWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZW5kZXJlZE5vZGVzO1xuICAgIH1cbiAgICBzdGF0aWMgbm9kZXNPblJheShvY3RyZWUsIHJheSkge1xuICAgICAgICBjb25zdCBub2Rlc09uUmF5ID0gW107XG4gICAgICAgIGNvbnN0IHJheUNsb25lID0gcmF5LmNsb25lKCk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBvY3RyZWUudmlzaWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBjb25zdCBzcGhlcmUgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclNwaGVyZVxuICAgICAgICAgICAgICAgIC5jb3B5KG5vZGUuYm91bmRpbmdTcGhlcmUpXG4gICAgICAgICAgICAgICAgLmFwcGx5TWF0cml4NChvY3RyZWUubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgaWYgKHJheUNsb25lLmludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSkge1xuICAgICAgICAgICAgICAgIG5vZGVzT25SYXkucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXNPblJheTtcbiAgICB9XG4gICAgc3RhdGljIHJlYWRQaXhlbHMocmVuZGVyZXIsIHgsIHksIHBpY2tXbmRTaXplKSB7XG4gICAgICAgIC8vIFJlYWQgdGhlIHBpeGVsIGZyb20gdGhlIHBpY2sgcmVuZGVyIHRhcmdldC5cbiAgICAgICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoNCAqIHBpY2tXbmRTaXplICogcGlja1duZFNpemUpO1xuICAgICAgICByZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLCB4LCB5LCBwaWNrV25kU2l6ZSwgcGlja1duZFNpemUsIHBpeGVscyk7XG4gICAgICAgIHJlbmRlcmVyLnNldFNjaXNzb3JUZXN0KGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIuc2V0UmVuZGVyVGFyZ2V0KG51bGwpO1xuICAgICAgICByZXR1cm4gcGl4ZWxzO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlVGVtcE5vZGVzKG9jdHJlZSwgbm9kZXMsIHBpY2tNYXRlcmlhbCwgbm9kZUluZGV4T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHRlbXBOb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBzY2VuZU5vZGUgPSBub2RlLnNjZW5lTm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBOb2RlID0gbmV3IFBvaW50cyhzY2VuZU5vZGUuZ2VvbWV0cnksIHBpY2tNYXRlcmlhbCk7XG4gICAgICAgICAgICB0ZW1wTm9kZS5tYXRyaXggPSBzY2VuZU5vZGUubWF0cml4O1xuICAgICAgICAgICAgdGVtcE5vZGUubWF0cml4V29ybGQgPSBzY2VuZU5vZGUubWF0cml4V29ybGQ7XG4gICAgICAgICAgICB0ZW1wTm9kZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wTm9kZS5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBub2RlSW5kZXhPZmZzZXQgKyBpICsgMTtcbiAgICAgICAgICAgIGlmIChub2RlSW5kZXggPiAyNTUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNb3JlIHRoYW4gMjU1IG5vZGVzIGZvciBwaWNrIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcE5vZGUub25CZWZvcmVSZW5kZXIgPSBQb2ludENsb3VkTWF0ZXJpYWwubWFrZU9uQmVmb3JlUmVuZGVyKG9jdHJlZSwgbm9kZSwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgIHRlbXBOb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVtcE5vZGVzO1xuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlUGlja01hdGVyaWFsKHBpY2tNYXRlcmlhbCwgbm9kZU1hdGVyaWFsLCBwYXJhbXMpIHtcbiAgICAgICAgcGlja01hdGVyaWFsLnBvaW50U2l6ZVR5cGUgPSBub2RlTWF0ZXJpYWwucG9pbnRTaXplVHlwZTtcbiAgICAgICAgcGlja01hdGVyaWFsLnNoYXBlID0gbm9kZU1hdGVyaWFsLnNoYXBlO1xuICAgICAgICBwaWNrTWF0ZXJpYWwuc2l6ZSA9IG5vZGVNYXRlcmlhbC5zaXplO1xuICAgICAgICBwaWNrTWF0ZXJpYWwubWluU2l6ZSA9IG5vZGVNYXRlcmlhbC5taW5TaXplO1xuICAgICAgICBwaWNrTWF0ZXJpYWwubWF4U2l6ZSA9IG5vZGVNYXRlcmlhbC5tYXhTaXplO1xuICAgICAgICBwaWNrTWF0ZXJpYWwuY2xhc3NpZmljYXRpb24gPSBub2RlTWF0ZXJpYWwuY2xhc3NpZmljYXRpb247XG4gICAgICAgIHBpY2tNYXRlcmlhbC51c2VGaWx0ZXJCeU5vcm1hbCA9IG5vZGVNYXRlcmlhbC51c2VGaWx0ZXJCeU5vcm1hbDtcbiAgICAgICAgcGlja01hdGVyaWFsLmZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkID0gbm9kZU1hdGVyaWFsLmZpbHRlckJ5Tm9ybWFsVGhyZXNob2xkO1xuICAgICAgICBpZiAocGFyYW1zLnBpY2tPdXRzaWRlQ2xpcFJlZ2lvbikge1xuICAgICAgICAgICAgcGlja01hdGVyaWFsLmNsaXBNb2RlID0gQ2xpcE1vZGUuRElTQUJMRUQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwaWNrTWF0ZXJpYWwuY2xpcE1vZGUgPSBub2RlTWF0ZXJpYWwuY2xpcE1vZGU7XG4gICAgICAgICAgICBwaWNrTWF0ZXJpYWwuc2V0Q2xpcEJveGVzKG5vZGVNYXRlcmlhbC5jbGlwTW9kZSA9PT0gQ2xpcE1vZGUuQ0xJUF9PVVRTSURFID8gbm9kZU1hdGVyaWFsLmNsaXBCb3hlcyA6IFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgdXBkYXRlUGlja1JlbmRlclRhcmdldChwaWNrU3RhdGUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQud2lkdGggPT09IHdpZHRoICYmIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcbiAgICAgICAgcGlja1N0YXRlLnJlbmRlclRhcmdldCA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIubWFrZVBpY2tSZW5kZXJUYXJnZXQoKTtcbiAgICAgICAgcGlja1N0YXRlLnJlbmRlclRhcmdldC5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICBzdGF0aWMgbWFrZVBpY2tSZW5kZXJUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoMSwgMSwge1xuICAgICAgICAgICAgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXG4gICAgICAgICAgICBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsXG4gICAgICAgICAgICBmb3JtYXQ6IFJHQkFGb3JtYXQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZEhpdChwaXhlbHMsIHBpY2tXbmRTaXplKSB7XG4gICAgICAgIGNvbnN0IGlidWZmZXIgPSBuZXcgVWludDMyQXJyYXkocGl4ZWxzLmJ1ZmZlcik7XG4gICAgICAgIC8vIEZpbmQgY2xvc2VzdCBoaXQgaW5zaWRlIHBpeGVsV2luZG93IGJvdW5kYXJpZXNcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGxldCBoaXQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHBpY2tXbmRTaXplOyB1KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHYgPSAwOyB2IDwgcGlja1duZFNpemU7IHYrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHUgKyB2ICogcGlja1duZFNpemU7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnBvdyh1IC0gKHBpY2tXbmRTaXplIC0gMSkgLyAyLCAyKSArIE1hdGgucG93KHYgLSAocGlja1duZFNpemUgLSAxKSAvIDIsIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBjSW5kZXggPSBwaXhlbHNbNCAqIG9mZnNldCArIDNdO1xuICAgICAgICAgICAgICAgIHBpeGVsc1s0ICogb2Zmc2V0ICsgM10gPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBJbmRleCA9IGlidWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBpZiAocGNJbmRleCA+IDAgJiYgZGlzdGFuY2UgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcEluZGV4OiBwSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwY0luZGV4OiBwY0luZGV4IC0gMSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQaWNrUG9pbnQoaGl0LCBub2Rlcykge1xuICAgICAgICBpZiAoIWhpdCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9pbnQgPSB7fTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbm9kZXNbaGl0LnBjSW5kZXhdICYmIG5vZGVzW2hpdC5wY0luZGV4XS5ub2RlLnNjZW5lTm9kZTtcbiAgICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50LnBvaW50Q2xvdWQgPSBub2Rlc1toaXQucGNJbmRleF0ub2N0cmVlO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gcG9pbnRzLmdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gYXR0cmlidXRlc1twcm9wZXJ0eV07XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLXN3aXRjaFxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5hZGRQb3NpdGlvblRvUGlja1BvaW50KHBvaW50LCBoaXQsIHZhbHVlcywgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgICAgIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuYWRkTm9ybWFsVG9QaWNrUG9pbnQocG9pbnQsIGhpdCwgdmFsdWVzLCBwb2ludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09ICdpbmRpY2VzJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaXRlbVNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRbcHJvcGVydHldID0gdmFsdWVzLmFycmF5W2hpdC5wSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMuaXRlbVNpemU7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaCh2YWx1ZXMuYXJyYXlbdmFsdWVzLml0ZW1TaXplICogaGl0LnBJbmRleCArIGpdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzdGF0aWMgYWRkUG9zaXRpb25Ub1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cykge1xuICAgICAgICBwb2ludC5wb3NpdGlvbiA9IG5ldyBWZWN0b3IzKClcbiAgICAgICAgICAgIC5mcm9tQnVmZmVyQXR0cmlidXRlKHZhbHVlcywgaGl0LnBJbmRleClcbiAgICAgICAgICAgIC5hcHBseU1hdHJpeDQocG9pbnRzLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgc3RhdGljIGFkZE5vcm1hbFRvUGlja1BvaW50KHBvaW50LCBoaXQsIHZhbHVlcywgcG9pbnRzKSB7XG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh2YWx1ZXMsIGhpdC5wSW5kZXgpO1xuICAgICAgICBjb25zdCBub3JtYWw0ID0gbmV3IFZlY3RvcjQobm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiwgMCkuYXBwbHlNYXRyaXg0KHBvaW50cy5tYXRyaXhXb3JsZCk7XG4gICAgICAgIG5vcm1hbC5zZXQobm9ybWFsNC54LCBub3JtYWw0LnksIG5vcm1hbDQueik7XG4gICAgICAgIHBvaW50Lm5vcm1hbCA9IG5vcm1hbDtcbiAgICB9XG4gICAgc3RhdGljIGdldFBpY2tTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKTtcbiAgICAgICAgc2NlbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBQb2ludENsb3VkTWF0ZXJpYWwoKTtcbiAgICAgICAgbWF0ZXJpYWwucG9pbnRDb2xvclR5cGUgPSBQb2ludENvbG9yVHlwZS5QT0lOVF9JTkRFWDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlbmRlclRhcmdldDogUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5tYWtlUGlja1JlbmRlclRhcmdldCgpLFxuICAgICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxuICAgICAgICAgICAgc2NlbmU6IHNjZW5lLFxuICAgICAgICB9O1xuICAgIH1cbn1cblBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuaGVscGVyVmVjMyA9IG5ldyBWZWN0b3IzKCk7XG5Qb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcblBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuY2xlYXJDb2xvciA9IG5ldyBDb2xvcigpO1xuIiwiaW1wb3J0IHsgU3BoZXJlIH0gZnJvbSAndGhyZWUnO1xuZXhwb3J0IGNsYXNzIE9jdHJlZUdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2FkZXIsIGJvdW5kaW5nQm94KSB7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbG9hZGVyO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMubWF4TnVtTm9kZXNMb2FkaW5nID0gMztcbiAgICAgICAgdGhpcy5udW1Ob2Rlc0xvYWRpbmcgPSAwO1xuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvaW50QXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XG4gICAgICAgIHRoaXMudXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5ib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLnRpZ2h0Qm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMucm9vdC50cmF2ZXJzZSgobm9kZSkgPT4gbm9kZS5kaXNwb3NlKCkpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gdHJ1ZTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPYmplY3QzRCB9IGZyb20gJ3RocmVlJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkVHJlZSBleHRlbmRzIE9iamVjdDNEIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QgIT09IG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQm94MywgT2JqZWN0M0QsIFBvaW50cywgU3BoZXJlLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgREVGQVVMVF9NSU5fTk9ERV9QSVhFTF9TSVpFIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgT2N0cmVlR2VvbWV0cnkgfSBmcm9tICcuL2xvYWRpbmcyL29jdHJlZS1nZW9tZXRyeSc7XG5pbXBvcnQgeyBQb2ludENsb3VkTWF0ZXJpYWwgfSBmcm9tICcuL21hdGVyaWFscyc7XG5pbXBvcnQgeyBQb2ludENsb3VkT2N0cmVlTm9kZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLW5vZGUnO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZVBpY2tlciB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XG5pbXBvcnQgeyBQb2ludENsb3VkVHJlZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtdHJlZSc7XG5pbXBvcnQgeyBjb21wdXRlVHJhbnNmb3JtZWRCb3VuZGluZ0JveCB9IGZyb20gJy4vdXRpbHMvYm91bmRzJztcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlIGV4dGVuZHMgUG9pbnRDbG91ZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKHBvdHJlZSwgcGNvR2VvbWV0cnksIG1hdGVyaWFsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XG4gICAgICAgIHRoaXMubWF4TGV2ZWwgPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHJhZGl1cyBvZiBhIG5vZGUncyBib3VuZGluZyBzcGhlcmUgb24gdGhlIHNjcmVlbiBpbiBvcmRlciB0byBiZSBkaXNwbGF5ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pbk5vZGVQaXhlbFNpemUgPSBERUZBVUxUX01JTl9OT0RFX1BJWEVMX1NJWkU7XG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3hOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVHZW9tZXRyeSA9IFtdO1xuICAgICAgICB0aGlzLm51bVZpc2libGVQb2ludHMgPSAwO1xuICAgICAgICB0aGlzLnNob3dCb3VuZGluZ0JveCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpc2libGVCb3VuZHMgPSBuZXcgQm94MygpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5wb3RyZWUgPSBwb3RyZWU7XG4gICAgICAgIHRoaXMucm9vdCA9IHBjb0dlb21ldHJ5LnJvb3Q7XG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkgPSBwY29HZW9tZXRyeTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IHBjb0dlb21ldHJ5LmJvdW5kaW5nQm94O1xuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkocGNvR2VvbWV0cnkub2Zmc2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsIHx8IHBjb0dlb21ldHJ5IGluc3RhbmNlb2YgT2N0cmVlR2VvbWV0cnkgPyBuZXcgUG9pbnRDbG91ZE1hdGVyaWFsKHsgY29sb3JSZ2JhOiB0cnVlIH0pIDogbmV3IFBvaW50Q2xvdWRNYXRlcmlhbCgpO1xuICAgICAgICB0aGlzLmluaXRNYXRlcmlhbCh0aGlzLm1hdGVyaWFsKTtcbiAgICB9XG4gICAgaW5pdE1hdGVyaWFsKG1hdGVyaWFsKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQodHJ1ZSk7XG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KHRoaXMucGNvR2VvbWV0cnkudGlnaHRCb3VuZGluZ0JveCB8fCB0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKSwgdGhpcy5tYXRyaXhXb3JsZCk7XG4gICAgICAgIGNvbnN0IGJXaWR0aCA9IG1heC56IC0gbWluLno7XG4gICAgICAgIG1hdGVyaWFsLmhlaWdodE1pbiA9IG1pbi56IC0gMC4yICogYldpZHRoO1xuICAgICAgICBtYXRlcmlhbC5oZWlnaHRNYXggPSBtYXgueiArIDAuMiAqIGJXaWR0aDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5yb290LmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5LnJvb3QudHJhdmVyc2UobiA9PiB0aGlzLnBvdHJlZS5scnUucmVtb3ZlKG4pKTtcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnZpc2libGVHZW9tZXRyeSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgcG9pbnRTaXplVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwucG9pbnRTaXplVHlwZTtcbiAgICB9XG4gICAgc2V0IHBvaW50U2l6ZVR5cGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5wb2ludFNpemVUeXBlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvVHJlZU5vZGUoZ2VvbWV0cnlOb2RlLCBwYXJlbnQpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IFBvaW50cyhnZW9tZXRyeU5vZGUuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFBvaW50Q2xvdWRPY3RyZWVOb2RlKGdlb21ldHJ5Tm9kZSwgcG9pbnRzKTtcbiAgICAgICAgcG9pbnRzLm5hbWUgPSBnZW9tZXRyeU5vZGUubmFtZTtcbiAgICAgICAgcG9pbnRzLnBvc2l0aW9uLmNvcHkoZ2VvbWV0cnlOb2RlLmJvdW5kaW5nQm94Lm1pbik7XG4gICAgICAgIHBvaW50cy5mcnVzdHVtQ3VsbGVkID0gZmFsc2U7XG4gICAgICAgIHBvaW50cy5vbkJlZm9yZVJlbmRlciA9IFBvaW50Q2xvdWRNYXRlcmlhbC5tYWtlT25CZWZvcmVSZW5kZXIodGhpcywgbm9kZSk7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5zY2VuZU5vZGUuYWRkKHBvaW50cyk7XG4gICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5bZ2VvbWV0cnlOb2RlLmluZGV4XSA9IG5vZGU7XG4gICAgICAgICAgICBnZW9tZXRyeU5vZGUub25lVGltZURpc3Bvc2VIYW5kbGVycy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLmRpc3Bvc2VTY2VuZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuc2NlbmVOb2RlLnJlbW92ZShub2RlLnNjZW5lTm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdHJlZSBub2RlIChyZW5kZXJlZCBhbmQgaW4gdGhlIEdQVSkgd2l0aCB0aGUgZ2VvbWV0cnkgbm9kZS5cbiAgICAgICAgICAgICAgICBwYXJlbnQuY2hpbGRyZW5bZ2VvbWV0cnlOb2RlLmluZGV4XSA9IGdlb21ldHJ5Tm9kZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuYWRkKHBvaW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHVwZGF0ZVZpc2libGVCb3VuZHMoKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMudmlzaWJsZUJvdW5kcztcbiAgICAgICAgYm91bmRzLm1pbi5zZXQoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XG4gICAgICAgIGJvdW5kcy5tYXguc2V0KC1JbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy52aXNpYmxlTm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZk5vZGUpIHtcbiAgICAgICAgICAgICAgICBib3VuZHMuZXhwYW5kQnlQb2ludChub2RlLmJvdW5kaW5nQm94Lm1pbik7XG4gICAgICAgICAgICAgICAgYm91bmRzLmV4cGFuZEJ5UG9pbnQobm9kZS5ib3VuZGluZ0JveC5tYXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUJvdW5kaW5nQm94ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaG93Qm91bmRpbmdCb3ggfHwgIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJiUm9vdCA9IHRoaXMucGFyZW50LmdldE9iamVjdEJ5TmFtZSgnYmJyb290Jyk7XG4gICAgICAgIGlmICghYmJSb290KSB7XG4gICAgICAgICAgICBiYlJvb3QgPSBuZXcgT2JqZWN0M0QoKTtcbiAgICAgICAgICAgIGJiUm9vdC5uYW1lID0gJ2Jicm9vdCc7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGQoYmJSb290KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlQm94ZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudmlzaWJsZU5vZGVzKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZGluZ0JveE5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlzTGVhZk5vZGUpIHtcbiAgICAgICAgICAgICAgICB2aXNpYmxlQm94ZXMucHVzaChub2RlLmJvdW5kaW5nQm94Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmJSb290LmNoaWxkcmVuID0gdmlzaWJsZUJveGVzO1xuICAgIH1cbiAgICB1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xuICAgICAgICBpZiAodGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPT09IHRydWUgfHwgZm9yY2UgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlRGVzY2VuZGFudHMob2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHRvSGlkZSA9IFtdO1xuICAgICAgICBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqZWN0KTtcbiAgICAgICAgd2hpbGUgKHRvSGlkZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpUb0hpZGUgPSB0b0hpZGUuc2hpZnQoKTtcbiAgICAgICAgICAgIG9ialRvSGlkZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqVG9IaWRlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9iai5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvSGlkZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW92ZVRvT3JpZ2luKCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnNldCgwLCAwLCAwKTsgLy8gUmVzZXQsIHRoZW4gdGhlIG1hdHJpeCB3aWxsIGJlIHVwZGF0ZWQgaW4gZ2V0Qm91bmRpbmdCb3hXb3JsZCgpXG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KDAsIDAsIDApLnN1Yih0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5nZXRDZW50ZXIobmV3IFZlY3RvcjMoKSkpO1xuICAgIH1cbiAgICBtb3ZlVG9Hcm91bmRQbGFuZSgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ICs9IC10aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5taW4ueTtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3hXb3JsZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3gsIHRoaXMubWF0cml4V29ybGQpO1xuICAgIH1cbiAgICBnZXRWaXNpYmxlRXh0ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQm91bmRzLmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICB9XG4gICAgcGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucGlja2VyID0gdGhpcy5waWNrZXIgfHwgbmV3IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyLnBpY2socmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBbdGhpc10sIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldCBwcm9ncmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUdlb21ldHJ5Lmxlbmd0aCA9PT0gMFxuICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICA6IHRoaXMudmlzaWJsZU5vZGVzLmxlbmd0aCAvIHRoaXMudmlzaWJsZUdlb21ldHJ5Lmxlbmd0aDtcbiAgICB9XG59XG4iLCJjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbmNvbnN0IGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJyk7XG5leHBvcnQgY29uc3QgRkVBVFVSRVMgPSB7XG4gICAgU0hBREVSX0lOVEVSUE9MQVRJT046IGhhc0V4dGVuc2lvbignRVhUX2ZyYWdfZGVwdGgnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcbiAgICBTSEFERVJfU1BMQVRTOiBoYXNFeHRlbnNpb24oJ0VYVF9mcmFnX2RlcHRoJykgJiYgaGFzRXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpICYmIGhhc01pblZhcnlpbmdWZWN0b3JzKDgpLFxuICAgIFNIQURFUl9FREw6IGhhc0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcbiAgICBwcmVjaXNpb246IGdldFByZWNpc2lvbigpLFxufTtcbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihleHQpIHtcbiAgICByZXR1cm4gZ2wgIT09IG51bGwgJiYgQm9vbGVhbihnbC5nZXRFeHRlbnNpb24oZXh0KSk7XG59XG5mdW5jdGlvbiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyh2YWx1ZSkge1xuICAgIHJldHVybiBnbCAhPT0gbnVsbCAmJiBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1ZBUllJTkdfVkVDVE9SUykgPj0gdmFsdWU7XG59XG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oKSB7XG4gICAgaWYgKGdsID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3QgdnNIaWdocEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpO1xuICAgIGNvbnN0IHZzTWVkaXVtcEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XG4gICAgY29uc3QgZnNIaWdocEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCk7XG4gICAgY29uc3QgZnNNZWRpdW1wRmxvYXQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpO1xuICAgIGNvbnN0IGhpZ2hwQXZhaWxhYmxlID0gdnNIaWdocEZsb2F0ICYmIGZzSGlnaHBGbG9hdCAmJiB2c0hpZ2hwRmxvYXQucHJlY2lzaW9uID4gMCAmJiBmc0hpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcbiAgICBjb25zdCBtZWRpdW1wQXZhaWxhYmxlID0gdnNNZWRpdW1wRmxvYXQgJiZcbiAgICAgICAgZnNNZWRpdW1wRmxvYXQgJiZcbiAgICAgICAgdnNNZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMCAmJlxuICAgICAgICBmc01lZGl1bXBGbG9hdC5wcmVjaXNpb24gPiAwO1xuICAgIHJldHVybiBoaWdocEF2YWlsYWJsZSA/ICdoaWdocCcgOiBtZWRpdW1wQXZhaWxhYmxlID8gJ21lZGl1bXAnIDogJ2xvd3AnO1xufVxuIiwiZXhwb3J0IGNsYXNzIEFzeW5jQmxvY2tpbmdRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZXJzID0gW107XG4gICAgICAgIHRoaXMucHJvbWlzZXMgPSBbXTtcbiAgICB9XG4gICAgZW5xdWV1ZSh0KSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlc29sdmVycy5zaGlmdCgpO1xuICAgICAgICByZXNvbHZlKHQpO1xuICAgIH1cbiAgICBkZXF1ZXVlKCkge1xuICAgICAgICBpZiAoIXRoaXMucHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmFkZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2VzLnNoaWZ0KCk7XG4gICAgfVxuICAgIGFkZCgpIHtcbiAgICAgICAgdGhpcy5wcm9taXNlcy5wdXNoKG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlcnMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEFzeW5jQmxvY2tpbmdRdWV1ZSB9IGZyb20gJy4vYXN5bmMtYmxvY2tpbmctcXVldWUnO1xuZXhwb3J0IGNsYXNzIEF1dG9UZXJtaW5hdGluZ1dvcmtlciB7XG4gICAgY29uc3RydWN0b3Iod3JhcHBlZFdvcmtlciwgbWF4SWRsZSkge1xuICAgICAgICB0aGlzLndyYXBwZWRXb3JrZXIgPSB3cmFwcGVkV29ya2VyO1xuICAgICAgICB0aGlzLm1heElkbGUgPSBtYXhJZGxlO1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB3b3JrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZWRXb3JrZXI7XG4gICAgfVxuICAgIGdldCBpc1Rlcm1pbmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZWQ7XG4gICAgfVxuICAgIG1hcmtJZGxlKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGVybWluYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLndyYXBwZWRXb3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH0sIHRoaXMubWF4SWRsZSk7XG4gICAgfVxuICAgIG1hcmtJblVzZSgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXb3JrZXJQb29sIHtcbiAgICBjb25zdHJ1Y3RvcihtYXhXb3JrZXJzLCB3b3JrZXJUeXBlKSB7XG4gICAgICAgIHRoaXMubWF4V29ya2VycyA9IG1heFdvcmtlcnM7XG4gICAgICAgIHRoaXMud29ya2VyVHlwZSA9IHdvcmtlclR5cGU7XG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBBc3luY0Jsb2NraW5nUXVldWUoKTtcbiAgICAgICAgdGhpcy5wb29sU2l6ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB3b3JrZXIgcHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZCB3aGVuIG9uZSBpcyBhdmFpbGFibGUuXG4gICAgICovXG4gICAgZ2V0V29ya2VyKCkge1xuICAgICAgICAvLyBJZiB0aGUgbnVtYmVyIG9mIGFjdGl2ZSB3b3JrZXJzIGlzIHNtYWxsZXIgdGhhbiB0aGUgbWF4aW11bSwgcmV0dXJuIGEgbmV3IG9uZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gYSBwcm9taXNlIGZvciB3b3JrZXIgZnJvbSB0aGUgcG9vbC5cbiAgICAgICAgaWYgKHRoaXMucG9vbFNpemUgPCB0aGlzLm1heFdvcmtlcnMpIHtcbiAgICAgICAgICAgIHRoaXMucG9vbFNpemUrKztcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEF1dG9UZXJtaW5hdGluZ1dvcmtlcihuZXcgdGhpcy53b3JrZXJUeXBlKCksIFdvcmtlclBvb2wuUE9PTF9NQVhfSURMRSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9vbC5kZXF1ZXVlKCkudGhlbih3b3JrZXIgPT4ge1xuICAgICAgICAgICAgICAgIHdvcmtlci5tYXJrSW5Vc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGVxdWV1ZWQgd29ya2VyIGhhcyBiZWVuIHRlcm1pbmF0ZWQsIGRlY3JlYXNlIHRoZSBwb29sIHNpemUgYW5kIG1ha2UgYSByZWN1cnNpdmUgY2FsbCB0byBnZXQgYSBuZXcgd29ya2VyXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtlci5pc1Rlcm1pbmF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sU2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRXb3JrZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIGEgV29ya2VyIGJhY2sgaW50byB0aGUgcG9vbFxuICAgICAqIEBwYXJhbSB3b3JrZXJcbiAgICAgKi9cbiAgICByZWxlYXNlV29ya2VyKHdvcmtlcikge1xuICAgICAgICB3b3JrZXIubWFya0lkbGUoKTtcbiAgICAgICAgdGhpcy5wb29sLmVucXVldWUod29ya2VyKTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiBpZGxlIHRpbWUgdGhhdCBjYW4gZWxhcHNlIGJlZm9yZSBhIHdvcmtlciBmcm9tIHRoaXMgcG9vbCBpcyBhdXRvbWF0aWNhbGx5IHRlcm1pbmF0ZWRcbiAqL1xuV29ya2VyUG9vbC5QT09MX01BWF9JRExFID0gNzAwMDtcbiIsImV4cG9ydCBjbGFzcyBWZXJzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMudmVyc2lvbk1pbm9yID0gMDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgY29uc3Qgdm1MZW5ndGggPSB2ZXJzaW9uLmluZGV4T2YoJy4nKSA9PT0gLTEgPyB2ZXJzaW9uLmxlbmd0aCA6IHZlcnNpb24uaW5kZXhPZignLicpO1xuICAgICAgICB0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSwgMTApO1xuICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKHZtTGVuZ3RoICsgMSksIDEwKTtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMudmVyc2lvbk1pbm9yKSkge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld2VyVGhhbih2ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVmVyc2lvbih2ZXJzaW9uKTtcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+IHYudmVyc2lvbk1pbm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcXVhbE9ySGlnaGVyKHZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cFRvKHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5ld2VyVGhhbih2ZXJzaW9uKTtcbiAgICB9XG59XG4iLCIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbXBvcnQgeyBCb3gzLCBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBVaW50OEJ1ZmZlckF0dHJpYnV0ZSwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFBvaW50QXR0cmlidXRlTmFtZSB9IGZyb20gJy4uL3BvaW50LWF0dHJpYnV0ZXMnO1xuaW1wb3J0IHsgaGFuZGxlRW1wdHlCdWZmZXIsIGhhbmRsZUZhaWxlZFJlcXVlc3QgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5pbXBvcnQgeyBXb3JrZXJQb29sIH0gZnJvbSAnLi4vdXRpbHMvd29ya2VyLXBvb2wnO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuZXhwb3J0IGNsYXNzIEJpbmFyeUxvYWRlciB7XG4gICAgY29uc3RydWN0b3IoeyBnZXRVcmwgPSBzID0+IFByb21pc2UucmVzb2x2ZShzKSwgdmVyc2lvbiwgYm91bmRpbmdCb3gsIHNjYWxlLCB4aHJSZXF1ZXN0LCB9KSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gbmV3IFZlcnNpb24odmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyUmVxdWVzdCA9IHhoclJlcXVlc3Q7XG4gICAgICAgIHRoaXMuZ2V0VXJsID0gZ2V0VXJsO1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfVxuICAgIGxvYWQobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5sb2FkZWQgfHwgdGhpcy5kaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5nZXRVcmwodGhpcy5nZXROb2RlVXJsKG5vZGUpKSlcbiAgICAgICAgICAgIC50aGVuKHVybCA9PiB0aGlzLnhoclJlcXVlc3QodXJsLCB7IG1vZGU6ICdjb3JzJyB9KSlcbiAgICAgICAgICAgIC50aGVuKHJlcyA9PiBoYW5kbGVGYWlsZWRSZXF1ZXN0KHJlcykpXG4gICAgICAgICAgICAudGhlbihva1JlcyA9PiBva1Jlcy5hcnJheUJ1ZmZlcigpKVxuICAgICAgICAgICAgLnRoZW4oYnVmZmVyID0+IGhhbmRsZUVtcHR5QnVmZmVyKGJ1ZmZlcikpXG4gICAgICAgICAgICAudGhlbihva0J1ZmZlciA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB0aGlzLnBhcnNlKG5vZGUsIG9rQnVmZmVyLCByZXNvbHZlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROb2RlVXJsKG5vZGUpIHtcbiAgICAgICAgbGV0IHVybCA9IG5vZGUuZ2V0VXJsKCk7XG4gICAgICAgIGlmICh0aGlzLnZlcnNpb24uZXF1YWxPckhpZ2hlcignMS40JykpIHtcbiAgICAgICAgICAgIHVybCArPSAnLmJpbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcGFyc2Uobm9kZSwgYnVmZmVyLCByZXNvbHZlKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLmdldFdvcmtlcigpLnRoZW4oYXV0b1Rlcm1pbmF0aW5nV29ya2VyID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlcyA9IG5vZGUucGNvR2VvbWV0cnkucG9pbnRBdHRyaWJ1dGVzO1xuICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gYnVmZmVyLmJ5dGVMZW5ndGggLyBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy52ZXJzaW9uLnVwVG8oJzEuNScpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvVGVybWluYXRpbmdXb3JrZXIud29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBCaW5hcnlMb2FkZXIuV09SS0VSX1BPT0wucmVsZWFzZVdvcmtlcihhdXRvVGVybWluYXRpbmdXb3JrZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSAobm9kZS5nZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnkgfHwgbmV3IEJ1ZmZlckdlb21ldHJ5KCkpO1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LmJvdW5kaW5nQm94ID0gbm9kZS5ib3VuZGluZ0JveDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJ1ZmZlckF0dHJpYnV0ZXMoZ2VvbWV0cnksIGRhdGEuYXR0cmlidXRlQnVmZmVycyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmRpY2VzKGdlb21ldHJ5LCBkYXRhLmluZGljZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTm9ybWFsQXR0cmlidXRlKGdlb21ldHJ5LCBudW1Qb2ludHMpO1xuICAgICAgICAgICAgICAgIG5vZGUubWVhbiA9IG5ldyBWZWN0b3IzKCkuZnJvbUFycmF5KGRhdGEubWVhbik7XG4gICAgICAgICAgICAgICAgbm9kZS50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5nZXRUaWdodEJvdW5kaW5nQm94KGRhdGEudGlnaHRCb3VuZGluZ0JveCk7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuZmFpbGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5wY29HZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcbiAgICAgICAgICAgICAgICBub2RlLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKG5vZGUpKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLnJlbGVhc2VXb3JrZXIoYXV0b1Rlcm1pbmF0aW5nV29ya2VyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLnZlcnNpb24sXG4gICAgICAgICAgICAgICAgbWluOiBub2RlLmJvdW5kaW5nQm94Lm1pbi50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBub2RlLnBjb0dlb21ldHJ5Lm9mZnNldC50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAgICAgICAgICAgc3BhY2luZzogbm9kZS5zcGFjaW5nLFxuICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBub2RlLmhhc0NoaWxkcmVuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF1dG9UZXJtaW5hdGluZ1dvcmtlci53b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSwgW21lc3NhZ2UuYnVmZmVyXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRUaWdodEJvdW5kaW5nQm94KHsgbWluLCBtYXggfSkge1xuICAgICAgICBjb25zdCBib3ggPSBuZXcgQm94MyhuZXcgVmVjdG9yMygpLmZyb21BcnJheShtaW4pLCBuZXcgVmVjdG9yMygpLmZyb21BcnJheShtYXgpKTtcbiAgICAgICAgYm94Lm1heC5zdWIoYm94Lm1pbik7XG4gICAgICAgIGJveC5taW4uc2V0KDAsIDAsIDApO1xuICAgICAgICByZXR1cm4gYm94O1xuICAgIH1cbiAgICBhZGRCdWZmZXJBdHRyaWJ1dGVzKGdlb21ldHJ5LCBidWZmZXJzKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlcnMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1twcm9wZXJ0eV0uYnVmZmVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5QT1NJVElPTl9DQVJURVNJQU4pKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VEKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDMsIHRydWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5JTlRFTlNJVFkpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbnRlbnNpdHknLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dHJpYnV0ZShwcm9wZXJ0eSwgUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY2xhc3NpZmljYXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfU1BIRVJFTUFQUEVEKSkge1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYpKSB7XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dHJpYnV0ZShwcm9wZXJ0eSwgUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCkpIHtcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhZGRJbmRpY2VzKGdlb21ldHJ5LCBpbmRpY2VzKSB7XG4gICAgICAgIGNvbnN0IGluZGljZXNBdHRyaWJ1dGUgPSBuZXcgVWludDhCdWZmZXJBdHRyaWJ1dGUoaW5kaWNlcywgNCk7XG4gICAgICAgIGluZGljZXNBdHRyaWJ1dGUubm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnaW5kaWNlcycsIGluZGljZXNBdHRyaWJ1dGUpO1xuICAgIH1cbiAgICBhZGROb3JtYWxBdHRyaWJ1dGUoZ2VvbWV0cnksIG51bVBvaW50cykge1xuICAgICAgICBpZiAoIWdlb21ldHJ5LmdldEF0dHJpYnV0ZSgnbm9ybWFsJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBGbG9hdDMyQXJyYXkobnVtUG9pbnRzICogMyk7XG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNBdHRyaWJ1dGUocHJvcGVydHksIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHByb3BlcnR5LCAxMCkgPT09IG5hbWU7XG4gICAgfVxufVxuQmluYXJ5TG9hZGVyLldPUktFUl9QT09MID0gbmV3IFdvcmtlclBvb2woMzIsIHJlcXVpcmUoJy4uL3dvcmtlcnMvYmluYXJ5LWRlY29kZXIud29ya2VyLmpzJykuZGVmYXVsdCk7XG4iLCIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5pbXBvcnQgeyBCb3gzLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgUG9pbnRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vcG9pbnQtYXR0cmlidXRlcyc7XG5pbXBvcnQgeyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkgfSBmcm9tICcuLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnknO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZSB9IGZyb20gJy4uL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeS1ub2RlJztcbmltcG9ydCB7IGNyZWF0ZUNoaWxkQUFCQiB9IGZyb20gJy4uL3V0aWxzL2JvdW5kcyc7XG5pbXBvcnQgeyBnZXRJbmRleEZyb21OYW1lLCBoYW5kbGVGYWlsZWRSZXF1ZXN0IH0gZnJvbSAnLi4vdXRpbHMvdXRpbHMnO1xuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xuaW1wb3J0IHsgQmluYXJ5TG9hZGVyIH0gZnJvbSAnLi9iaW5hcnktbG9hZGVyJztcbi8qKlxuICpcbiAqIEBwYXJhbSB1cmxcbiAqICAgIFRoZSB1cmwgb2YgdGhlIHBvaW50IGNsb3VkIGZpbGUgKHVzdWFsbHkgY2xvdWQuanMpLlxuICogQHBhcmFtIGdldFVybFxuICogICAgRnVuY3Rpb24gd2hpY2ggcmVjZWl2ZXMgdGhlIHJlbGF0aXZlIFVSTCBvZiBhIHBvaW50IGNsb3VkIGNodW5rIGZpbGUgd2hpY2ggaXMgdG8gYmUgbG9hZGVkXG4gKiAgICBhbmQgc2hvdWQgcmV0dXJuIGEgbmV3IHVybCAoZS5nLiBzaWduZWQpIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIG9yIGEgcHJvbWlzZS5cbiAqIEBwYXJhbSB4aHJSZXF1ZXN0IEFuIGFycm93IGZ1bmN0aW9uIGZvciBhIGZldGNoIHJlcXVlc3RcbiAqIEByZXR1cm5zXG4gKiAgICBBbiBvYnNlcnZhYmxlIHdoaWNoIGVtaXRzIG9uY2Ugd2hlbiB0aGUgZmlyc3QgTE9EIG9mIHRoZSBwb2ludCBjbG91ZCBpcyBsb2FkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkUE9DKHVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShnZXRVcmwodXJsKSkudGhlbih0cmFuc2Zvcm1lZFVybCA9PiB7XG4gICAgICAgIHJldHVybiB4aHJSZXF1ZXN0KHRyYW5zZm9ybWVkVXJsLCB7IG1vZGU6ICdjb3JzJyB9KVxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzKSlcbiAgICAgICAgICAgIC50aGVuKG9rUmVzID0+IG9rUmVzLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKHBhcnNlKHRyYW5zZm9ybWVkVXJsLCBnZXRVcmwsIHhoclJlcXVlc3QpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlKHVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0LCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCB9ID0gZ2V0Qm91bmRpbmdCb3hlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gbmV3IEJpbmFyeUxvYWRlcih7XG4gICAgICAgICAgICBnZXRVcmwsXG4gICAgICAgICAgICB2ZXJzaW9uOiBkYXRhLnZlcnNpb24sXG4gICAgICAgICAgICBib3VuZGluZ0JveCxcbiAgICAgICAgICAgIHNjYWxlOiBkYXRhLnNjYWxlLFxuICAgICAgICAgICAgeGhyUmVxdWVzdCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBjbyA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkobG9hZGVyLCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCwgb2Zmc2V0LCB4aHJSZXF1ZXN0KTtcbiAgICAgICAgcGNvLnVybCA9IHVybDtcbiAgICAgICAgcGNvLm9jdHJlZURpciA9IGRhdGEub2N0cmVlRGlyO1xuICAgICAgICBwY28ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBwY28uc3BhY2luZyA9IGRhdGEuc3BhY2luZztcbiAgICAgICAgcGNvLmhpZXJhcmNoeVN0ZXBTaXplID0gZGF0YS5oaWVyYXJjaHlTdGVwU2l6ZTtcbiAgICAgICAgcGNvLnByb2plY3Rpb24gPSBkYXRhLnByb2plY3Rpb247XG4gICAgICAgIHBjby5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHBjby5wb2ludEF0dHJpYnV0ZXMgPSBuZXcgUG9pbnRBdHRyaWJ1dGVzKGRhdGEucG9pbnRBdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IG5ldyBWZXJzaW9uKGRhdGEudmVyc2lvbik7XG4gICAgICAgIHJldHVybiBsb2FkUm9vdChwY28sIGRhdGEsIG5vZGVzLCB2ZXJzaW9uKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLnVwVG8oJzEuNCcpKSB7XG4gICAgICAgICAgICAgICAgbG9hZFJlbWFpbmluZ0hpZXJhcmNoeShwY28sIGRhdGEsIG5vZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjby5ub2RlcyA9IG5vZGVzO1xuICAgICAgICAgICAgcmV0dXJuIHBjbztcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQm94ZXMoZGF0YSkge1xuICAgIGNvbnN0IG1pbiA9IG5ldyBWZWN0b3IzKGRhdGEuYm91bmRpbmdCb3gubHgsIGRhdGEuYm91bmRpbmdCb3gubHksIGRhdGEuYm91bmRpbmdCb3gubHopO1xuICAgIGNvbnN0IG1heCA9IG5ldyBWZWN0b3IzKGRhdGEuYm91bmRpbmdCb3gudXgsIGRhdGEuYm91bmRpbmdCb3gudXksIGRhdGEuYm91bmRpbmdCb3gudXopO1xuICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gbmV3IEJveDMobWluLCBtYXgpO1xuICAgIGNvbnN0IHRpZ2h0Qm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IG1pbi5jbG9uZSgpO1xuICAgIGlmIChkYXRhLnRpZ2h0Qm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3QgeyBseCwgbHksIGx6LCB1eCwgdXksIHV6IH0gPSBkYXRhLnRpZ2h0Qm91bmRpbmdCb3g7XG4gICAgICAgIHRpZ2h0Qm91bmRpbmdCb3gubWluLnNldChseCwgbHksIGx6KTtcbiAgICAgICAgdGlnaHRCb3VuZGluZ0JveC5tYXguc2V0KHV4LCB1eSwgdXopO1xuICAgIH1cbiAgICBib3VuZGluZ0JveC5taW4uc3ViKG9mZnNldCk7XG4gICAgYm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgIHRpZ2h0Qm91bmRpbmdCb3gubWluLnN1YihvZmZzZXQpO1xuICAgIHRpZ2h0Qm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgIHJldHVybiB7IG9mZnNldCwgYm91bmRpbmdCb3gsIHRpZ2h0Qm91bmRpbmdCb3ggfTtcbn1cbmZ1bmN0aW9uIGxvYWRSb290KHBjbywgZGF0YSwgbm9kZXMsIHZlcnNpb24pIHtcbiAgICBjb25zdCBuYW1lID0gJ3InO1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZShuYW1lLCBwY28sIHBjby5ib3VuZGluZ0JveCk7XG4gICAgcm9vdC5oYXNDaGlsZHJlbiA9IHRydWU7XG4gICAgcm9vdC5zcGFjaW5nID0gcGNvLnNwYWNpbmc7XG4gICAgaWYgKHZlcnNpb24udXBUbygnMS41JykpIHtcbiAgICAgICAgcm9vdC5udW1Qb2ludHMgPSBkYXRhLmhpZXJhcmNoeVswXVsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJvb3QubnVtUG9pbnRzID0gMDtcbiAgICB9XG4gICAgcGNvLnJvb3QgPSByb290O1xuICAgIG5vZGVzW25hbWVdID0gcm9vdDtcbiAgICByZXR1cm4gcGNvLnJvb3QubG9hZCgpO1xufVxuZnVuY3Rpb24gbG9hZFJlbWFpbmluZ0hpZXJhcmNoeShwY28sIGRhdGEsIG5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbbmFtZSwgbnVtUG9pbnRzXSA9IGRhdGEuaGllcmFyY2h5W2ldO1xuICAgICAgICBjb25zdCB7IGluZGV4LCBwYXJlbnROYW1lLCBsZXZlbCB9ID0gcGFyc2VOYW1lKG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZXNbcGFyZW50TmFtZV07XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gY3JlYXRlQ2hpbGRBQUJCKHBhcmVudE5vZGUuYm91bmRpbmdCb3gsIGluZGV4KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlKG5hbWUsIHBjbywgYm91bmRpbmdCb3gpO1xuICAgICAgICBub2RlLmxldmVsID0gbGV2ZWw7XG4gICAgICAgIG5vZGUubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xuICAgICAgICBub2RlLnNwYWNpbmcgPSBwY28uc3BhY2luZyAvIE1hdGgucG93KDIsIG5vZGUubGV2ZWwpO1xuICAgICAgICBub2Rlc1tuYW1lXSA9IG5vZGU7XG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbmRleDogZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSxcbiAgICAgICAgcGFyZW50TmFtZTogbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKSxcbiAgICAgICAgbGV2ZWw6IG5hbWUubGVuZ3RoIC0gMSxcbiAgICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9iaW5hcnktbG9hZGVyJztcbmV4cG9ydCAqIGZyb20gJy4vbG9hZC1wb2MnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG4iLCJpbXBvcnQgeyBTcGhlcmUgfSBmcm9tICd0aHJlZSc7XG5leHBvcnQgY2xhc3MgT2N0cmVlR2VvbWV0cnlOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvY3RyZWVHZW9tZXRyeSwgYm91bmRpbmdCb3gpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5vY3RyZWVHZW9tZXRyeSA9IG9jdHJlZUdlb21ldHJ5O1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNMZWFmTm9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNUcmVlTm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuaWQgPSBPY3RyZWVHZW9tZXRyeU5vZGUuSURDb3VudCsrO1xuICAgICAgICB0aGlzLmluZGV4ID0gcGFyc2VJbnQobmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xuICAgICAgICB0aGlzLnRpZ2h0Qm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgICB0aGlzLm51bVBvaW50cyA9IDA7XG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xuICAgIH1cbiAgICBnZXRMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGV2ZWw7XG4gICAgfVxuICAgIGlzTG9hZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZWQ7XG4gICAgfVxuICAgIGdldEJvdW5kaW5nU3BoZXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZGluZ1NwaGVyZTtcbiAgICB9XG4gICAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBsb2FkKCkge1xuICAgICAgICBpZiAodGhpcy5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcgPj0gdGhpcy5vY3RyZWVHZW9tZXRyeS5tYXhOdW1Ob2Rlc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vY3RyZWVHZW9tZXRyeS5sb2FkZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2N0cmVlR2VvbWV0cnkubG9hZGVyLmxvYWQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0TnVtUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udW1Qb2ludHM7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmdlb21ldHJ5ICYmIHRoaXMucGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9uZVRpbWVEaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyYXZlcnNlKGNiLCBpbmNsdWRlU2VsZiA9IHRydWUpIHtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBpbmNsdWRlU2VsZiA/IFt0aGlzXSA6IFtdO1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgd2hpbGUgKChjdXJyZW50ID0gc3RhY2sucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNiKGN1cnJlbnQpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjdXJyZW50LmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbk9jdHJlZUdlb21ldHJ5Tm9kZS5JRENvdW50ID0gMDtcbk9jdHJlZUdlb21ldHJ5Tm9kZS5JRENvdW50ID0gMDtcbiIsIi8qKlxuICogU29tZSB0eXBlcyBvZiBwb3NzaWJsZSBwb2ludCBhdHRyaWJ1dGUgZGF0YSBmb3JtYXRzXG4gKlxuICogQGNsYXNzXG4gKi9cbmNvbnN0IFBvaW50QXR0cmlidXRlVHlwZXMgPSB7XG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBuYW1lOiAnZG91YmxlJywgc2l6ZTogOCB9LFxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBuYW1lOiAnZmxvYXQnLCBzaXplOiA0IH0sXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgbmFtZTogJ2ludDgnLCBzaXplOiAxIH0sXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIG5hbWU6ICd1aW50OCcsIHNpemU6IDEgfSxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgbmFtZTogJ2ludDE2Jywgc2l6ZTogMiB9LFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgbmFtZTogJ3VpbnQxNicsIHNpemU6IDIgfSxcbiAgICBEQVRBX1RZUEVfSU5UMzI6IHsgb3JkaW5hbDogNiwgbmFtZTogJ2ludDMyJywgc2l6ZTogNCB9LFxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgbmFtZTogJ3VpbnQzMicsIHNpemU6IDQgfSxcbiAgICBEQVRBX1RZUEVfSU5UNjQ6IHsgb3JkaW5hbDogOCwgbmFtZTogJ2ludDY0Jywgc2l6ZTogOCB9LFxuICAgIERBVEFfVFlQRV9VSU5UNjQ6IHsgb3JkaW5hbDogOSwgbmFtZTogJ3VpbnQ2NCcsIHNpemU6IDggfVxufTtcbmxldCBpID0gMDtcbmZvciAoY29uc3Qgb2JqIGluIFBvaW50QXR0cmlidXRlVHlwZXMpIHtcbiAgICBQb2ludEF0dHJpYnV0ZVR5cGVzW2ldID0gUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdO1xuICAgIGkrKztcbn1cbmV4cG9ydCB7IFBvaW50QXR0cmlidXRlVHlwZXMgfTtcbmNsYXNzIFBvaW50QXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBudW1FbGVtZW50cywgcmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV0sIHVyaSA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm51bUVsZW1lbnRzID0gbnVtRWxlbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnJztcbiAgICB9XG59XG5leHBvcnQgeyBQb2ludEF0dHJpYnV0ZSB9O1xuZXhwb3J0IGNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1BPU0lUSU9OX0NBUlRFU0lBTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbiAgICBSR0JBX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcbiAgICBDT0xPUl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXG4gICAgUkdCX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCAzKSxcbiAgICBOT1JNQUxfRkxPQVRTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9GTE9BVFMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXG4gICAgSU5URU5TSVRZOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lOVEVOU0lUWScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXG4gICAgQ0xBU1NJRklDQVRJT046IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ0xBU1NJRklDQVRJT04nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfU1BIRVJFTUFQUEVEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxuICAgIE5PUk1BTF9PQ1QxNjogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfT0NUMTYnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXG4gICAgTk9STUFMOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcbiAgICBSRVRVUk5fTlVNQkVSOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1JFVFVSTl9OVU1CRVInLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgTlVNQkVSX09GX1JFVFVSTlM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTlVNQkVSX09GX1JFVFVSTlMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXG4gICAgU09VUkNFX0lEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NPVVJDRV9JRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXG4gICAgSU5ESUNFUzogbmV3IFBvaW50QXR0cmlidXRlKCdJTkRJQ0VTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLCAxKSxcbiAgICBTUEFDSU5HOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NQQUNJTkcnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMSksXG4gICAgR1BTX1RJTUU6IG5ldyBQb2ludEF0dHJpYnV0ZSgnR1BTX1RJTUUnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9ET1VCTEUsIDEpXG59O1xuZXhwb3J0IGNsYXNzIFBvaW50QXR0cmlidXRlcyB7XG4gICAgY29uc3RydWN0b3IocG9pbnRBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzID0gW10sIGJ5dGVTaXplID0gMCwgc2l6ZSA9IDAsIHZlY3RvcnMgPSBbXSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmJ5dGVTaXplID0gYnl0ZVNpemU7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XG4gICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkKHBvaW50QXR0cmlidXRlKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcbiAgICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuICAgIGFkZFZlY3Rvcih2ZWN0b3IpIHtcbiAgICAgICAgdGhpcy52ZWN0b3JzLnB1c2godmVjdG9yKTtcbiAgICB9XG4gICAgaGFzTm9ybWFscygpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAocG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX1NQSEVSRU1BUFBFRCB8fFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9GTE9BVFMgfHxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUwgfHxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfT0NUMTYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZmluZChhdHRyID0+IGF0dHIubmFtZSA9PT0gYXR0cmlidXRlTmFtZSk7XG4gICAgfVxufVxuIiwiLy8gQ3JlYXRlIGVudW1zIGZvciBkaWZmZXJlbnQgdHlwZXMgb2Ygd29ya2Vyc1xuZXhwb3J0IHZhciBXb3JrZXJUeXBlO1xuKGZ1bmN0aW9uIChXb3JrZXJUeXBlKSB7XG4gICAgV29ya2VyVHlwZVtcIkRFQ09ERVJfV09SS0VSXCJdID0gXCJERUNPREVSX1dPUktFUlwiO1xuICAgIFdvcmtlclR5cGVbXCJERUNPREVSX1dPUktFUl9HTFRGXCJdID0gXCJERUNPREVSX1dPUktFUl9HTFRGXCI7XG59KShXb3JrZXJUeXBlIHx8IChXb3JrZXJUeXBlID0ge30pKTtcbi8vIFdvcmtlciBKUyBuYW1lczogJ0JpbmFyeURlY29kZXJXb3JrZXIuanMnLCAnREVNV29ya2VyLmpzJywgJ0VwdEJpbmFyeURlY29kZXJXb3JrZXIuanMnLCAnRXB0TGFzemlwRGVjb2Rlcldvcmtlci5qcycsXG4vLyBFcHRac3RhbmRhcmREZWNvZGVyX3ByZWFtYmxlLmpzJywgJ0VwdFpzdGFuZGFyZERlY29kZXJXb3JrZXIuanMnLCAnTEFTRGVjb2Rlcldvcmtlci5qcycsICdMQVNMQVpXb3JrZXIuanMnLCAnTGF6TG9hZGVyV29ya2VyLmpzJ1xuZnVuY3Rpb24gY3JlYXRlV29ya2VyKHR5cGUpIHtcbiAgICAvLyBjb25zb2xlLmxvZyh0eXBlKVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFdvcmtlclR5cGUuREVDT0RFUl9XT1JLRVI6IHtcbiAgICAgICAgICAgIGNvbnN0IERlY29kZXJXb3JrZXIgPSByZXF1aXJlKCcuL2RlY29kZXIud29ya2VyLmpzJykuZGVmYXVsdDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlcldvcmtlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgV29ya2VyVHlwZS5ERUNPREVSX1dPUktFUl9HTFRGOiB7XG4gICAgICAgICAgICBjb25zdCBEZWNvZGVyV29ya2VyX0dMVEYgPSByZXF1aXJlKCcuL2dsdGYtZGVjb2Rlci53b3JrZXIuanMnKS5kZWZhdWx0O1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNvZGVyV29ya2VyX0dMVEYoKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHdvcmtlciB0eXBlJyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdvcmtlclBvb2wge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvLyBXb3JrZXJzIHdpbGwgYmUgYW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5IGZvciBlYWNoIHdvcmtlciB0eXBlIGFuZCB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgb2YgV29ya2VycyB0aGF0IGNhbiBiZSBlbXB0eVxuICAgICAgICB0aGlzLndvcmtlcnMgPSB7IERFQ09ERVJfV09SS0VSOiBbXSwgREVDT0RFUl9XT1JLRVJfR0xURjogW10gfTtcbiAgICB9XG4gICAgZ2V0V29ya2VyKHdvcmtlclR5cGUpIHtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3IgaWYgd29ya2VyVHlwZSBpcyBub3QgcmVjb2duaXplZFxuICAgICAgICBpZiAodGhpcy53b3JrZXJzW3dvcmtlclR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB3b3JrZXIgdHlwZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgd29ya2VyIFVSTCwgaWYgVVJMIGRvZXMgbm90IGV4aXN0IGluIHRoZSB3b3JrZXIgb2JqZWN0LCBjcmVhdGUgYSBuZXcgYXJyYXkgd2l0aCB0aGUgVVJMIGFzIGEga2V5XG4gICAgICAgIGlmICh0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB3b3JrZXIgPSBjcmVhdGVXb3JrZXIod29ya2VyVHlwZSk7XG4gICAgICAgICAgICB0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0ucHVzaCh3b3JrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2Vyc1t3b3JrZXJUeXBlXS5wb3AoKTtcbiAgICAgICAgaWYgKHdvcmtlciA9PT0gdW5kZWZpbmVkKSB7IC8vIFR5cGVzY3JpcHQgbmVlZHMgdGhpc1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3b3JrZXJzIGF2YWlsYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgbGFzdCB3b3JrZXIgaW4gdGhlIGFycmF5IGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgYXJyYXlcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9XG4gICAgcmV0dXJuV29ya2VyKHdvcmtlclR5cGUsIHdvcmtlcikge1xuICAgICAgICB0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0ucHVzaCh3b3JrZXIpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBleHRyYWN0QmFzZVBhdGgodXJsKSB7XG4gICAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVybChiYXNlUGF0aCwgZmlsZU5hbWUpIHtcbiAgICByZXR1cm4gYCR7YmFzZVBhdGh9JHtmaWxlTmFtZX1gO1xufVxuIiwiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEJveDMsIFNwaGVyZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IE9jdHJlZUdlb21ldHJ5IH0gZnJvbSAnLi9vY3RyZWUtZ2VvbWV0cnknO1xuaW1wb3J0IHsgT2N0cmVlR2VvbWV0cnlOb2RlIH0gZnJvbSAnLi9vY3RyZWUtZ2VvbWV0cnktbm9kZSc7XG5pbXBvcnQgeyBQb2ludEF0dHJpYnV0ZSwgUG9pbnRBdHRyaWJ1dGVzLCBQb2ludEF0dHJpYnV0ZVR5cGVzIH0gZnJvbSAnLi9wb2ludC1hdHRyaWJ1dGVzJztcbmltcG9ydCB7IFdvcmtlclBvb2wsIFdvcmtlclR5cGUgfSBmcm9tICcuL3dvcmtlci1wb29sJztcbmltcG9ydCB7IGJ1aWxkVXJsLCBleHRyYWN0QmFzZVBhdGggfSBmcm9tICcuL3V0aWxzJztcbi8vIEJ1ZmZlciBmaWxlcyBmb3IgREVGQVVMVCBlbmNvZGluZ1xuZXhwb3J0IGNvbnN0IEhJRVJBUkNIWV9GSUxFID0gJ2hpZXJhcmNoeS5iaW4nO1xuZXhwb3J0IGNvbnN0IE9DVFJFRV9GSUxFID0gJ29jdHJlZS5iaW4nO1xuLy8gRGVmYXVsdCBidWZmZXIgZmlsZXMgZm9yIEdMVEYgZW5jb2RpbmdcbmV4cG9ydCBjb25zdCBHTFRGX0NPTE9SU19GSUxFID0gJ2NvbG9ycy5nbGJpbic7XG5leHBvcnQgY29uc3QgR0xURl9QT1NJVElPTlNfRklMRSA9ICdwb3NpdGlvbnMuZ2xiaW4nO1xuZXhwb3J0IGNsYXNzIE5vZGVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGdldFVybCwgdXJsLCB3b3JrZXJQb29sLCBtZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmdldFVybCA9IGdldFVybDtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbCA9IHdvcmtlclBvb2w7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlQYXRoID0gJyc7XG4gICAgICAgIHRoaXMub2N0cmVlUGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gJyc7XG4gICAgICAgIHRoaXMuZ2x0ZlBvc2l0aW9uc1BhdGggPSAnJztcbiAgICB9XG4gICAgYXN5bmMgbG9hZChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmxvYWRlZCB8fCBub2RlLmxvYWRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICBub2RlLm9jdHJlZUdlb21ldHJ5Lm51bU5vZGVzTG9hZGluZysrO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmxvYWRIaWVyYXJjaHkobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGJ5dGVPZmZzZXQsIGJ5dGVTaXplIH0gPSBub2RlO1xuICAgICAgICAgICAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBieXRlU2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdieXRlT2Zmc2V0IGFuZCBieXRlU2l6ZSBhcmUgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5lbmNvZGluZyA9PT0gXCJHTFRGXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxDb2xvcnMgPSBhd2FpdCB0aGlzLmdldFVybCh0aGlzLmdsdGZDb2xvcnNQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxQb3NpdGlvbnMgPSBhd2FpdCB0aGlzLmdldFVybCh0aGlzLmdsdGZQb3NpdGlvbnNQYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZVNpemUgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgbG9hZGVkIG5vZGUgd2l0aCAwIGJ5dGVzOiAke25vZGUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0UG9zaXRpb25zID0gYnl0ZU9mZnNldCAqIDRuICogM247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb3NpdGlvbnMgPSBieXRlT2Zmc2V0ICogNG4gKiAzbiArIGJ5dGVTaXplICogNG4gKiAzbiAtIDFuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzUG9zaXRpb25zID0geyBSYW5nZTogYGJ5dGVzPSR7Zmlyc3RQb3NpdGlvbnN9LSR7bGFzdFBvc2l0aW9uc31gIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlUG9zaXRpb25zID0gYXdhaXQgZmV0Y2godXJsUG9zaXRpb25zLCB7IGhlYWRlcnM6IGhlYWRlcnNQb3NpdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclBvc2l0aW9ucyA9IGF3YWl0IHJlc3BvbnNlUG9zaXRpb25zLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sb3JzID0gYnl0ZU9mZnNldCAqIDRuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q29sb3JzID0gYnl0ZU9mZnNldCAqIDRuICsgYnl0ZVNpemUgKiA0biAtIDFuO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzQ29sb3JzID0geyBSYW5nZTogYGJ5dGVzPSR7Zmlyc3RDb2xvcnN9LSR7bGFzdENvbG9yc31gIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlQ29sb3JzID0gYXdhaXQgZmV0Y2godXJsQ29sb3JzLCB7IGhlYWRlcnM6IGhlYWRlcnNDb2xvcnMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckNvbG9ycyA9IGF3YWl0IHJlc3BvbnNlQ29sb3JzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGFwcGVuZEJ1ZmZlcihidWZmZXJQb3NpdGlvbnMsIGJ1ZmZlckNvbG9ycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsT2N0cmVlID0gYXdhaXQgdGhpcy5nZXRVcmwodGhpcy5vY3RyZWVQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGJ5dGVPZmZzZXQgKyBieXRlU2l6ZSAtIEJpZ0ludCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZVNpemUgPT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgbG9hZGVkIG5vZGUgd2l0aCAwIGJ5dGVzOiAke25vZGUubmFtZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IFJhbmdlOiBgYnl0ZXM9JHtmaXJzdH0tJHtsYXN0fWAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmxPY3RyZWUsIHsgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB3b3JrZXJUeXBlID0gdGhpcy5tZXRhZGF0YS5lbmNvZGluZyA9PT0gJ0dMVEYnID8gV29ya2VyVHlwZS5ERUNPREVSX1dPUktFUl9HTFRGIDogV29ya2VyVHlwZS5ERUNPREVSX1dPUktFUjtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbC5nZXRXb3JrZXIod29ya2VyVHlwZSk7XG4gICAgICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZS5kYXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBkYXRhLmF0dHJpYnV0ZUJ1ZmZlcnM7XG4gICAgICAgICAgICAgICAgdGhpcy53b3JrZXJQb29sLnJldHVybldvcmtlcih3b3JrZXJUeXBlLCB3b3JrZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBidWZmZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IGJ1ZmZlcnNbcHJvcGVydHldLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAncG9zaXRpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ3JnYmEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3JnYmEnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDQsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ05PUk1BTCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eSA9PT0gJ0lORElDRVMnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLm5vcm1hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbmRpY2VzJywgYnVmZmVyQXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlckF0dHJpYnV0ZSA9IG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoQXR0cmlidXRlID0gYnVmZmVyc1twcm9wZXJ0eV0uYXR0cmlidXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQXR0cmlidXRlLnBvdHJlZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGJ1ZmZlcnNbcHJvcGVydHldLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogYnVmZmVyc1twcm9wZXJ0eV0uc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlY2lzZUJ1ZmZlcjogYnVmZmVyc1twcm9wZXJ0eV0ucHJlY2lzZUJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogYmF0Y2hBdHRyaWJ1dGUucmFuZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUocHJvcGVydHksIGJ1ZmZlckF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5kZW5zaXR5ID0gZGF0YS5kZW5zaXR5O1xuICAgICAgICAgICAgICAgIG5vZGUuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcbiAgICAgICAgICAgICAgICBub2RlLm9jdHJlZUdlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnRpZ2h0Qm91bmRpbmdCb3ggPSB0aGlzLmdldFRpZ2h0Qm91bmRpbmdCb3goZGF0YS50aWdodEJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZXMgPSBub2RlLm9jdHJlZUdlb21ldHJ5LnBvaW50QXR0cmlidXRlcztcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlID0gbm9kZS5vY3RyZWVHZW9tZXRyeS5zY2FsZTtcbiAgICAgICAgICAgIGNvbnN0IGJveCA9IG5vZGUuYm91bmRpbmdCb3g7XG4gICAgICAgICAgICBjb25zdCBtaW4gPSBub2RlLm9jdHJlZUdlb21ldHJ5Lm9mZnNldC5jbG9uZSgpLmFkZChib3gubWluKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBib3gubWF4LmNsb25lKCkuc3ViKGJveC5taW4pO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gbWluLmNsb25lKCkuYWRkKHNpemUpO1xuICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gbm9kZS5udW1Qb2ludHM7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLm9jdHJlZUdlb21ldHJ5LmxvYWRlci5vZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZXM6IHBvaW50QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgICAgICAgICAgbWluOiBtaW4sXG4gICAgICAgICAgICAgICAgbWF4OiBtYXgsXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBudW1Qb2ludHM6IG51bVBvaW50c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZShtZXNzYWdlLCBbbWVzc2FnZS5idWZmZXJdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbm9kZS5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIG5vZGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbm9kZS5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUhpZXJhcmNoeShub2RlLCBidWZmZXIpIHtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgICAgICBjb25zdCBieXRlc1Blck5vZGUgPSAyMjtcbiAgICAgICAgY29uc3QgbnVtTm9kZXMgPSBidWZmZXIuYnl0ZUxlbmd0aCAvIGJ5dGVzUGVyTm9kZTtcbiAgICAgICAgY29uc3Qgb2N0cmVlID0gbm9kZS5vY3RyZWVHZW9tZXRyeTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgICBub2Rlc1swXSA9IG5vZGU7XG4gICAgICAgIGxldCBub2RlUG9zID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdmlldy5nZXRVaW50OChpICogYnl0ZXNQZXJOb2RlICsgMCk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZE1hc2sgPSB2aWV3LmdldFVpbnQ4KGkgKiBieXRlc1Blck5vZGUgKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHZpZXcuZ2V0VWludDMyKGkgKiBieXRlc1Blck5vZGUgKyAyLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB2aWV3LmdldEJpZ0ludDY0KGkgKiBieXRlc1Blck5vZGUgKyA2LCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVTaXplID0gdmlldy5nZXRCaWdJbnQ2NChpICogYnl0ZXNQZXJOb2RlICsgMTQsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHByb3h5IHdpdGggcmVhbCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudC5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgICAgICBjdXJyZW50LmJ5dGVTaXplID0gYnl0ZVNpemU7XG4gICAgICAgICAgICAgICAgY3VycmVudC5udW1Qb2ludHMgPSBudW1Qb2ludHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9hZCBwcm94eVxuICAgICAgICAgICAgICAgIGN1cnJlbnQuaGllcmFyY2h5Qnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY3VycmVudC5oaWVyYXJjaHlCeXRlU2l6ZSA9IGJ5dGVTaXplO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbG9hZCByZWFsIG5vZGVcbiAgICAgICAgICAgICAgICBjdXJyZW50LmJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuYnl0ZVNpemUgPSBieXRlU2l6ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm51bVBvaW50cyA9IG51bVBvaW50cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQubm9kZVR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkSW5kZXggPSAwOyBjaGlsZEluZGV4IDwgODsgY2hpbGRJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRFeGlzdHMgPSAoMSA8PCBjaGlsZEluZGV4ICYgY2hpbGRNYXNrKSAhPT0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkRXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBjdXJyZW50Lm5hbWUgKyBjaGlsZEluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQUFCQiA9IGNyZWF0ZUNoaWxkQUFCQihjdXJyZW50LmJvdW5kaW5nQm94LCBjaGlsZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5ldyBPY3RyZWVHZW9tZXRyeU5vZGUoY2hpbGROYW1lLCBvY3RyZWUsIGNoaWxkQUFCQik7XG4gICAgICAgICAgICAgICAgY2hpbGQubmFtZSA9IGNoaWxkTmFtZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5zcGFjaW5nID0gY3VycmVudC5zcGFjaW5nIC8gMjtcbiAgICAgICAgICAgICAgICBjaGlsZC5sZXZlbCA9IGN1cnJlbnQubGV2ZWwgKyAxO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGRyZW5bY2hpbGRJbmRleF0gPSBjaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIG5vZGVzW25vZGVQb3NdID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgbm9kZVBvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxvYWRIaWVyYXJjaHkobm9kZSkge1xuICAgICAgICBjb25zdCB7IGhpZXJhcmNoeUJ5dGVPZmZzZXQsIGhpZXJhcmNoeUJ5dGVTaXplIH0gPSBub2RlO1xuICAgICAgICBpZiAoaGllcmFyY2h5Qnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGhpZXJhcmNoeUJ5dGVTaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaGllcmFyY2h5Qnl0ZU9mZnNldCBhbmQgaGllcmFyY2h5Qnl0ZVNpemUgYXJlIHVuZGVmaW5lZCBmb3Igbm9kZSAke25vZGUubmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoaWVyYXJjaHlVcmwgPSBhd2FpdCB0aGlzLmdldFVybCh0aGlzLmhpZXJhcmNoeVBhdGgpO1xuICAgICAgICBjb25zdCBmaXJzdCA9IGhpZXJhcmNoeUJ5dGVPZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxhc3QgPSBmaXJzdCArIGhpZXJhcmNoeUJ5dGVTaXplIC0gQmlnSW50KDEpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBSYW5nZTogYGJ5dGVzPSR7Zmlyc3R9LSR7bGFzdH1gIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goaGllcmFyY2h5VXJsLCB7IGhlYWRlcnMgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIHRoaXMucGFyc2VIaWVyYXJjaHkobm9kZSwgYnVmZmVyKTtcbiAgICB9XG4gICAgZ2V0VGlnaHRCb3VuZGluZ0JveCh7IG1pbiwgbWF4IH0pIHtcbiAgICAgICAgY29uc3QgYm94ID0gbmV3IEJveDMobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkobWluKSwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkobWF4KSk7XG4gICAgICAgIGJveC5tYXguc3ViKGJveC5taW4pO1xuICAgICAgICBib3gubWluLnNldCgwLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIGJveDtcbiAgICB9XG59XG5jb25zdCB0bXBWZWMzID0gbmV3IFZlY3RvcjMoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQUFCQihhYWJiLCBpbmRleCkge1xuICAgIGNvbnN0IG1pbiA9IGFhYmIubWluLmNsb25lKCk7XG4gICAgY29uc3QgbWF4ID0gYWFiYi5tYXguY2xvbmUoKTtcbiAgICBjb25zdCBzaXplID0gdG1wVmVjMy5zdWJWZWN0b3JzKG1heCwgbWluKTtcbiAgICBpZiAoKGluZGV4ICYgMGIwMDAxKSA+IDApIHtcbiAgICAgICAgbWluLnogKz0gc2l6ZS56IC8gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1heC56IC09IHNpemUueiAvIDI7XG4gICAgfVxuICAgIGlmICgoaW5kZXggJiAwYjAwMTApID4gMCkge1xuICAgICAgICBtaW4ueSArPSBzaXplLnkgLyAyO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF4LnkgLT0gc2l6ZS55IC8gMjtcbiAgICB9XG4gICAgaWYgKChpbmRleCAmIDBiMDEwMCkgPiAwKSB7XG4gICAgICAgIG1pbi54ICs9IHNpemUueCAvIDI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBtYXgueCAtPSBzaXplLnggLyAyO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJveDMobWluLCBtYXgpO1xufVxuZnVuY3Rpb24gYXBwZW5kQnVmZmVyKGJ1ZmZlcjEsIGJ1ZmZlcjIpIHtcbiAgICB2YXIgdG1wID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyMS5ieXRlTGVuZ3RoICsgYnVmZmVyMi5ieXRlTGVuZ3RoKTtcbiAgICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEpLCAwKTtcbiAgICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjIpLCBidWZmZXIxLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0bXAuYnVmZmVyO1xufVxuY29uc3QgdHlwZW5hbWVUeXBlYXR0cmlidXRlTWFwID0ge1xuICAgIGRvdWJsZTogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRE9VQkxFLFxuICAgIGZsb2F0OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCxcbiAgICBpbnQ4OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LFxuICAgIHVpbnQ4OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCxcbiAgICBpbnQxNjogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UMTYsXG4gICAgdWludDE2OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UMTYsXG4gICAgaW50MzI6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDMyLFxuICAgIHVpbnQzMjogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLFxuICAgIGludDY0OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ2NCxcbiAgICB1aW50NjQ6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ2NFxufTtcbmV4cG9ydCBjbGFzcyBPY3RyZWVMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKGdldFVybCwgdXJsKSB7XG4gICAgICAgIHRoaXMud29ya2VyUG9vbCA9IG5ldyBXb3JrZXJQb29sKCk7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSAnJztcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlQYXRoID0gJyc7XG4gICAgICAgIHRoaXMub2N0cmVlUGF0aCA9ICcnO1xuICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gJyc7XG4gICAgICAgIHRoaXMuZ2x0ZlBvc2l0aW9uc1BhdGggPSAnJztcbiAgICAgICAgdGhpcy5nZXRVcmwgPSBnZXRVcmw7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBleHRyYWN0QmFzZVBhdGgodXJsKTtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlQYXRoID0gYnVpbGRVcmwodGhpcy5iYXNlUGF0aCwgSElFUkFSQ0hZX0ZJTEUpO1xuICAgICAgICB0aGlzLm9jdHJlZVBhdGggPSBidWlsZFVybCh0aGlzLmJhc2VQYXRoLCBPQ1RSRUVfRklMRSk7XG4gICAgICAgIC8vIFdlIGRlZmF1bHQgdG8gdGhlIGtub3duIG5hbWluZyBjb252ZW50aW9uIGZvciBnbFRGIGRhdGFzZXRzXG4gICAgICAgIHRoaXMuZ2x0ZkNvbG9yc1BhdGggPSBidWlsZFVybCh0aGlzLmJhc2VQYXRoLCBHTFRGX0NPTE9SU19GSUxFKTtcbiAgICAgICAgdGhpcy5nbHRmUG9zaXRpb25zUGF0aCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVBhdGgsIEdMVEZfUE9TSVRJT05TX0ZJTEUpO1xuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VBdHRyaWJ1dGVzKGpzb25BdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgUG9pbnRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VtZW50cyA9IHsgcmdiOiAncmdiYScgfTtcbiAgICAgICAgZm9yIChjb25zdCBqc29uQXR0cmlidXRlIG9mIGpzb25BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIG51bUVsZW1lbnRzLCBtaW4sIG1heCwgYnVmZmVyVmlldyB9ID0ganNvbkF0dHJpYnV0ZTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlbmFtZVR5cGVhdHRyaWJ1dGVNYXBbanNvbkF0dHJpYnV0ZS50eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHBvdHJlZUF0dHJpYnV0ZU5hbWUgPSByZXBsYWNlbWVudHNbbmFtZV0gPyByZXBsYWNlbWVudHNbbmFtZV0gOiBuYW1lO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbmV3IFBvaW50QXR0cmlidXRlKHBvdHJlZUF0dHJpYnV0ZU5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJWaWV3KSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLnVyaSA9IGJ1ZmZlclZpZXcudXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG51bUVsZW1lbnRzID09PSAxICYmIG1pbiAmJiBtYXgpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucmFuZ2UgPSBbbWluWzBdLCBtYXhbMF1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLnJhbmdlID0gW21pbiwgbWF4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnZ3BzLXRpbWUnKSB7IC8vIEhBQ0s6IEd1YXJkIGFnYWluc3QgYmFkIGdwc1RpbWUgcmFuZ2UgaW4gbWV0YWRhdGEsIHNlZSBwb3RyZWUvcG90cmVlIzkwOVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlLnJhbmdlWzBdID09PSAnbnVtYmVyJyAmJiBhdHRyaWJ1dGUucmFuZ2VbMF0gPT09IGF0dHJpYnV0ZS5yYW5nZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucmFuZ2VbMV0gKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyaWJ1dGUuaW5pdGlhbFJhbmdlID0gYXR0cmlidXRlLnJhbmdlO1xuICAgICAgICAgICAgYXR0cmlidXRlcy5hZGQoYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBoYXNOb3JtYWxzID0gYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFgnKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFknKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFonKSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGhhc05vcm1hbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOT1JNQUwnLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbJ05vcm1hbFgnLCAnTm9ybWFsWScsICdOb3JtYWxaJ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYWRkVmVjdG9yKHZlY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIGFzeW5jIGxvYWQodXJsLCB4aHJSZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5mZXRjaE1ldGFkYXRhKHVybCwgeGhyUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPY3RyZWVMb2FkZXIucGFyc2VBdHRyaWJ1dGVzKG1ldGFkYXRhLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLmFwcGx5Q3VzdG9tQnVmZmVyVVJJKG1ldGFkYXRhLmVuY29kaW5nLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5jcmVhdGVMb2FkZXIodXJsLCBtZXRhZGF0YSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gdGhpcy5jcmVhdGVCb3VuZGluZ0JveChtZXRhZGF0YSk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KGJvdW5kaW5nQm94KTtcbiAgICAgICAgY29uc3Qgb2N0cmVlID0gdGhpcy5pbml0aWFsaXplT2N0cmVlKGxvYWRlciwgdXJsLCBtZXRhZGF0YSwgYm91bmRpbmdCb3gsIG9mZnNldCwgYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLmluaXRpYWxpemVSb290Tm9kZShvY3RyZWUsIGJvdW5kaW5nQm94LCBtZXRhZGF0YSk7XG4gICAgICAgIG9jdHJlZS5yb290ID0gcm9vdDtcbiAgICAgICAgbG9hZGVyLmxvYWQocm9vdCk7XG4gICAgICAgIHJldHVybiB7IGdlb21ldHJ5OiBvY3RyZWUgfTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hNZXRhZGF0YSh1cmwsIHhoclJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB4aHJSZXF1ZXN0KHVybCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfVxuICAgIGFwcGx5Q3VzdG9tQnVmZmVyVVJJKGVuY29kaW5nLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIC8vIE9ubHkgZGF0YXNldHMgd2l0aCBHTFRGIGVuY29kaW5nIHN1cHBvcnQgY3VzdG9tIGJ1ZmZlciBVUklzIC1cbiAgICAgICAgLy8gYXMgb3Bwb3NlZCB0byBkYXRhc2V0cyB3aXRoIERFRkFVTFQgZW5jb2RpbmcgY29taW5nIGZyb20gUG90cmVlQ29udmVydGVyXG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ0dMVEYnKSB7XG4gICAgICAgICAgICB0aGlzLmdsdGZQb3NpdGlvbnNQYXRoID0gYXR0cmlidXRlcy5nZXRBdHRyaWJ1dGUoXCJwb3NpdGlvblwiKT8udXJpID8/IHRoaXMuZ2x0ZlBvc2l0aW9uc1BhdGg7XG4gICAgICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gYXR0cmlidXRlcy5nZXRBdHRyaWJ1dGUoXCJyZ2JhXCIpPy51cmkgPz8gdGhpcy5nbHRmQ29sb3JzUGF0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVMb2FkZXIodXJsLCBtZXRhZGF0YSwgYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBsb2FkZXIgPSBuZXcgTm9kZUxvYWRlcih0aGlzLmdldFVybCwgdXJsLCB0aGlzLndvcmtlclBvb2wsIG1ldGFkYXRhKTtcbiAgICAgICAgbG9hZGVyLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICBsb2FkZXIuc2NhbGUgPSBtZXRhZGF0YS5zY2FsZTtcbiAgICAgICAgbG9hZGVyLm9mZnNldCA9IG1ldGFkYXRhLm9mZnNldDtcbiAgICAgICAgbG9hZGVyLmhpZXJhcmNoeVBhdGggPSB0aGlzLmhpZXJhcmNoeVBhdGg7XG4gICAgICAgIGxvYWRlci5vY3RyZWVQYXRoID0gdGhpcy5vY3RyZWVQYXRoO1xuICAgICAgICBsb2FkZXIuZ2x0ZkNvbG9yc1BhdGggPSB0aGlzLmdsdGZDb2xvcnNQYXRoO1xuICAgICAgICBsb2FkZXIuZ2x0ZlBvc2l0aW9uc1BhdGggPSB0aGlzLmdsdGZQb3NpdGlvbnNQYXRoO1xuICAgICAgICByZXR1cm4gbG9hZGVyO1xuICAgIH1cbiAgICBjcmVhdGVCb3VuZGluZ0JveChtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBtaW4gPSBuZXcgVmVjdG9yMyguLi5tZXRhZGF0YS5ib3VuZGluZ0JveC5taW4pO1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgVmVjdG9yMyguLi5tZXRhZGF0YS5ib3VuZGluZ0JveC5tYXgpO1xuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3gzKG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICAgIH1cbiAgICBnZXRPZmZzZXQoYm91bmRpbmdCb3gpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYm91bmRpbmdCb3gubWluLmNsb25lKCk7XG4gICAgICAgIGJvdW5kaW5nQm94Lm1pbi5zdWIob2Zmc2V0KTtcbiAgICAgICAgYm91bmRpbmdCb3gubWF4LnN1YihvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBpbml0aWFsaXplT2N0cmVlKGxvYWRlciwgdXJsLCBtZXRhZGF0YSwgYm91bmRpbmdCb3gsIG9mZnNldCwgYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBvY3RyZWUgPSBuZXcgT2N0cmVlR2VvbWV0cnkobG9hZGVyLCBib3VuZGluZ0JveCk7XG4gICAgICAgIG9jdHJlZS51cmwgPSB1cmw7XG4gICAgICAgIG9jdHJlZS5zcGFjaW5nID0gbWV0YWRhdGEuc3BhY2luZztcbiAgICAgICAgb2N0cmVlLnNjYWxlID0gbWV0YWRhdGEuc2NhbGU7XG4gICAgICAgIG9jdHJlZS5wcm9qZWN0aW9uID0gbWV0YWRhdGEucHJvamVjdGlvbjtcbiAgICAgICAgb2N0cmVlLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XG4gICAgICAgIG9jdHJlZS5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nQm94LmdldEJvdW5kaW5nU3BoZXJlKG5ldyBTcGhlcmUoKSk7XG4gICAgICAgIG9jdHJlZS50aWdodEJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdCb3guZ2V0Qm91bmRpbmdTcGhlcmUobmV3IFNwaGVyZSgpKTtcbiAgICAgICAgb2N0cmVlLnRpZ2h0Qm91bmRpbmdCb3ggPSB0aGlzLmdldFRpZ2h0Qm91bmRpbmdCb3gobWV0YWRhdGEpO1xuICAgICAgICBvY3RyZWUub2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBvY3RyZWUucG9pbnRBdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIG9jdHJlZTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVJvb3ROb2RlKG9jdHJlZSwgYm91bmRpbmdCb3gsIG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSBuZXcgT2N0cmVlR2VvbWV0cnlOb2RlKCdyJywgb2N0cmVlLCBib3VuZGluZ0JveCk7XG4gICAgICAgIHJvb3QubGV2ZWwgPSAwO1xuICAgICAgICByb290Lm5vZGVUeXBlID0gMjtcbiAgICAgICAgcm9vdC5oaWVyYXJjaHlCeXRlT2Zmc2V0ID0gQmlnSW50KDApO1xuICAgICAgICByb290LmhpZXJhcmNoeUJ5dGVTaXplID0gQmlnSW50KG1ldGFkYXRhLmhpZXJhcmNoeS5maXJzdENodW5rU2l6ZSk7XG4gICAgICAgIHJvb3Quc3BhY2luZyA9IG9jdHJlZS5zcGFjaW5nO1xuICAgICAgICByb290LmJ5dGVPZmZzZXQgPSBCaWdJbnQoMCk7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICBnZXRUaWdodEJvdW5kaW5nQm94KG1ldGFkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gbWV0YWRhdGEuYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoIXBvc2l0aW9uQXR0cmlidXRlIHx8ICFwb3NpdGlvbkF0dHJpYnV0ZS5taW4gfHwgIXBvc2l0aW9uQXR0cmlidXRlLm1heCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQb3NpdGlvbiBhdHRyaWJ1dGUgKG1pbiwgbWF4KSBub3QgZm91bmQuIEZhbGxpbmcgYmFjayB0byBib3VuZGluZ0JveCBmb3IgdGlnaHRCb3VuZGluZ0JveCcpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3gzKG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1pbiksIG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1heCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1ldGFkYXRhLmJvdW5kaW5nQm94Lm1pbjtcbiAgICAgICAgY29uc3QgdGlnaHRCb3VuZGluZ0JveCA9IG5ldyBCb3gzKG5ldyBWZWN0b3IzKHBvc2l0aW9uQXR0cmlidXRlLm1pblswXSAtIG9mZnNldFswXSwgcG9zaXRpb25BdHRyaWJ1dGUubWluWzFdIC0gb2Zmc2V0WzFdLCBwb3NpdGlvbkF0dHJpYnV0ZS5taW5bMl0gLSBvZmZzZXRbMl0pLCBuZXcgVmVjdG9yMyhwb3NpdGlvbkF0dHJpYnV0ZS5tYXhbMF0gLSBvZmZzZXRbMF0sIHBvc2l0aW9uQXR0cmlidXRlLm1heFsxXSAtIG9mZnNldFsxXSwgcG9zaXRpb25BdHRyaWJ1dGUubWF4WzJdIC0gb2Zmc2V0WzJdKSk7XG4gICAgICAgIHJldHVybiB0aWdodEJvdW5kaW5nQm94O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE9jdHJlZUxvYWRlciB9IGZyb20gJy4vb2N0cmVlLWxvYWRlcic7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZE9jdHJlZSh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCkge1xuICAgIGNvbnN0IHRydWVVcmwgPSBhd2FpdCBnZXRVcmwodXJsKTtcbiAgICBjb25zdCBsb2FkZXIgPSBuZXcgT2N0cmVlTG9hZGVyKGdldFVybCwgdXJsKTtcbiAgICBjb25zdCB7IGdlb21ldHJ5IH0gPSBhd2FpdCBsb2FkZXIubG9hZCh0cnVlVXJsLCB4aHJSZXF1ZXN0KTtcbiAgICByZXR1cm4gZ2VvbWV0cnk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNHZW9tZXRyeU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZSAhPT0gbnVsbCAmJiBub2RlLmlzR2VvbWV0cnlOb2RlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVHJlZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZSAhPT0gbnVsbCAmJiBub2RlLmlzVHJlZU5vZGU7XG59XG4iLCIvKipcbiAqIGZyb206IGh0dHA6Ly9lbG9xdWVudGphdmFzY3JpcHQubmV0LzFzdF9lZGl0aW9uL2FwcGVuZGl4Mi5odG1sXG4gKlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBCaW5hcnlIZWFwKHNjb3JlRnVuY3Rpb24pIHtcbiAgdGhpcy5jb250ZW50ID0gW107XG4gIHRoaXMuc2NvcmVGdW5jdGlvbiA9IHNjb3JlRnVuY3Rpb247XG59XG5CaW5hcnlIZWFwLnByb3RvdHlwZSA9IHtcbiAgcHVzaDogZnVuY3Rpb24gcHVzaChlbGVtZW50KSB7XG4gICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICB0aGlzLmNvbnRlbnQucHVzaChlbGVtZW50KTtcbiAgICAvLyBBbGxvdyBpdCB0byBidWJibGUgdXAuXG4gICAgdGhpcy5idWJibGVVcCh0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMSk7XG4gIH0sXG4gIHBvcDogZnVuY3Rpb24gcG9wKCkge1xuICAgIC8vIFN0b3JlIHRoZSBmaXJzdCBlbGVtZW50IHNvIHdlIGNhbiByZXR1cm4gaXQgbGF0ZXIuXG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuY29udGVudFswXTtcbiAgICAvLyBHZXQgdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAvLyBJZiB0aGVyZSBhcmUgYW55IGVsZW1lbnRzIGxlZnQsIHB1dCB0aGUgZW5kIGVsZW1lbnQgYXQgdGhlXG4gICAgLy8gc3RhcnQsIGFuZCBsZXQgaXQgc2luayBkb3duLlxuICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5jb250ZW50WzBdID0gZW5kO1xuICAgICAgdGhpcy5zaW5rRG93bigwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobm9kZSkge1xuICAgIHZhciBsZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICAgIC8vIFRvIHJlbW92ZSBhIHZhbHVlLCB3ZSBtdXN0IHNlYXJjaCB0aHJvdWdoIHRoZSBhcnJheSB0byBmaW5kXG4gICAgLy8gaXQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSAhPSBub2RlKSBjb250aW51ZTtcbiAgICAgIC8vIFdoZW4gaXQgaXMgZm91bmQsIHRoZSBwcm9jZXNzIHNlZW4gaW4gJ3BvcCcgaXMgcmVwZWF0ZWRcbiAgICAgIC8vIHRvIGZpbGwgdXAgdGhlIGhvbGUuXG4gICAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgd2UgcG9wcGVkIHdhcyB0aGUgb25lIHdlIG5lZWRlZCB0byByZW1vdmUsXG4gICAgICAvLyB3ZSdyZSBkb25lLlxuICAgICAgaWYgKGkgPT0gbGVuZ3RoIC0gMSkgYnJlYWs7XG4gICAgICAvLyBPdGhlcndpc2UsIHdlIHJlcGxhY2UgdGhlIHJlbW92ZWQgZWxlbWVudCB3aXRoIHRoZSBwb3BwZWRcbiAgICAgIC8vIG9uZSwgYW5kIGFsbG93IGl0IHRvIGZsb2F0IHVwIG9yIHNpbmsgZG93biBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIHRoaXMuY29udGVudFtpXSA9IGVuZDtcbiAgICAgIHRoaXMuYnViYmxlVXAoaSk7XG4gICAgICB0aGlzLnNpbmtEb3duKGkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuICBzaXplOiBmdW5jdGlvbiBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9LFxuICBidWJibGVVcDogZnVuY3Rpb24gYnViYmxlVXAobikge1xuICAgIC8vIEZldGNoIHRoZSBlbGVtZW50IHRoYXQgaGFzIHRvIGJlIG1vdmVkLlxuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dLFxuICAgICAgc2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG4gICAgLy8gV2hlbiBhdCAwLCBhbiBlbGVtZW50IGNhbiBub3QgZ28gdXAgYW55IGZ1cnRoZXIuXG4gICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXG4gICAgICB2YXIgcGFyZW50TiA9IE1hdGguZmxvb3IoKG4gKyAxKSAvIDIpIC0gMSxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dO1xuICAgICAgLy8gSWYgdGhlIHBhcmVudCBoYXMgYSBsZXNzZXIgc2NvcmUsIHRoaW5ncyBhcmUgaW4gb3JkZXIgYW5kIHdlXG4gICAgICAvLyBhcmUgZG9uZS5cbiAgICAgIGlmIChzY29yZSA+PSB0aGlzLnNjb3JlRnVuY3Rpb24ocGFyZW50KSkgYnJlYWs7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3dhcCB0aGUgcGFyZW50IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCBhbmRcbiAgICAgIC8vIGNvbnRpbnVlLlxuICAgICAgdGhpcy5jb250ZW50W3BhcmVudE5dID0gZWxlbWVudDtcbiAgICAgIHRoaXMuY29udGVudFtuXSA9IHBhcmVudDtcbiAgICAgIG4gPSBwYXJlbnROO1xuICAgIH1cbiAgfSxcbiAgc2lua0Rvd246IGZ1bmN0aW9uIHNpbmtEb3duKG4pIHtcbiAgICAvLyBMb29rIHVwIHRoZSB0YXJnZXQgZWxlbWVudCBhbmQgaXRzIHNjb3JlLlxuICAgIHZhciBsZW5ndGggPSB0aGlzLmNvbnRlbnQubGVuZ3RoLFxuICAgICAgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXSxcbiAgICAgIGVsZW1TY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgaW5kaWNlcyBvZiB0aGUgY2hpbGQgZWxlbWVudHMuXG4gICAgICB2YXIgY2hpbGQyTiA9IChuICsgMSkgKiAyLFxuICAgICAgICBjaGlsZDFOID0gY2hpbGQyTiAtIDE7XG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgZWxlbWVudCxcbiAgICAgIC8vIGlmIGFueS5cbiAgICAgIHZhciBzd2FwID0gbnVsbDtcbiAgICAgIC8vIElmIHRoZSBmaXJzdCBjaGlsZCBleGlzdHMgKGlzIGluc2lkZSB0aGUgYXJyYXkpLi4uXG4gICAgICBpZiAoY2hpbGQxTiA8IGxlbmd0aCkge1xuICAgICAgICAvLyBMb29rIGl0IHVwIGFuZCBjb21wdXRlIGl0cyBzY29yZS5cbiAgICAgICAgdmFyIGNoaWxkMSA9IHRoaXMuY29udGVudFtjaGlsZDFOXSxcbiAgICAgICAgICBjaGlsZDFTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDEpO1xuICAgICAgICAvLyBJZiB0aGUgc2NvcmUgaXMgbGVzcyB0aGFuIG91ciBlbGVtZW50J3MsIHdlIG5lZWQgdG8gc3dhcC5cbiAgICAgICAgaWYgKGNoaWxkMVNjb3JlIDwgZWxlbVNjb3JlKSBzd2FwID0gY2hpbGQxTjtcbiAgICAgIH1cbiAgICAgIC8vIERvIHRoZSBzYW1lIGNoZWNrcyBmb3IgdGhlIG90aGVyIGNoaWxkLlxuICAgICAgaWYgKGNoaWxkMk4gPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoaWxkMiA9IHRoaXMuY29udGVudFtjaGlsZDJOXSxcbiAgICAgICAgICBjaGlsZDJTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDIpO1xuICAgICAgICBpZiAoY2hpbGQyU2NvcmUgPCAoc3dhcCA9PSBudWxsID8gZWxlbVNjb3JlIDogY2hpbGQxU2NvcmUpKSBzd2FwID0gY2hpbGQyTjtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gbmVlZCB0byBzd2FwIGZ1cnRoZXIsIHdlIGFyZSBkb25lLlxuICAgICAgaWYgKHN3YXAgPT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgc3dhcCBhbmQgY29udGludWUuXG4gICAgICB0aGlzLmNvbnRlbnRbbl0gPSB0aGlzLmNvbnRlbnRbc3dhcF07XG4gICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgbiA9IHN3YXA7XG4gICAgfVxuICB9XG59OyIsImltcG9ydCB7IEJ1ZmZlckF0dHJpYnV0ZSwgQnVmZmVyR2VvbWV0cnksIENvbG9yLCBMaW5lQmFzaWNNYXRlcmlhbCwgTGluZVNlZ21lbnRzLCB9IGZyb20gJ3RocmVlJztcbi8qKlxuICpcbiAqIGNvZGUgYWRhcHRlZCBmcm9tIHRocmVlLmpzIEJveEhlbHBlci5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2Rldi9zcmMvaGVscGVycy9Cb3hIZWxwZXIuanNcbiAqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xuICogQGF1dGhvciBtc2NodWV0eiAvIGh0dHA6Ly9wb3RyZWUub3JnXG4gKi9cbmV4cG9ydCBjbGFzcyBCb3gzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcbiAgICBjb25zdHJ1Y3Rvcihib3gsIGNvbG9yID0gbmV3IENvbG9yKDB4ZmZmZjAwKSkge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgN10pO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1pbi56LFxuICAgICAgICAgICAgYm94Lm1heC54LCBib3gubWluLnksIGJveC5taW4ueixcbiAgICAgICAgICAgIGJveC5tYXgueCwgYm94Lm1pbi55LCBib3gubWF4LnosXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1heC56LFxuICAgICAgICAgICAgYm94Lm1pbi54LCBib3gubWF4LnksIGJveC5taW4ueixcbiAgICAgICAgICAgIGJveC5tYXgueCwgYm94Lm1heC55LCBib3gubWluLnosXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1heC56LFxuICAgICAgICAgICAgYm94Lm1pbi54LCBib3gubWF4LnksIGJveC5tYXguelxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcbiAgICAgICAgZ2VvbWV0cnkuc2V0SW5kZXgobmV3IEJ1ZmZlckF0dHJpYnV0ZShpbmRpY2VzLCAxKSk7XG4gICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKHBvc2l0aW9ucywgMykpO1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBjb2xvciB9KTtcbiAgICAgICAgc3VwZXIoZ2VvbWV0cnksIG1hdGVyaWFsKTtcbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgTFJVSXRlbSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICB9XG59XG4vKipcbiAqIEEgZG91Ymx5LWxpbmtlZC1saXN0IG9mIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgY2xhc3MgTFJVIHtcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEJ1ZGdldCA9IDEwMDAwMDApIHtcbiAgICAgICAgdGhpcy5wb2ludEJ1ZGdldCA9IHBvaW50QnVkZ2V0O1xuICAgICAgICAvLyB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBpdGVtXG4gICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgICAvLyB0aGUgbW9zdCByZWNlbnRseSB1c2VkIGl0ZW1cbiAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuc2l6ZTtcbiAgICB9XG4gICAgaGFzKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuaGFzKG5vZGUuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgc3BlY2lmaWVkIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgaXRlbS4gaWYgdGhlIGxpc3QgZG9lcyBub3QgY29udGFpbiBub2RlLCBpdCB3aWxsXG4gICAgICogYmUgYWRkZWQuXG4gICAgICovXG4gICAgdG91Y2gobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUubG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KG5vZGUuaWQpO1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy50b3VjaEV4aXN0aW5nKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGROZXcobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkTmV3KG5vZGUpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5ldyBMUlVJdGVtKG5vZGUpO1xuICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xuICAgICAgICB0aGlzLmxhc3QgPSBpdGVtO1xuICAgICAgICBpZiAoaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlyc3QpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXMuc2V0KG5vZGUuaWQsIGl0ZW0pO1xuICAgICAgICB0aGlzLm51bVBvaW50cyArPSBub2RlLm51bVBvaW50cztcbiAgICB9XG4gICAgdG91Y2hFeGlzdGluZyhpdGVtKSB7XG4gICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgLy8gaGFuZGxlIHRvdWNoIG9uIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpdGVtLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLmxhc3Q7XG4gICAgICAgICAgICAgICAgaXRlbS5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3QgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpdGVtLm5leHQpIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0b3VjaCBvbiBsYXN0IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSB0b3VjaCBvbiBhbnkgb3RoZXIgZWxlbWVudFxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgaXRlbS5uZXh0LnByZXZpb3VzID0gaXRlbS5wcmV2aW91cztcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLmxhc3Q7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0ID0gaXRlbTtcbiAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmUobm9kZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5nZXQobm9kZS5pZCk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdC5wcmV2aW91cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Lm5leHQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXMgJiYgaXRlbS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pdGVtcy5kZWxldGUobm9kZS5pZCk7XG4gICAgICAgIHRoaXMubnVtUG9pbnRzIC09IG5vZGUubnVtUG9pbnRzO1xuICAgIH1cbiAgICBnZXRMUlVJdGVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maXJzdCA/IHRoaXMuZmlyc3Qubm9kZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnJlZU1lbW9yeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXRlbXMuc2l6ZSA8PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMubnVtUG9pbnRzID4gdGhpcy5wb2ludEJ1ZGdldCAqIDIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldExSVUl0ZW0oKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlU3VidHJlZShub2RlKSB7XG4gICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSBub2RlcyB3aGljaCBhcmUgdG8gYmUgZGlzcG9zZWQgYW5kIHJlbW92ZWQuXG4gICAgICAgIGNvbnN0IG5vZGVzVG9EaXNwb3NlID0gW25vZGVdO1xuICAgICAgICBub2RlLnRyYXZlcnNlKG4gPT4ge1xuICAgICAgICAgICAgaWYgKG4ubG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNUb0Rpc3Bvc2UucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIERpc3Bvc2Ugb2YgYWxsIHRoZSBub2RlcyBpbiBvbmUgZ28uXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1RvRGlzcG9zZSkge1xuICAgICAgICAgICAgbi5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZShuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEJveDMsIEZydXN0dW0sIE1hdHJpeDQsIFZlY3RvcjIsIFZlY3RvcjMsIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgREVGQVVMVF9QT0lOVF9CVURHRVQsIE1BWF9MT0FEU19UT19HUFUsIE1BWF9OVU1fTk9ERVNfTE9BRElORywgUEVSU1BFQ1RJVkVfQ0FNRVJBLCB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEZFQVRVUkVTIH0gZnJvbSAnLi9mZWF0dXJlcyc7XG5pbXBvcnQgeyBCaW5hcnlMb2FkZXIsIGxvYWRQT0MgfSBmcm9tICcuL2xvYWRpbmcnO1xuaW1wb3J0IHsgbG9hZE9jdHJlZSB9IGZyb20gJy4vbG9hZGluZzIvbG9hZC1vY3RyZWUnO1xuaW1wb3J0IHsgQ2xpcE1vZGUgfSBmcm9tICcuL21hdGVyaWFscyc7XG5pbXBvcnQgeyBQb2ludENsb3VkT2N0cmVlIH0gZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUnO1xuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZVBpY2tlciB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XG5pbXBvcnQgeyBpc0dlb21ldHJ5Tm9kZSwgaXNUcmVlTm9kZSB9IGZyb20gJy4vdHlwZS1wcmVkaWNhdGVzJztcbmltcG9ydCB7IEJpbmFyeUhlYXAgfSBmcm9tICcuL3V0aWxzL2JpbmFyeS1oZWFwJztcbmltcG9ydCB7IEJveDNIZWxwZXIgfSBmcm9tICcuL3V0aWxzL2JveDMtaGVscGVyJztcbmltcG9ydCB7IExSVSB9IGZyb20gJy4vdXRpbHMvbHJ1JztcbmV4cG9ydCBjbGFzcyBRdWV1ZUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50Q2xvdWRJbmRleCwgd2VpZ2h0LCBub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wb2ludENsb3VkSW5kZXggPSBwb2ludENsb3VkSW5kZXg7XG4gICAgICAgIHRoaXMud2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG59XG5jb25zdCBHRU9NRVRSWV9MT0FERVJTID0ge1xuICAgIHYxOiBsb2FkUE9DLFxuICAgIHYyOiBsb2FkT2N0cmVlXG59O1xuZXhwb3J0IGNsYXNzIFBvdHJlZSB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbiA9IFwidjFcIikge1xuICAgICAgICB0aGlzLl9wb2ludEJ1ZGdldCA9IERFRkFVTFRfUE9JTlRfQlVER0VUO1xuICAgICAgICB0aGlzLl9yZW5kZXJlclNpemUgPSBuZXcgVmVjdG9yMigpO1xuICAgICAgICB0aGlzLm1heE51bU5vZGVzTG9hZGluZyA9IE1BWF9OVU1fTk9ERVNfTE9BRElORztcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IEZFQVRVUkVTO1xuICAgICAgICB0aGlzLmxydSA9IG5ldyBMUlUodGhpcy5fcG9pbnRCdWRnZXQpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHlTdHJ1Y3R1cmVzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZydXN0dW1NYXRyaXggPSBuZXcgTWF0cml4NCgpO1xuICAgICAgICAgICAgY29uc3QgaW52ZXJzZVdvcmxkTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG4gICAgICAgICAgICByZXR1cm4gKHBvaW50Q2xvdWRzLCBjYW1lcmEpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcnVzdHVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVyYVBvc2l0aW9ucyA9IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5UXVldWUgPSBuZXcgQmluYXJ5SGVhcCh4ID0+IDEgLyB4LndlaWdodCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludENsb3Vkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludENsb3VkID0gcG9pbnRDbG91ZHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9pbnRDbG91ZC5pbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLm51bVZpc2libGVQb2ludHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLnZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLnZpc2libGVHZW9tZXRyeSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGdXJzdHVtIGluIG9iamVjdCBzcGFjZS5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZXJzZVZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3b3JsZE1hdHJpeCA9IHBvaW50Q2xvdWQubWF0cml4V29ybGQ7XG4gICAgICAgICAgICAgICAgICAgIGZydXN0dW1NYXRyaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZGVudGl0eSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkoY2FtZXJhLnByb2plY3Rpb25NYXRyaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkoaW52ZXJzZVZpZXdNYXRyaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkod29ybGRNYXRyaXgpO1xuICAgICAgICAgICAgICAgICAgICBmcnVzdHVtcy5wdXNoKG5ldyBGcnVzdHVtKCkuc2V0RnJvbVByb2plY3Rpb25NYXRyaXgoZnJ1c3R1bU1hdHJpeCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDYW1lcmEgcG9zaXRpb24gaW4gb2JqZWN0IHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VXb3JsZE1hdHJpeC5jb3B5KHdvcmxkTWF0cml4KS5pbnZlcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhTWF0cml4XG4gICAgICAgICAgICAgICAgICAgICAgICAuaWRlbnRpdHkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGludmVyc2VXb3JsZE1hdHJpeClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWx0aXBseShjYW1lcmEubWF0cml4V29ybGQpO1xuICAgICAgICAgICAgICAgICAgICBjYW1lcmFQb3NpdGlvbnMucHVzaChuZXcgVmVjdG9yMygpLnNldEZyb21NYXRyaXhQb3NpdGlvbihjYW1lcmFNYXRyaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Q2xvdWQudmlzaWJsZSAmJiBwb2ludENsb3VkLnJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvcml0eVF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShpLCB3ZWlnaHQsIHBvaW50Q2xvdWQucm9vdCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgYW55IHByZXZpb3VzbHkgdmlzaWJsZSBub2Rlcy4gV2Ugd2lsbCBsYXRlciBzaG93IG9ubHkgdGhlIG5lZWRlZCBvbmVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUcmVlTm9kZShwb2ludENsb3VkLnJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLmhpZGVEZXNjZW5kYW50cyhwb2ludENsb3VkLnJvb3Quc2NlbmVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGJvdW5kaW5nQm94Tm9kZSBvZiBwb2ludENsb3VkLmJvdW5kaW5nQm94Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94Tm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJ1c3R1bXMsIGNhbWVyYVBvc2l0aW9ucywgcHJpb3JpdHlRdWV1ZSB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgdGhpcy5sb2FkR2VvbWV0cnkgPSBHRU9NRVRSWV9MT0FERVJTW3ZlcnNpb25dO1xuICAgIH1cbiAgICBsb2FkUG9pbnRDbG91ZCh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCA9IChpbnB1dCwgaW5pdCkgPT4gZmV0Y2goaW5wdXQsIGluaXQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRHZW9tZXRyeSh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCkudGhlbihnZW9tZXRyeSA9PiBuZXcgUG9pbnRDbG91ZE9jdHJlZSh0aGlzLCBnZW9tZXRyeSkpO1xuICAgIH1cbiAgICB1cGRhdGVQb2ludENsb3Vkcyhwb2ludENsb3VkcywgY2FtZXJhLCByZW5kZXJlcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVwZGF0ZVZpc2liaWxpdHkocG9pbnRDbG91ZHMsIGNhbWVyYSwgcmVuZGVyZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50Q2xvdWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludENsb3VkID0gcG9pbnRDbG91ZHNbaV07XG4gICAgICAgICAgICBpZiAocG9pbnRDbG91ZC5kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRDbG91ZC5tYXRlcmlhbC51cGRhdGVNYXRlcmlhbChwb2ludENsb3VkLCBwb2ludENsb3VkLnZpc2libGVOb2RlcywgY2FtZXJhLCByZW5kZXJlcik7XG4gICAgICAgICAgICBwb2ludENsb3VkLnVwZGF0ZVZpc2libGVCb3VuZHMoKTtcbiAgICAgICAgICAgIHBvaW50Q2xvdWQudXBkYXRlQm91bmRpbmdCb3hlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubHJ1LmZyZWVNZW1vcnkoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIHBpY2socG9pbnRDbG91ZHMsIHJlbmRlcmVyLCBjYW1lcmEsIHJheSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgUG90cmVlLnBpY2tlciA9IFBvdHJlZS5waWNrZXIgfHwgbmV3IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIoKTtcbiAgICAgICAgcmV0dXJuIFBvdHJlZS5waWNrZXIucGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIHBvaW50Q2xvdWRzLCBwYXJhbXMpO1xuICAgIH1cbiAgICBnZXQgcG9pbnRCdWRnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludEJ1ZGdldDtcbiAgICB9XG4gICAgc2V0IHBvaW50QnVkZ2V0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9pbnRCdWRnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvaW50QnVkZ2V0ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmxydS5wb2ludEJ1ZGdldCA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5scnUuZnJlZU1lbW9yeSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBzZXQgbWF4TG9hZGVyV29ya2Vycyh2YWx1ZSkge1xuICAgICAgICBCaW5hcnlMb2FkZXIuV09SS0VSX1BPT0wubWF4V29ya2VycyA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IG1heExvYWRlcldvcmtlcnMoKSB7XG4gICAgICAgIHJldHVybiBCaW5hcnlMb2FkZXIuV09SS0VSX1BPT0wubWF4V29ya2VycztcbiAgICB9XG4gICAgdXBkYXRlVmlzaWJpbGl0eShwb2ludENsb3VkcywgY2FtZXJhLCByZW5kZXJlcikge1xuICAgICAgICBsZXQgbnVtVmlzaWJsZVBvaW50cyA9IDA7XG4gICAgICAgIGNvbnN0IHZpc2libGVOb2RlcyA9IFtdO1xuICAgICAgICBjb25zdCB1bmxvYWRlZEdlb21ldHJ5ID0gW107XG4gICAgICAgIC8vIGNhbGN1bGF0ZSBvYmplY3Qgc3BhY2UgZnJ1c3R1bSBhbmQgY2FtIHBvcyBhbmQgc2V0dXAgcHJpb3JpdHkgcXVldWVcbiAgICAgICAgY29uc3QgeyBmcnVzdHVtcywgY2FtZXJhUG9zaXRpb25zLCBwcmlvcml0eVF1ZXVlIH0gPSB0aGlzLnVwZGF0ZVZpc2liaWxpdHlTdHJ1Y3R1cmVzKHBvaW50Q2xvdWRzLCBjYW1lcmEpO1xuICAgICAgICBsZXQgbG9hZGVkVG9HUFVUaGlzRnJhbWUgPSAwO1xuICAgICAgICBsZXQgZXhjZWVkZWRNYXhMb2Fkc1RvR1BVID0gZmFsc2U7XG4gICAgICAgIGxldCBub2RlTG9hZEZhaWxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcXVldWVJdGVtO1xuICAgICAgICB3aGlsZSAoKHF1ZXVlSXRlbSA9IHByaW9yaXR5UXVldWUucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gcXVldWVJdGVtLm5vZGU7XG4gICAgICAgICAgICAvLyBJZiB3ZSB3aWxsIGVuZCB1cCB3aXRoIHRvbyBtYW55IHBvaW50cywgd2Ugc3RvcCByaWdodCBhd2F5LlxuICAgICAgICAgICAgaWYgKG51bVZpc2libGVQb2ludHMgKyBub2RlLm51bVBvaW50cyA+IHRoaXMucG9pbnRCdWRnZXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50Q2xvdWRJbmRleCA9IHF1ZXVlSXRlbS5wb2ludENsb3VkSW5kZXg7XG4gICAgICAgICAgICBjb25zdCBwb2ludENsb3VkID0gcG9pbnRDbG91ZHNbcG9pbnRDbG91ZEluZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IG1heExldmVsID0gcG9pbnRDbG91ZC5tYXhMZXZlbCAhPT0gdW5kZWZpbmVkID8gcG9pbnRDbG91ZC5tYXhMZXZlbCA6IEluZmluaXR5O1xuICAgICAgICAgICAgaWYgKG5vZGUubGV2ZWwgPiBtYXhMZXZlbCB8fFxuICAgICAgICAgICAgICAgICFmcnVzdHVtc1twb2ludENsb3VkSW5kZXhdLmludGVyc2VjdHNCb3gobm9kZS5ib3VuZGluZ0JveCkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZENsaXAocG9pbnRDbG91ZCwgbm9kZS5ib3VuZGluZ0JveCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bVZpc2libGVQb2ludHMgKz0gbm9kZS5udW1Qb2ludHM7XG4gICAgICAgICAgICBwb2ludENsb3VkLm51bVZpc2libGVQb2ludHMgKz0gbm9kZS5udW1Qb2ludHM7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gcXVldWVJdGVtLnBhcmVudDtcbiAgICAgICAgICAgIGlmIChpc0dlb21ldHJ5Tm9kZShub2RlKSAmJiAoIXBhcmVudE5vZGUgfHwgaXNUcmVlTm9kZShwYXJlbnROb2RlKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5sb2FkZWQgJiYgbG9hZGVkVG9HUFVUaGlzRnJhbWUgPCBNQVhfTE9BRFNfVE9fR1BVKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBwb2ludENsb3VkLnRvVHJlZU5vZGUobm9kZSwgcGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZFRvR1BVVGhpc0ZyYW1lKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub2RlLmZhaWxlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sb2FkZWQgJiYgbG9hZGVkVG9HUFVUaGlzRnJhbWUgPj0gTUFYX0xPQURTX1RPX0dQVSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhjZWVkZWRNYXhMb2Fkc1RvR1BVID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bmxvYWRlZEdlb21ldHJ5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Q2xvdWQudmlzaWJsZUdlb21ldHJ5LnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlTG9hZEZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1RyZWVOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlTm9kZVZpc2liaWxpdHkocG9pbnRDbG91ZCwgbm9kZSwgdmlzaWJsZU5vZGVzKTtcbiAgICAgICAgICAgICAgICBwb2ludENsb3VkLnZpc2libGVHZW9tZXRyeS5wdXNoKG5vZGUuZ2VvbWV0cnlOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSAwLjUgKiByZW5kZXJlci5nZXRTaXplKHRoaXMuX3JlbmRlcmVyU2l6ZSkuaGVpZ2h0ICogcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVDaGlsZFZpc2liaWxpdHkocXVldWVJdGVtLCBwcmlvcml0eVF1ZXVlLCBwb2ludENsb3VkLCBub2RlLCBjYW1lcmFQb3NpdGlvbnNbcG9pbnRDbG91ZEluZGV4XSwgY2FtZXJhLCBoYWxmSGVpZ2h0KTtcbiAgICAgICAgfSAvLyBlbmQgcHJpb3JpdHkgcXVldWUgbG9vcFxuICAgICAgICBjb25zdCBudW1Ob2Rlc1RvTG9hZCA9IE1hdGgubWluKHRoaXMubWF4TnVtTm9kZXNMb2FkaW5nLCB1bmxvYWRlZEdlb21ldHJ5Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IG5vZGVMb2FkUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ob2Rlc1RvTG9hZDsgaSsrKSB7XG4gICAgICAgICAgICBub2RlTG9hZFByb21pc2VzLnB1c2godW5sb2FkZWRHZW9tZXRyeVtpXS5sb2FkKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2aXNpYmxlTm9kZXM6IHZpc2libGVOb2RlcyxcbiAgICAgICAgICAgIG51bVZpc2libGVQb2ludHM6IG51bVZpc2libGVQb2ludHMsXG4gICAgICAgICAgICBleGNlZWRlZE1heExvYWRzVG9HUFU6IGV4Y2VlZGVkTWF4TG9hZHNUb0dQVSxcbiAgICAgICAgICAgIG5vZGVMb2FkRmFpbGVkOiBub2RlTG9hZEZhaWxlZCxcbiAgICAgICAgICAgIG5vZGVMb2FkUHJvbWlzZXM6IG5vZGVMb2FkUHJvbWlzZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZVRyZWVOb2RlVmlzaWJpbGl0eShwb2ludENsb3VkLCBub2RlLCB2aXNpYmxlTm9kZXMpIHtcbiAgICAgICAgdGhpcy5scnUudG91Y2gobm9kZS5nZW9tZXRyeU5vZGUpO1xuICAgICAgICBjb25zdCBzY2VuZU5vZGUgPSBub2RlLnNjZW5lTm9kZTtcbiAgICAgICAgc2NlbmVOb2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICBzY2VuZU5vZGUubWF0ZXJpYWwgPSBwb2ludENsb3VkLm1hdGVyaWFsO1xuICAgICAgICBzY2VuZU5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIHNjZW5lTm9kZS5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHBvaW50Q2xvdWQubWF0cml4V29ybGQsIHNjZW5lTm9kZS5tYXRyaXgpO1xuICAgICAgICB2aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveFZpc2liaWxpdHkocG9pbnRDbG91ZCwgbm9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUNoaWxkVmlzaWJpbGl0eShxdWV1ZUl0ZW0sIHByaW9yaXR5UXVldWUsIHBvaW50Q2xvdWQsIG5vZGUsIGNhbWVyYVBvc2l0aW9uLCBjYW1lcmEsIGhhbGZIZWlnaHQpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzcGhlcmUgPSBjaGlsZC5ib3VuZGluZ1NwaGVyZTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvKGNhbWVyYVBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XG4gICAgICAgICAgICBsZXQgcHJvamVjdGlvbkZhY3RvciA9IDAuMDtcbiAgICAgICAgICAgIGlmIChjYW1lcmEudHlwZSA9PT0gUEVSU1BFQ1RJVkVfQ0FNRVJBKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyc3BlY3RpdmUgPSBjYW1lcmE7XG4gICAgICAgICAgICAgICAgY29uc3QgZm92ID0gKHBlcnNwZWN0aXZlLmZvdiAqIE1hdGguUEkpIC8gMTgwLjA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2xvcGUgPSBNYXRoLnRhbihmb3YgLyAyLjApO1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25GYWN0b3IgPSBoYWxmSGVpZ2h0IC8gKHNsb3BlICogZGlzdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3J0aG9ncmFwaGljID0gY2FtZXJhO1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb25GYWN0b3IgPSAoMiAqIGhhbGZIZWlnaHQpIC8gKG9ydGhvZ3JhcGhpYy50b3AgLSBvcnRob2dyYXBoaWMuYm90dG9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNjcmVlblBpeGVsUmFkaXVzID0gcmFkaXVzICogcHJvamVjdGlvbkZhY3RvcjtcbiAgICAgICAgICAgIC8vIERvbid0IGFkZCB0aGUgbm9kZSBpZiBpdCdsbCBiZSB0b28gc21hbGwgb24gdGhlIHNjcmVlbi5cbiAgICAgICAgICAgIGlmIChzY3JlZW5QaXhlbFJhZGl1cyA8IHBvaW50Q2xvdWQubWluTm9kZVBpeGVsU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9kZXMgd2hpY2ggYXJlIGxhcmdlciB3aWxsIGhhdmUgcHJpb3JpdHkgaW4gbG9hZGluZy9kaXNwbGF5aW5nLlxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZGlzdGFuY2UgPCByYWRpdXMgPyBOdW1iZXIuTUFYX1ZBTFVFIDogc2NyZWVuUGl4ZWxSYWRpdXMgKyAxIC8gZGlzdGFuY2U7XG4gICAgICAgICAgICBwcmlvcml0eVF1ZXVlLnB1c2gobmV3IFF1ZXVlSXRlbShxdWV1ZUl0ZW0ucG9pbnRDbG91ZEluZGV4LCB3ZWlnaHQsIGNoaWxkLCBub2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQm91bmRpbmdCb3hWaXNpYmlsaXR5KHBvaW50Q2xvdWQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHBvaW50Q2xvdWQuc2hvd0JvdW5kaW5nQm94ICYmICFub2RlLmJvdW5kaW5nQm94Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgYm94SGVscGVyID0gbmV3IEJveDNIZWxwZXIobm9kZS5ib3VuZGluZ0JveCk7XG4gICAgICAgICAgICBib3hIZWxwZXIubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgcG9pbnRDbG91ZC5ib3VuZGluZ0JveE5vZGVzLnB1c2goYm94SGVscGVyKTtcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlID0gYm94SGVscGVyO1xuICAgICAgICAgICAgbm9kZS5ib3VuZGluZ0JveE5vZGUubWF0cml4LmNvcHkocG9pbnRDbG91ZC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9pbnRDbG91ZC5zaG93Qm91bmRpbmdCb3ggJiYgbm9kZS5ib3VuZGluZ0JveE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZS5ib3VuZGluZ0JveE5vZGUubWF0cml4LmNvcHkocG9pbnRDbG91ZC5tYXRyaXhXb3JsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXBvaW50Q2xvdWQuc2hvd0JvdW5kaW5nQm94ICYmIG5vZGUuYm91bmRpbmdCb3hOb2RlKSB7XG4gICAgICAgICAgICBub2RlLmJvdW5kaW5nQm94Tm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdWxkQ2xpcChwb2ludENsb3VkLCBib3VuZGluZ0JveCkge1xuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHBvaW50Q2xvdWQubWF0ZXJpYWw7XG4gICAgICAgIGlmIChtYXRlcmlhbC5udW1DbGlwQm94ZXMgPT09IDAgfHwgbWF0ZXJpYWwuY2xpcE1vZGUgIT09IENsaXBNb2RlLkNMSVBfT1VUU0lERSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJveDIgPSBib3VuZGluZ0JveC5jbG9uZSgpO1xuICAgICAgICBwb2ludENsb3VkLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xuICAgICAgICBib3gyLmFwcGx5TWF0cml4NChwb2ludENsb3VkLm1hdHJpeFdvcmxkKTtcbiAgICAgICAgY29uc3QgY2xpcEJveGVzID0gbWF0ZXJpYWwuY2xpcEJveGVzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaXBCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2xpcE1hdHJpeFdvcmxkID0gY2xpcEJveGVzW2ldLm1hdHJpeDtcbiAgICAgICAgICAgIGNvbnN0IGNsaXBCb3hXb3JsZCA9IG5ldyBCb3gzKG5ldyBWZWN0b3IzKC0wLjUsIC0wLjUsIC0wLjUpLCBuZXcgVmVjdG9yMygwLjUsIDAuNSwgMC41KSkuYXBwbHlNYXRyaXg0KGNsaXBNYXRyaXhXb3JsZCk7XG4gICAgICAgICAgICBpZiAoYm94Mi5pbnRlcnNlY3RzQm94KGNsaXBCb3hXb3JsZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9sb2FkLW9jdHJlZSc7XG4iLCJleHBvcnQgKiBmcm9tICcuL21hdGVyaWFscyc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWF0dHJpYnV0ZXMnO1xuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnktbm9kZSc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeSc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZS1ub2RlJztcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZSc7XG5leHBvcnQgKiBmcm9tICcuL3BvaW50LWNsb3VkLXRyZWUnO1xuZXhwb3J0ICogZnJvbSAnLi9wb3RyZWUnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgKiBmcm9tICcuL3ZlcnNpb24nO1xuZXhwb3J0IHsgbG9hZFBPQyBhcyBWMV9MT0FERVIgfSBmcm9tICcuL2xvYWRpbmcnO1xuZXhwb3J0IHsgbG9hZE9jdHJlZSBhcyBWMl9MT0FERVIgfSBmcm9tICcuL2xvYWRpbmcyJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///238\n")},300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"(()=>{\\\"use strict\\\";var __webpack_modules__={256:()=>{eval(\\\"\\\\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\\\\n/**\\\\n * Some types of possible point attribute data formats\\\\n *\\\\n * @class\\\\n */\\\\nconst PointAttributeTypes = {\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\\\\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\\\\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\\\\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\\\\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\\\\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\\\\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\\\\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\\\\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\\\\n};\\\\nlet i = 0;\\\\nfor (const obj in PointAttributeTypes) {\\\\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\\\\n    i++;\\\\n}\\\\n\\\\nclass PointAttribute {\\\\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\\\\n        this.name = name;\\\\n        this.type = type;\\\\n        this.numElements = numElements;\\\\n        this.range = range;\\\\n        this.uri = uri;\\\\n        this.byteSize = this.numElements * this.type.size;\\\\n        this.description = '';\\\\n    }\\\\n}\\\\n\\\\nconst POINT_ATTRIBUTES = {\\\\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\\\\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\\\\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\\\\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\\\\n};\\\\nclass PointAttributes {\\\\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\\\\n        this.attributes = attributes;\\\\n        this.byteSize = byteSize;\\\\n        this.size = size;\\\\n        this.vectors = vectors;\\\\n        if (pointAttributes != null) {\\\\n            for (let i = 0; i < pointAttributes.length; i++) {\\\\n                const pointAttributeName = pointAttributes[i];\\\\n                const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\n                this.attributes.push(pointAttribute);\\\\n                this.byteSize += pointAttribute.byteSize;\\\\n                this.size++;\\\\n            }\\\\n        }\\\\n    }\\\\n    add(pointAttribute) {\\\\n        this.attributes.push(pointAttribute);\\\\n        this.byteSize += pointAttribute.byteSize;\\\\n        this.size++;\\\\n    }\\\\n    addVector(vector) {\\\\n        this.vectors.push(vector);\\\\n    }\\\\n    hasNormals() {\\\\n        for (const name in this.attributes) {\\\\n            const pointAttribute = this.attributes[name];\\\\n            if (pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\\\\n                return true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n    getAttribute(attributeName) {\\\\n        return this.attributes.find(attr => attr.name === attributeName);\\\\n    }\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/loading2/decoder.worker.js\\\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\\\nfunction _nonIterableRest() { throw new TypeError(\\\\\\\"Invalid attempt to destructure non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); }\\\\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \\\\\\\"undefined\\\\\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\\\\\"@@iterator\\\\\\\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\\\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \\\\\\\"undefined\\\\\\\" && o[Symbol.iterator] || o[\\\\\\\"@@iterator\\\\\\\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\\\\\"number\\\\\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\\\\\"Invalid attempt to iterate non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\\\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\\\\\"string\\\\\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\\\\\"Object\\\\\\\" && o.constructor) n = o.constructor.name; if (n === \\\\\\\"Map\\\\\\\" || n === \\\\\\\"Set\\\\\\\") return Array.from(o); if (n === \\\\\\\"Arguments\\\\\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\\\\n\\\\nvar typedArrayMapping = {\\\\n  'int8': Int8Array,\\\\n  'int16': Int16Array,\\\\n  'int32': Int32Array,\\\\n  'int64': Float64Array,\\\\n  'uint8': Uint8Array,\\\\n  'uint16': Uint16Array,\\\\n  'uint32': Uint32Array,\\\\n  'uint64': Float64Array,\\\\n  'float': Float32Array,\\\\n  'double': Float64Array\\\\n};\\\\nonmessage = function onmessage(event) {\\\\n  var _event$data = event.data,\\\\n    buffer = _event$data.buffer,\\\\n    pointAttributes = _event$data.pointAttributes,\\\\n    scale = _event$data.scale,\\\\n    name = _event$data.name,\\\\n    min = _event$data.min,\\\\n    max = _event$data.max,\\\\n    size = _event$data.size,\\\\n    offset = _event$data.offset,\\\\n    numPoints = _event$data.numPoints;\\\\n  var view = new DataView(buffer);\\\\n  var attributeBuffers = {};\\\\n  var attributeOffset = 0;\\\\n  var bytesPerPoint = 0;\\\\n  var _iterator = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step;\\\\n  try {\\\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\\\n      var pointAttribute = _step.value;\\\\n      bytesPerPoint += pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator.e(err);\\\\n  } finally {\\\\n    _iterator.f();\\\\n  }\\\\n  var gridSize = 32;\\\\n  var grid = new Uint32Array(Math.pow(gridSize, 3));\\\\n  var toIndex = function toIndex(x, y, z) {\\\\n    // min is already subtracted\\\\n    var dx = gridSize * x / size.x;\\\\n    var dy = gridSize * y / size.y;\\\\n    var dz = gridSize * z / size.z;\\\\n    var ix = Math.min(parseInt(dx), gridSize - 1);\\\\n    var iy = Math.min(parseInt(dy), gridSize - 1);\\\\n    var iz = Math.min(parseInt(dz), gridSize - 1);\\\\n    var index = ix + iy * gridSize + iz * gridSize * gridSize;\\\\n    return index;\\\\n  };\\\\n  var numOccupiedCells = 0;\\\\n  var tightBoxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\\\\n  var tightBoxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\\\\n  var _iterator2 = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step2;\\\\n  try {\\\\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\\\n      var _pointAttribute = _step2.value;\\\\n      if (['POSITION_CARTESIAN', 'position'].includes(_pointAttribute.name)) {\\\\n        var _buff = new ArrayBuffer(numPoints * 4 * 3);\\\\n        var positions = new Float32Array(_buff);\\\\n        for (var _j = 0; _j < numPoints; _j++) {\\\\n          var pointOffset = _j * bytesPerPoint;\\\\n          var x = view.getInt32(pointOffset + attributeOffset + 0, true) * scale[0] + offset[0] - min.x;\\\\n          var y = view.getInt32(pointOffset + attributeOffset + 4, true) * scale[1] + offset[1] - min.y;\\\\n          var z = view.getInt32(pointOffset + attributeOffset + 8, true) * scale[2] + offset[2] - min.z;\\\\n          tightBoxMin[0] = Math.min(tightBoxMin[0], x);\\\\n          tightBoxMin[1] = Math.min(tightBoxMin[1], y);\\\\n          tightBoxMin[2] = Math.min(tightBoxMin[2], z);\\\\n          tightBoxMax[0] = Math.max(tightBoxMax[0], x);\\\\n          tightBoxMax[1] = Math.max(tightBoxMax[1], y);\\\\n          tightBoxMax[2] = Math.max(tightBoxMax[2], z);\\\\n          var index = toIndex(x, y, z);\\\\n          var count = grid[index]++;\\\\n          if (count === 0) {\\\\n            numOccupiedCells++;\\\\n          }\\\\n          positions[3 * _j + 0] = x;\\\\n          positions[3 * _j + 1] = y;\\\\n          positions[3 * _j + 2] = z;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else if (['RGBA', 'rgba'].includes(_pointAttribute.name)) {\\\\n        var _buff2 = new ArrayBuffer(numPoints * 4);\\\\n        var colors = new Uint8Array(_buff2);\\\\n        for (var _j2 = 0; _j2 < numPoints; _j2++) {\\\\n          var _pointOffset = _j2 * bytesPerPoint;\\\\n          var r = view.getUint16(_pointOffset + attributeOffset + 0, true);\\\\n          var g = view.getUint16(_pointOffset + attributeOffset + 2, true);\\\\n          var b = view.getUint16(_pointOffset + attributeOffset + 4, true);\\\\n          colors[4 * _j2 + 0] = r > 255 ? r / 256 : r;\\\\n          colors[4 * _j2 + 1] = g > 255 ? g / 256 : g;\\\\n          colors[4 * _j2 + 2] = b > 255 ? b / 256 : b;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff2,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else {\\\\n        var _buff3 = new ArrayBuffer(numPoints * 4);\\\\n        var _f = new Float32Array(_buff3);\\\\n        var TypedArray = typedArrayMapping[_pointAttribute.type.name];\\\\n        var preciseBuffer = new TypedArray(numPoints);\\\\n        var _offset2 = 0,\\\\n          _scale2 = 1;\\\\n        var getterMap = {\\\\n          'int8': view.getInt8,\\\\n          'int16': view.getInt16,\\\\n          'int32': view.getInt32,\\\\n          // 'int64':  view.getInt64,\\\\n          'uint8': view.getUint8,\\\\n          'uint16': view.getUint16,\\\\n          'uint32': view.getUint32,\\\\n          // 'uint64': view.getUint64,\\\\n          'float': view.getFloat32,\\\\n          'double': view.getFloat64\\\\n        };\\\\n        var _getter = getterMap[_pointAttribute.type.name].bind(view);\\\\n\\\\n        // compute offset and scale to pack larger types into 32 bit floats\\\\n        if (_pointAttribute.type.size > 4) {\\\\n          var _pointAttribute$range = _slicedToArray(_pointAttribute.range, 2),\\\\n            amin = _pointAttribute$range[0],\\\\n            amax = _pointAttribute$range[1];\\\\n          _offset2 = amin;\\\\n          _scale2 = 1 / (amax - amin);\\\\n        }\\\\n        for (var _j3 = 0; _j3 < numPoints; _j3++) {\\\\n          var _pointOffset2 = _j3 * bytesPerPoint;\\\\n          var _value = _getter(_pointOffset2 + attributeOffset, true);\\\\n          _f[_j3] = (_value - _offset2) * _scale2;\\\\n          preciseBuffer[_j3] = _value;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff3,\\\\n          preciseBuffer: preciseBuffer,\\\\n          attribute: _pointAttribute,\\\\n          offset: _offset2,\\\\n          scale: _scale2\\\\n        };\\\\n      }\\\\n      attributeOffset += _pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator2.e(err);\\\\n  } finally {\\\\n    _iterator2.f();\\\\n  }\\\\n  var occupancy = parseInt(numPoints / numOccupiedCells);\\\\n  {\\\\n    // add indices\\\\n    var buff = new ArrayBuffer(numPoints * 4);\\\\n    var indices = new Uint32Array(buff);\\\\n    for (var i = 0; i < numPoints; i++) {\\\\n      indices[i] = i;\\\\n    }\\\\n    attributeBuffers['INDICES'] = {\\\\n      buffer: buff,\\\\n      attribute: PointAttribute.INDICES\\\\n    };\\\\n  }\\\\n  {\\\\n    // handle attribute vectors\\\\n    var vectors = pointAttributes.vectors;\\\\n    var _iterator3 = _createForOfIteratorHelper(vectors),\\\\n      _step3;\\\\n    try {\\\\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\\\n        var vector = _step3.value;\\\\n        var _name = vector.name,\\\\n          attributes = vector.attributes;\\\\n        var numVectorElements = attributes.length;\\\\n        var _buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\\\\n        var f32 = new Float32Array(_buffer);\\\\n        var iElement = 0;\\\\n        var _iterator4 = _createForOfIteratorHelper(attributes),\\\\n          _step4;\\\\n        try {\\\\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\\\n            var sourceName = _step4.value;\\\\n            var sourceBuffer = attributeBuffers[sourceName];\\\\n            var _offset = sourceBuffer.offset,\\\\n              _scale = sourceBuffer.scale;\\\\n            var _view = new DataView(sourceBuffer.buffer);\\\\n            var getter = _view.getFloat32.bind(_view);\\\\n            for (var j = 0; j < numPoints; j++) {\\\\n              var value = getter(j * 4, true);\\\\n              f32[j * numVectorElements + iElement] = value / _scale + _offset;\\\\n            }\\\\n            iElement++;\\\\n          }\\\\n        } catch (err) {\\\\n          _iterator4.e(err);\\\\n        } finally {\\\\n          _iterator4.f();\\\\n        }\\\\n        var vecAttribute = new PointAttribute(_name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\\\\n        attributeBuffers[_name] = {\\\\n          buffer: _buffer,\\\\n          attribute: vecAttribute\\\\n        };\\\\n      }\\\\n    } catch (err) {\\\\n      _iterator3.e(err);\\\\n    } finally {\\\\n      _iterator3.f();\\\\n    }\\\\n  }\\\\n  var message = {\\\\n    buffer: buffer,\\\\n    attributeBuffers: attributeBuffers,\\\\n    density: occupancy,\\\\n    tightBoundingBox: {\\\\n      min: tightBoxMin,\\\\n      max: tightBoxMax\\\\n    }\\\\n  };\\\\n  var transferables = [];\\\\n  for (var property in message.attributeBuffers) {\\\\n    transferables.push(message.attributeBuffers[property].buffer);\\\\n  }\\\\n  transferables.push(buffer);\\\\n  postMessage(message, transferables);\\\\n};//# sourceURL=[module]\\\\n\\\")}},__webpack_exports__={};__webpack_modules__[256]()})();\", \"Worker\", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzP2RiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgd29ya2VyIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV29ya2VyX2ZuKCkge1xuICByZXR1cm4gd29ya2VyKFwiKCgpPT57XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXsyNTY6KCk9PntldmFsKFxcXCJcXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sb2FkaW5nMi9wb2ludC1hdHRyaWJ1dGVzLnRzXFxcXG4vKipcXFxcbiAqIFNvbWUgdHlwZXMgb2YgcG9zc2libGUgcG9pbnQgYXR0cmlidXRlIGRhdGEgZm9ybWF0c1xcXFxuICpcXFxcbiAqIEBjbGFzc1xcXFxuICovXFxcXG5jb25zdCBQb2ludEF0dHJpYnV0ZVR5cGVzID0ge1xcXFxuICAgIERBVEFfVFlQRV9ET1VCTEU6IHsgb3JkaW5hbDogMCwgbmFtZTogJ2RvdWJsZScsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfRkxPQVQ6IHsgb3JkaW5hbDogMSwgbmFtZTogJ2Zsb2F0Jywgc2l6ZTogNCB9LFxcXFxuICAgIERBVEFfVFlQRV9JTlQ4OiB7IG9yZGluYWw6IDIsIG5hbWU6ICdpbnQ4Jywgc2l6ZTogMSB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UODogeyBvcmRpbmFsOiAzLCBuYW1lOiAndWludDgnLCBzaXplOiAxIH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDE2OiB7IG9yZGluYWw6IDQsIG5hbWU6ICdpbnQxNicsIHNpemU6IDIgfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIG5hbWU6ICd1aW50MTYnLCBzaXplOiAyIH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDMyOiB7IG9yZGluYWw6IDYsIG5hbWU6ICdpbnQzMicsIHNpemU6IDQgfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDMyOiB7IG9yZGluYWw6IDcsIG5hbWU6ICd1aW50MzInLCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIG5hbWU6ICdpbnQ2NCcsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIG5hbWU6ICd1aW50NjQnLCBzaXplOiA4IH1cXFxcbn07XFxcXG5sZXQgaSA9IDA7XFxcXG5mb3IgKGNvbnN0IG9iaiBpbiBQb2ludEF0dHJpYnV0ZVR5cGVzKSB7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVUeXBlc1tpXSA9IFBvaW50QXR0cmlidXRlVHlwZXNbb2JqXTtcXFxcbiAgICBpKys7XFxcXG59XFxcXG5cXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlIHtcXFxcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBudW1FbGVtZW50cywgcmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV0sIHVyaSA9IHVuZGVmaW5lZCkge1xcXFxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xcXFxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xcXFxuICAgICAgICB0aGlzLm51bUVsZW1lbnRzID0gbnVtRWxlbWVudHM7XFxcXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcXFxcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7XFxcXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnJztcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbmNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XFxcXG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1BPU0lUSU9OX0NBUlRFU0lBTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSR0JBX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcXFxcbiAgICBDT0xPUl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXFxcXG4gICAgUkdCX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCAzKSxcXFxcbiAgICBOT1JNQUxfRkxPQVRTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9GTE9BVFMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXFxcXG4gICAgSU5URU5TSVRZOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lOVEVOU0lUWScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXG4gICAgQ0xBU1NJRklDQVRJT046IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ0xBU1NJRklDQVRJT04nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfU1BIRVJFTUFQUEVEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfT0NUMTYnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXFxcXG4gICAgTk9STUFMOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSRVRVUk5fTlVNQkVSOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1JFVFVSTl9OVU1CRVInLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgTlVNQkVSX09GX1JFVFVSTlM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTlVNQkVSX09GX1JFVFVSTlMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgU09VUkNFX0lEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NPVVJDRV9JRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXG4gICAgSU5ESUNFUzogbmV3IFBvaW50QXR0cmlidXRlKCdJTkRJQ0VTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLCAxKSxcXFxcbiAgICBTUEFDSU5HOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NQQUNJTkcnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMSksXFxcXG4gICAgR1BTX1RJTUU6IG5ldyBQb2ludEF0dHJpYnV0ZSgnR1BTX1RJTUUnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9ET1VCTEUsIDEpXFxcXG59O1xcXFxuY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcXFxcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMgPSBbXSwgYnl0ZVNpemUgPSAwLCBzaXplID0gMCwgdmVjdG9ycyA9IFtdKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZTtcXFxcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcXFxcbiAgICAgICAgdGhpcy52ZWN0b3JzID0gdmVjdG9ycztcXFxcbiAgICAgICAgaWYgKHBvaW50QXR0cmlidXRlcyAhPSBudWxsKSB7XFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50QXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlTmFtZSA9IHBvaW50QXR0cmlidXRlc1tpXTtcXFxcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXG4gICAgICAgICAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcXFxcbiAgICAgICAgICAgIH1cXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBhZGQocG9pbnRBdHRyaWJ1dGUpIHtcXFxcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgICAgICB0aGlzLnNpemUrKztcXFxcbiAgICB9XFxcXG4gICAgYWRkVmVjdG9yKHZlY3Rvcikge1xcXFxuICAgICAgICB0aGlzLnZlY3RvcnMucHVzaCh2ZWN0b3IpO1xcXFxuICAgIH1cXFxcbiAgICBoYXNOb3JtYWxzKCkge1xcXFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tuYW1lXTtcXFxcbiAgICAgICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfU1BIRVJFTUFQUEVEIHx8XFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX0ZMT0FUUyB8fFxcXFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTCB8fFxcXFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9PQ1QxNikge1xcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICB9XFxcXG4gICAgZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGF0dHIgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGVOYW1lKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzXFxcXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxcXFxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFxcXFxcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfVxcXFxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1xcXFxcXFwiQEBpdGVyYXRvclxcXFxcXFwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cXFxcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxcXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFxcXFxcIkBAaXRlcmF0b3JcXFxcXFxcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcXFxcXCJudW1iZXJcXFxcXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cXFxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFxcXFxcXFwiT2JqZWN0XFxcXFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXFxcXFwiTWFwXFxcXFxcXCIgfHwgbiA9PT0gXFxcXFxcXCJTZXRcXFxcXFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcXFxcXFxcIkFyZ3VtZW50c1xcXFxcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxcXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cXFxcblxcXFxudmFyIHR5cGVkQXJyYXlNYXBwaW5nID0ge1xcXFxuICAnaW50OCc6IEludDhBcnJheSxcXFxcbiAgJ2ludDE2JzogSW50MTZBcnJheSxcXFxcbiAgJ2ludDMyJzogSW50MzJBcnJheSxcXFxcbiAgJ2ludDY0JzogRmxvYXQ2NEFycmF5LFxcXFxuICAndWludDgnOiBVaW50OEFycmF5LFxcXFxuICAndWludDE2JzogVWludDE2QXJyYXksXFxcXG4gICd1aW50MzInOiBVaW50MzJBcnJheSxcXFxcbiAgJ3VpbnQ2NCc6IEZsb2F0NjRBcnJheSxcXFxcbiAgJ2Zsb2F0JzogRmxvYXQzMkFycmF5LFxcXFxuICAnZG91YmxlJzogRmxvYXQ2NEFycmF5XFxcXG59O1xcXFxub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XFxcXG4gIHZhciBfZXZlbnQkZGF0YSA9IGV2ZW50LmRhdGEsXFxcXG4gICAgYnVmZmVyID0gX2V2ZW50JGRhdGEuYnVmZmVyLFxcXFxuICAgIHBvaW50QXR0cmlidXRlcyA9IF9ldmVudCRkYXRhLnBvaW50QXR0cmlidXRlcyxcXFxcbiAgICBzY2FsZSA9IF9ldmVudCRkYXRhLnNjYWxlLFxcXFxuICAgIG5hbWUgPSBfZXZlbnQkZGF0YS5uYW1lLFxcXFxuICAgIG1pbiA9IF9ldmVudCRkYXRhLm1pbixcXFxcbiAgICBtYXggPSBfZXZlbnQkZGF0YS5tYXgsXFxcXG4gICAgc2l6ZSA9IF9ldmVudCRkYXRhLnNpemUsXFxcXG4gICAgb2Zmc2V0ID0gX2V2ZW50JGRhdGEub2Zmc2V0LFxcXFxuICAgIG51bVBvaW50cyA9IF9ldmVudCRkYXRhLm51bVBvaW50cztcXFxcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcXFxcbiAgdmFyIGF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcXFxcbiAgdmFyIGF0dHJpYnV0ZU9mZnNldCA9IDA7XFxcXG4gIHZhciBieXRlc1BlclBvaW50ID0gMDtcXFxcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIHBvaW50QXR0cmlidXRlID0gX3N0ZXAudmFsdWU7XFxcXG4gICAgICBieXRlc1BlclBvaW50ICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgIH1cXFxcbiAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IuZigpO1xcXFxuICB9XFxcXG4gIHZhciBncmlkU2l6ZSA9IDMyO1xcXFxuICB2YXIgZ3JpZCA9IG5ldyBVaW50MzJBcnJheShNYXRoLnBvdyhncmlkU2l6ZSwgMykpO1xcXFxuICB2YXIgdG9JbmRleCA9IGZ1bmN0aW9uIHRvSW5kZXgoeCwgeSwgeikge1xcXFxuICAgIC8vIG1pbiBpcyBhbHJlYWR5IHN1YnRyYWN0ZWRcXFxcbiAgICB2YXIgZHggPSBncmlkU2l6ZSAqIHggLyBzaXplLng7XFxcXG4gICAgdmFyIGR5ID0gZ3JpZFNpemUgKiB5IC8gc2l6ZS55O1xcXFxuICAgIHZhciBkeiA9IGdyaWRTaXplICogeiAvIHNpemUuejtcXFxcbiAgICB2YXIgaXggPSBNYXRoLm1pbihwYXJzZUludChkeCksIGdyaWRTaXplIC0gMSk7XFxcXG4gICAgdmFyIGl5ID0gTWF0aC5taW4ocGFyc2VJbnQoZHkpLCBncmlkU2l6ZSAtIDEpO1xcXFxuICAgIHZhciBpeiA9IE1hdGgubWluKHBhcnNlSW50KGR6KSwgZ3JpZFNpemUgLSAxKTtcXFxcbiAgICB2YXIgaW5kZXggPSBpeCArIGl5ICogZ3JpZFNpemUgKyBpeiAqIGdyaWRTaXplICogZ3JpZFNpemU7XFxcXG4gICAgcmV0dXJuIGluZGV4O1xcXFxuICB9O1xcXFxuICB2YXIgbnVtT2NjdXBpZWRDZWxscyA9IDA7XFxcXG4gIHZhciB0aWdodEJveE1pbiA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXTtcXFxcbiAgdmFyIHRpZ2h0Qm94TWF4ID0gW051bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldO1xcXFxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDI7XFxcXG4gIHRyeSB7XFxcXG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcXFxcbiAgICAgIHZhciBfcG9pbnRBdHRyaWJ1dGUgPSBfc3RlcDIudmFsdWU7XFxcXG4gICAgICBpZiAoWydQT1NJVElPTl9DQVJURVNJQU4nLCAncG9zaXRpb24nXS5pbmNsdWRlcyhfcG9pbnRBdHRyaWJ1dGUubmFtZSkpIHtcXFxcbiAgICAgICAgdmFyIF9idWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmYpO1xcXFxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtUG9pbnRzOyBfaisrKSB7XFxcXG4gICAgICAgICAgdmFyIHBvaW50T2Zmc2V0ID0gX2ogKiBieXRlc1BlclBvaW50O1xcXFxuICAgICAgICAgIHZhciB4ID0gdmlldy5nZXRJbnQzMihwb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDAsIHRydWUpICogc2NhbGVbMF0gKyBvZmZzZXRbMF0gLSBtaW4ueDtcXFxcbiAgICAgICAgICB2YXIgeSA9IHZpZXcuZ2V0SW50MzIocG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyA0LCB0cnVlKSAqIHNjYWxlWzFdICsgb2Zmc2V0WzFdIC0gbWluLnk7XFxcXG4gICAgICAgICAgdmFyIHogPSB2aWV3LmdldEludDMyKHBvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgOCwgdHJ1ZSkgKiBzY2FsZVsyXSArIG9mZnNldFsyXSAtIG1pbi56O1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzBdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMF0sIHgpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzFdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMV0sIHkpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzJdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMl0sIHopO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzBdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMF0sIHgpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzFdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMV0sIHkpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzJdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMl0sIHopO1xcXFxuICAgICAgICAgIHZhciBpbmRleCA9IHRvSW5kZXgoeCwgeSwgeik7XFxcXG4gICAgICAgICAgdmFyIGNvdW50ID0gZ3JpZFtpbmRleF0rKztcXFxcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcXFxcbiAgICAgICAgICAgIG51bU9jY3VwaWVkQ2VsbHMrKztcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgICAgcG9zaXRpb25zWzMgKiBfaiArIDBdID0geDtcXFxcbiAgICAgICAgICBwb3NpdGlvbnNbMyAqIF9qICsgMV0gPSB5O1xcXFxuICAgICAgICAgIHBvc2l0aW9uc1szICogX2ogKyAyXSA9IHo7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgYXR0cmlidXRlQnVmZmVyc1tfcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7XFxcXG4gICAgICAgICAgYnVmZmVyOiBfYnVmZixcXFxcbiAgICAgICAgICBhdHRyaWJ1dGU6IF9wb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChbJ1JHQkEnLCAncmdiYSddLmluY2x1ZGVzKF9wb2ludEF0dHJpYnV0ZS5uYW1lKSkge1xcXFxuICAgICAgICB2YXIgX2J1ZmYyID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgY29sb3JzID0gbmV3IFVpbnQ4QXJyYXkoX2J1ZmYyKTtcXFxcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtUG9pbnRzOyBfajIrKykge1xcXFxuICAgICAgICAgIHZhciBfcG9pbnRPZmZzZXQgPSBfajIgKiBieXRlc1BlclBvaW50O1xcXFxuICAgICAgICAgIHZhciByID0gdmlldy5nZXRVaW50MTYoX3BvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgMCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgdmFyIGcgPSB2aWV3LmdldFVpbnQxNihfcG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyAyLCB0cnVlKTtcXFxcbiAgICAgICAgICB2YXIgYiA9IHZpZXcuZ2V0VWludDE2KF9wb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDQsIHRydWUpO1xcXFxuICAgICAgICAgIGNvbG9yc1s0ICogX2oyICsgMF0gPSByID4gMjU1ID8gciAvIDI1NiA6IHI7XFxcXG4gICAgICAgICAgY29sb3JzWzQgKiBfajIgKyAxXSA9IGcgPiAyNTUgPyBnIC8gMjU2IDogZztcXFxcbiAgICAgICAgICBjb2xvcnNbNCAqIF9qMiArIDJdID0gYiA+IDI1NSA/IGIgLyAyNTYgOiBiO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbX3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmYyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3BvaW50QXR0cmlidXRlXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICB2YXIgX2J1ZmYzID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgX2YgPSBuZXcgRmxvYXQzMkFycmF5KF9idWZmMyk7XFxcXG4gICAgICAgIHZhciBUeXBlZEFycmF5ID0gdHlwZWRBcnJheU1hcHBpbmdbX3BvaW50QXR0cmlidXRlLnR5cGUubmFtZV07XFxcXG4gICAgICAgIHZhciBwcmVjaXNlQnVmZmVyID0gbmV3IFR5cGVkQXJyYXkobnVtUG9pbnRzKTtcXFxcbiAgICAgICAgdmFyIF9vZmZzZXQyID0gMCxcXFxcbiAgICAgICAgICBfc2NhbGUyID0gMTtcXFxcbiAgICAgICAgdmFyIGdldHRlck1hcCA9IHtcXFxcbiAgICAgICAgICAnaW50OCc6IHZpZXcuZ2V0SW50OCxcXFxcbiAgICAgICAgICAnaW50MTYnOiB2aWV3LmdldEludDE2LFxcXFxuICAgICAgICAgICdpbnQzMic6IHZpZXcuZ2V0SW50MzIsXFxcXG4gICAgICAgICAgLy8gJ2ludDY0JzogIHZpZXcuZ2V0SW50NjQsXFxcXG4gICAgICAgICAgJ3VpbnQ4Jzogdmlldy5nZXRVaW50OCxcXFxcbiAgICAgICAgICAndWludDE2Jzogdmlldy5nZXRVaW50MTYsXFxcXG4gICAgICAgICAgJ3VpbnQzMic6IHZpZXcuZ2V0VWludDMyLFxcXFxuICAgICAgICAgIC8vICd1aW50NjQnOiB2aWV3LmdldFVpbnQ2NCxcXFxcbiAgICAgICAgICAnZmxvYXQnOiB2aWV3LmdldEZsb2F0MzIsXFxcXG4gICAgICAgICAgJ2RvdWJsZSc6IHZpZXcuZ2V0RmxvYXQ2NFxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICB2YXIgX2dldHRlciA9IGdldHRlck1hcFtfcG9pbnRBdHRyaWJ1dGUudHlwZS5uYW1lXS5iaW5kKHZpZXcpO1xcXFxuXFxcXG4gICAgICAgIC8vIGNvbXB1dGUgb2Zmc2V0IGFuZCBzY2FsZSB0byBwYWNrIGxhcmdlciB0eXBlcyBpbnRvIDMyIGJpdCBmbG9hdHNcXFxcbiAgICAgICAgaWYgKF9wb2ludEF0dHJpYnV0ZS50eXBlLnNpemUgPiA0KSB7XFxcXG4gICAgICAgICAgdmFyIF9wb2ludEF0dHJpYnV0ZSRyYW5nZSA9IF9zbGljZWRUb0FycmF5KF9wb2ludEF0dHJpYnV0ZS5yYW5nZSwgMiksXFxcXG4gICAgICAgICAgICBhbWluID0gX3BvaW50QXR0cmlidXRlJHJhbmdlWzBdLFxcXFxuICAgICAgICAgICAgYW1heCA9IF9wb2ludEF0dHJpYnV0ZSRyYW5nZVsxXTtcXFxcbiAgICAgICAgICBfb2Zmc2V0MiA9IGFtaW47XFxcXG4gICAgICAgICAgX3NjYWxlMiA9IDEgLyAoYW1heCAtIGFtaW4pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG51bVBvaW50czsgX2ozKyspIHtcXFxcbiAgICAgICAgICB2YXIgX3BvaW50T2Zmc2V0MiA9IF9qMyAqIGJ5dGVzUGVyUG9pbnQ7XFxcXG4gICAgICAgICAgdmFyIF92YWx1ZSA9IF9nZXR0ZXIoX3BvaW50T2Zmc2V0MiArIGF0dHJpYnV0ZU9mZnNldCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgX2ZbX2ozXSA9IChfdmFsdWUgLSBfb2Zmc2V0MikgKiBfc2NhbGUyO1xcXFxuICAgICAgICAgIHByZWNpc2VCdWZmZXJbX2ozXSA9IF92YWx1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW19wb2ludEF0dHJpYnV0ZS5uYW1lXSA9IHtcXFxcbiAgICAgICAgICBidWZmZXI6IF9idWZmMyxcXFxcbiAgICAgICAgICBwcmVjaXNlQnVmZmVyOiBwcmVjaXNlQnVmZmVyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3BvaW50QXR0cmlidXRlLFxcXFxuICAgICAgICAgIG9mZnNldDogX29mZnNldDIsXFxcXG4gICAgICAgICAgc2NhbGU6IF9zY2FsZTJcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIGF0dHJpYnV0ZU9mZnNldCArPSBfcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XFxcXG4gICAgfVxcXFxuICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IyLmYoKTtcXFxcbiAgfVxcXFxuICB2YXIgb2NjdXBhbmN5ID0gcGFyc2VJbnQobnVtUG9pbnRzIC8gbnVtT2NjdXBpZWRDZWxscyk7XFxcXG4gIHtcXFxcbiAgICAvLyBhZGQgaW5kaWNlc1xcXFxuICAgIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYpO1xcXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgIGluZGljZXNbaV0gPSBpO1xcXFxuICAgIH1cXFxcbiAgICBhdHRyaWJ1dGVCdWZmZXJzWydJTkRJQ0VTJ10gPSB7XFxcXG4gICAgICBidWZmZXI6IGJ1ZmYsXFxcXG4gICAgICBhdHRyaWJ1dGU6IFBvaW50QXR0cmlidXRlLklORElDRVNcXFxcbiAgICB9O1xcXFxuICB9XFxcXG4gIHtcXFxcbiAgICAvLyBoYW5kbGUgYXR0cmlidXRlIHZlY3RvcnNcXFxcbiAgICB2YXIgdmVjdG9ycyA9IHBvaW50QXR0cmlidXRlcy52ZWN0b3JzO1xcXFxuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodmVjdG9ycyksXFxcXG4gICAgICBfc3RlcDM7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XFxcXG4gICAgICAgIHZhciB2ZWN0b3IgPSBfc3RlcDMudmFsdWU7XFxcXG4gICAgICAgIHZhciBfbmFtZSA9IHZlY3Rvci5uYW1lLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSB2ZWN0b3IuYXR0cmlidXRlcztcXFxcbiAgICAgICAgdmFyIG51bVZlY3RvckVsZW1lbnRzID0gYXR0cmlidXRlcy5sZW5ndGg7XFxcXG4gICAgICAgIHZhciBfYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG51bVZlY3RvckVsZW1lbnRzICogbnVtUG9pbnRzICogNCk7XFxcXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KF9idWZmZXIpO1xcXFxuICAgICAgICB2YXIgaUVsZW1lbnQgPSAwO1xcXFxuICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF0dHJpYnV0ZXMpLFxcXFxuICAgICAgICAgIF9zdGVwNDtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xcXFxuICAgICAgICAgICAgdmFyIHNvdXJjZU5hbWUgPSBfc3RlcDQudmFsdWU7XFxcXG4gICAgICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gYXR0cmlidXRlQnVmZmVyc1tzb3VyY2VOYW1lXTtcXFxcbiAgICAgICAgICAgIHZhciBfb2Zmc2V0ID0gc291cmNlQnVmZmVyLm9mZnNldCxcXFxcbiAgICAgICAgICAgICAgX3NjYWxlID0gc291cmNlQnVmZmVyLnNjYWxlO1xcXFxuICAgICAgICAgICAgdmFyIF92aWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZUJ1ZmZlci5idWZmZXIpO1xcXFxuICAgICAgICAgICAgdmFyIGdldHRlciA9IF92aWV3LmdldEZsb2F0MzIuYmluZChfdmlldyk7XFxcXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcihqICogNCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgICAgIGYzMltqICogbnVtVmVjdG9yRWxlbWVudHMgKyBpRWxlbWVudF0gPSB2YWx1ZSAvIF9zY2FsZSArIF9vZmZzZXQ7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpRWxlbWVudCsrO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XFxcXG4gICAgICAgIH0gZmluYWxseSB7XFxcXG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIHZlY0F0dHJpYnV0ZSA9IG5ldyBQb2ludEF0dHJpYnV0ZShfbmFtZSwgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpO1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW19uYW1lXSA9IHtcXFxcbiAgICAgICAgICBidWZmZXI6IF9idWZmZXIsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiB2ZWNBdHRyaWJ1dGVcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH1cXFxcbiAgICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xcXFxuICAgIH0gZmluYWxseSB7XFxcXG4gICAgICBfaXRlcmF0b3IzLmYoKTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgdmFyIG1lc3NhZ2UgPSB7XFxcXG4gICAgYnVmZmVyOiBidWZmZXIsXFxcXG4gICAgYXR0cmlidXRlQnVmZmVyczogYXR0cmlidXRlQnVmZmVycyxcXFxcbiAgICBkZW5zaXR5OiBvY2N1cGFuY3ksXFxcXG4gICAgdGlnaHRCb3VuZGluZ0JveDoge1xcXFxuICAgICAgbWluOiB0aWdodEJveE1pbixcXFxcbiAgICAgIG1heDogdGlnaHRCb3hNYXhcXFxcbiAgICB9XFxcXG4gIH07XFxcXG4gIHZhciB0cmFuc2ZlcmFibGVzID0gW107XFxcXG4gIGZvciAodmFyIHByb3BlcnR5IGluIG1lc3NhZ2UuYXR0cmlidXRlQnVmZmVycykge1xcXFxuICAgIHRyYW5zZmVyYWJsZXMucHVzaChtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnNbcHJvcGVydHldLmJ1ZmZlcik7XFxcXG4gIH1cXFxcbiAgdHJhbnNmZXJhYmxlcy5wdXNoKGJ1ZmZlcik7XFxcXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xcXFxufTsvLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG5cXFwiKX19LF9fd2VicGFja19leHBvcnRzX189e307X193ZWJwYWNrX21vZHVsZXNfX1syNTZdKCl9KSgpO1wiLCBcIldvcmtlclwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///300\n")},218:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"(()=>{\\\"use strict\\\";var __webpack_modules__={374:()=>{eval(\\\"\\\\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\\\\n/**\\\\n * Some types of possible point attribute data formats\\\\n *\\\\n * @class\\\\n */\\\\nconst PointAttributeTypes = {\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\\\\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\\\\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\\\\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\\\\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\\\\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\\\\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\\\\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\\\\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\\\\n};\\\\nlet i = 0;\\\\nfor (const obj in PointAttributeTypes) {\\\\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\\\\n    i++;\\\\n}\\\\n\\\\nclass PointAttribute {\\\\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\\\\n        this.name = name;\\\\n        this.type = type;\\\\n        this.numElements = numElements;\\\\n        this.range = range;\\\\n        this.uri = uri;\\\\n        this.byteSize = this.numElements * this.type.size;\\\\n        this.description = '';\\\\n    }\\\\n}\\\\n\\\\nconst POINT_ATTRIBUTES = {\\\\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\\\\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\\\\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\\\\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\\\\n};\\\\nclass PointAttributes {\\\\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\\\\n        this.attributes = attributes;\\\\n        this.byteSize = byteSize;\\\\n        this.size = size;\\\\n        this.vectors = vectors;\\\\n        if (pointAttributes != null) {\\\\n            for (let i = 0; i < pointAttributes.length; i++) {\\\\n                const pointAttributeName = pointAttributes[i];\\\\n                const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\n                this.attributes.push(pointAttribute);\\\\n                this.byteSize += pointAttribute.byteSize;\\\\n                this.size++;\\\\n            }\\\\n        }\\\\n    }\\\\n    add(pointAttribute) {\\\\n        this.attributes.push(pointAttribute);\\\\n        this.byteSize += pointAttribute.byteSize;\\\\n        this.size++;\\\\n    }\\\\n    addVector(vector) {\\\\n        this.vectors.push(vector);\\\\n    }\\\\n    hasNormals() {\\\\n        for (const name in this.attributes) {\\\\n            const pointAttribute = this.attributes[name];\\\\n            if (pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL ||\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\\\\n                return true;\\\\n            }\\\\n        }\\\\n        return false;\\\\n    }\\\\n    getAttribute(attributeName) {\\\\n        return this.attributes.find(attr => attr.name === attributeName);\\\\n    }\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/loading2/gltf-decoder.worker.js\\\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \\\\\\\"undefined\\\\\\\" && o[Symbol.iterator] || o[\\\\\\\"@@iterator\\\\\\\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\\\\\"number\\\\\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\\\\\"Invalid attempt to iterate non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\\\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\\\\\"string\\\\\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\\\\\"Object\\\\\\\" && o.constructor) n = o.constructor.name; if (n === \\\\\\\"Map\\\\\\\" || n === \\\\\\\"Set\\\\\\\") return Array.from(o); if (n === \\\\\\\"Arguments\\\\\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\\\\n\\\\nvar typedArrayMapping = {\\\\n  'int8': Int8Array,\\\\n  'int16': Int16Array,\\\\n  'int32': Int32Array,\\\\n  'int64': Float64Array,\\\\n  'uint8': Uint8Array,\\\\n  'uint16': Uint16Array,\\\\n  'uint32': Uint32Array,\\\\n  'uint64': Float64Array,\\\\n  'float': Float32Array,\\\\n  'double': Float64Array\\\\n};\\\\nonmessage = function onmessage(event) {\\\\n  var _event$data = event.data,\\\\n    buffer = _event$data.buffer,\\\\n    pointAttributes = _event$data.pointAttributes,\\\\n    scale = _event$data.scale,\\\\n    name = _event$data.name,\\\\n    min = _event$data.min,\\\\n    max = _event$data.max,\\\\n    size = _event$data.size,\\\\n    offset = _event$data.offset,\\\\n    numPoints = _event$data.numPoints;\\\\n  var view = new DataView(buffer);\\\\n  var attributeBuffers = {};\\\\n  var bytesPerPointPosition = 4 * 3;\\\\n  var gridSize = 32;\\\\n  var grid = new Uint32Array(Math.pow(gridSize, 3));\\\\n  var toIndex = function toIndex(x, y, z) {\\\\n    // min is already subtracted\\\\n    var dx = gridSize * x / size.x;\\\\n    var dy = gridSize * y / size.y;\\\\n    var dz = gridSize * z / size.z;\\\\n    var ix = Math.min(parseInt(dx), gridSize - 1);\\\\n    var iy = Math.min(parseInt(dy), gridSize - 1);\\\\n    var iz = Math.min(parseInt(dz), gridSize - 1);\\\\n    var index = ix + iy * gridSize + iz * gridSize * gridSize;\\\\n    return index;\\\\n  };\\\\n  var numOccupiedCells = 0;\\\\n  var tightBoxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\\\\n  var tightBoxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\\\\n  var _iterator = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step;\\\\n  try {\\\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\\\n      var pointAttribute = _step.value;\\\\n      if ([\\\\\\\"POSITION_CARTESIAN\\\\\\\", \\\\\\\"position\\\\\\\"].includes(pointAttribute.name)) {\\\\n        var _buff = new ArrayBuffer(numPoints * 4 * 3);\\\\n        var positions = new Float32Array(_buff);\\\\n        for (var _j = 0; _j < numPoints; _j++) {\\\\n          var pointOffset = _j * bytesPerPointPosition;\\\\n          var x = view.getFloat32(pointOffset + 0, true) + offset[0] - min.x;\\\\n          var y = view.getFloat32(pointOffset + 4, true) + offset[1] - min.y;\\\\n          var z = view.getFloat32(pointOffset + 8, true) + offset[2] - min.z;\\\\n          tightBoxMin[0] = Math.min(tightBoxMin[0], x);\\\\n          tightBoxMin[1] = Math.min(tightBoxMin[1], y);\\\\n          tightBoxMin[2] = Math.min(tightBoxMin[2], z);\\\\n          tightBoxMax[0] = Math.max(tightBoxMax[0], x);\\\\n          tightBoxMax[1] = Math.max(tightBoxMax[1], y);\\\\n          tightBoxMax[2] = Math.max(tightBoxMax[2], z);\\\\n          var index = toIndex(x, y, z);\\\\n          var count = grid[index]++;\\\\n          if (count === 0) {\\\\n            numOccupiedCells++;\\\\n          }\\\\n          positions[3 * _j + 0] = x;\\\\n          positions[3 * _j + 1] = y;\\\\n          positions[3 * _j + 2] = z;\\\\n        }\\\\n        attributeBuffers[pointAttribute.name] = {\\\\n          buffer: _buff,\\\\n          attribute: pointAttribute\\\\n        };\\\\n      } else if ([\\\\\\\"RGBA\\\\\\\", \\\\\\\"rgba\\\\\\\"].includes(pointAttribute.name)) {\\\\n        attributeBuffers[pointAttribute.name] = {\\\\n          buffer: buffer.slice(numPoints * bytesPerPointPosition),\\\\n          attribute: pointAttribute\\\\n        };\\\\n      }\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator.e(err);\\\\n  } finally {\\\\n    _iterator.f();\\\\n  }\\\\n  var occupancy = parseInt(numPoints / numOccupiedCells);\\\\n  {\\\\n    // add indices\\\\n    var buff = new ArrayBuffer(numPoints * 4);\\\\n    var indices = new Uint32Array(buff);\\\\n    for (var i = 0; i < numPoints; i++) {\\\\n      indices[i] = i;\\\\n    }\\\\n    attributeBuffers[\\\\\\\"INDICES\\\\\\\"] = {\\\\n      buffer: buff,\\\\n      attribute: PointAttribute.INDICES\\\\n    };\\\\n  }\\\\n  {\\\\n    // handle attribute vectors\\\\n    var vectors = pointAttributes.vectors;\\\\n    var _iterator2 = _createForOfIteratorHelper(vectors),\\\\n      _step2;\\\\n    try {\\\\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\\\n        var vector = _step2.value;\\\\n        var _name = vector.name,\\\\n          attributes = vector.attributes;\\\\n        var numVectorElements = attributes.length;\\\\n        var _buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\\\\n        var f32 = new Float32Array(_buffer);\\\\n        var iElement = 0;\\\\n        var _iterator3 = _createForOfIteratorHelper(attributes),\\\\n          _step3;\\\\n        try {\\\\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\\\n            var sourceName = _step3.value;\\\\n            var sourceBuffer = attributeBuffers[sourceName];\\\\n            var _offset = sourceBuffer.offset,\\\\n              _scale = sourceBuffer.scale;\\\\n            var _view = new DataView(sourceBuffer.buffer);\\\\n            var getter = _view.getFloat32.bind(_view);\\\\n            for (var j = 0; j < numPoints; j++) {\\\\n              var value = getter(j * 4, true);\\\\n              f32[j * numVectorElements + iElement] = value / _scale + _offset;\\\\n            }\\\\n            iElement++;\\\\n          }\\\\n        } catch (err) {\\\\n          _iterator3.e(err);\\\\n        } finally {\\\\n          _iterator3.f();\\\\n        }\\\\n        var vecAttribute = new PointAttribute(_name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\\\\n        attributeBuffers[_name] = {\\\\n          buffer: _buffer,\\\\n          attribute: vecAttribute\\\\n        };\\\\n      }\\\\n    } catch (err) {\\\\n      _iterator2.e(err);\\\\n    } finally {\\\\n      _iterator2.f();\\\\n    }\\\\n  }\\\\n  var message = {\\\\n    buffer: buffer,\\\\n    attributeBuffers: attributeBuffers,\\\\n    density: occupancy,\\\\n    tightBoundingBox: {\\\\n      min: tightBoxMin,\\\\n      max: tightBoxMax\\\\n    }\\\\n  };\\\\n  var transferables = [];\\\\n  for (var property in message.attributeBuffers) {\\\\n    transferables.push(message.attributeBuffers[property].buffer);\\\\n  }\\\\n  transferables.push(buffer);\\\\n  postMessage(message, transferables);\\\\n};//# sourceURL=[module]\\\\n\\\")}},__webpack_exports__={};__webpack_modules__[374]()})();\", \"Worker\", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2dsdGYtZGVjb2Rlci53b3JrZXIuanM/MjI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB3b3JrZXIgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC9ydW50aW1lL2lubGluZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXb3JrZXJfZm4oKSB7XG4gIHJldHVybiB3b3JrZXIoXCIoKCk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIF9fd2VicGFja19tb2R1bGVzX189ezM3NDooKT0+e2V2YWwoXFxcIlxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xvYWRpbmcyL3BvaW50LWF0dHJpYnV0ZXMudHNcXFxcbi8qKlxcXFxuICogU29tZSB0eXBlcyBvZiBwb3NzaWJsZSBwb2ludCBhdHRyaWJ1dGUgZGF0YSBmb3JtYXRzXFxcXG4gKlxcXFxuICogQGNsYXNzXFxcXG4gKi9cXFxcbmNvbnN0IFBvaW50QXR0cmlidXRlVHlwZXMgPSB7XFxcXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBuYW1lOiAnZG91YmxlJywgc2l6ZTogOCB9LFxcXFxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBuYW1lOiAnZmxvYXQnLCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgbmFtZTogJ2ludDgnLCBzaXplOiAxIH0sXFxcXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIG5hbWU6ICd1aW50OCcsIHNpemU6IDEgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgbmFtZTogJ2ludDE2Jywgc2l6ZTogMiB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgbmFtZTogJ3VpbnQxNicsIHNpemU6IDIgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UMzI6IHsgb3JkaW5hbDogNiwgbmFtZTogJ2ludDMyJywgc2l6ZTogNCB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgbmFtZTogJ3VpbnQzMicsIHNpemU6IDQgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UNjQ6IHsgb3JkaW5hbDogOCwgbmFtZTogJ2ludDY0Jywgc2l6ZTogOCB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UNjQ6IHsgb3JkaW5hbDogOSwgbmFtZTogJ3VpbnQ2NCcsIHNpemU6IDggfVxcXFxufTtcXFxcbmxldCBpID0gMDtcXFxcbmZvciAoY29uc3Qgb2JqIGluIFBvaW50QXR0cmlidXRlVHlwZXMpIHtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZVR5cGVzW2ldID0gUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdO1xcXFxuICAgIGkrKztcXFxcbn1cXFxcblxcXFxuY2xhc3MgUG9pbnRBdHRyaWJ1dGUge1xcXFxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzLCByYW5nZSA9IFtJbmZpbml0eSwgLUluZmluaXR5XSwgdXJpID0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XFxcXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XFxcXG4gICAgICAgIHRoaXMubnVtRWxlbWVudHMgPSBudW1FbGVtZW50cztcXFxcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xcXFxuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IHRoaXMubnVtRWxlbWVudHMgKiB0aGlzLnR5cGUuc2l6ZTtcXFxcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICcnO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuY29uc3QgUE9JTlRfQVRUUklCVVRFUyA9IHtcXFxcbiAgICBQT1NJVElPTl9DQVJURVNJQU46IG5ldyBQb2ludEF0dHJpYnV0ZSgnUE9TSVRJT05fQ0FSVEVTSUFOJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxuICAgIFJHQkFfUEFDS0VEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NPTE9SX1BBQ0tFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDQpLFxcXFxuICAgIENPTE9SX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcXFxcbiAgICBSR0JfUEFDS0VEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NPTE9SX1BBQ0tFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDMpLFxcXFxuICAgIE5PUk1BTF9GTE9BVFM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMX0ZMT0FUUycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBJTlRFTlNJVFk6IG5ldyBQb2ludEF0dHJpYnV0ZSgnSU5URU5TSVRZJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcXFxcbiAgICBDTEFTU0lGSUNBVElPTjogbmV3IFBvaW50QXR0cmlidXRlKCdDTEFTU0lGSUNBVElPTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcbiAgICBOT1JNQUxfU1BIRVJFTUFQUEVEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9TUEhFUkVNQVBQRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXFxcXG4gICAgTk9STUFMX09DVDE2OiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9PQ1QxNicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcXFxcbiAgICBOT1JNQUw6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxuICAgIFJFVFVSTl9OVU1CRVI6IG5ldyBQb2ludEF0dHJpYnV0ZSgnUkVUVVJOX05VTUJFUicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcbiAgICBOVU1CRVJfT0ZfUkVUVVJOUzogbmV3IFBvaW50QXR0cmlidXRlKCdOVU1CRVJfT0ZfUkVUVVJOUycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcbiAgICBTT1VSQ0VfSUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnU09VUkNFX0lEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcXFxcbiAgICBJTkRJQ0VTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lORElDRVMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UMzIsIDEpLFxcXFxuICAgIFNQQUNJTkc6IG5ldyBQb2ludEF0dHJpYnV0ZSgnU1BBQ0lORycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAxKSxcXFxcbiAgICBHUFNfVElNRTogbmV3IFBvaW50QXR0cmlidXRlKCdHUFNfVElNRScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0RPVUJMRSwgMSlcXFxcbn07XFxcXG5jbGFzcyBQb2ludEF0dHJpYnV0ZXMge1xcXFxuICAgIGNvbnN0cnVjdG9yKHBvaW50QXR0cmlidXRlcywgYXR0cmlidXRlcyA9IFtdLCBieXRlU2l6ZSA9IDAsIHNpemUgPSAwLCB2ZWN0b3JzID0gW10pIHtcXFxcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IGJ5dGVTaXplO1xcXFxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xcXFxuICAgICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xcXFxuICAgICAgICBpZiAocG9pbnRBdHRyaWJ1dGVzICE9IG51bGwpIHtcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGVOYW1lID0gcG9pbnRBdHRyaWJ1dGVzW2ldO1xcXFxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlID0gUE9JTlRfQVRUUklCVVRFU1twb2ludEF0dHJpYnV0ZU5hbWVdO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgICAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIGFkZChwb2ludEF0dHJpYnV0ZSkge1xcXFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XFxcXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xcXFxuICAgIH1cXFxcbiAgICBhZGRWZWN0b3IodmVjdG9yKSB7XFxcXG4gICAgICAgIHRoaXMudmVjdG9ycy5wdXNoKHZlY3Rvcik7XFxcXG4gICAgfVxcXFxuICAgIGhhc05vcm1hbHMoKSB7XFxcXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcXFxcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xcXFxuICAgICAgICAgICAgaWYgKHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9TUEhFUkVNQVBQRUQgfHxcXFxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfRkxPQVRTIHx8XFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMIHx8XFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX09DVDE2KSB7XFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxuICAgIH1cXFxcbiAgICBnZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoYXR0ciA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZU5hbWUpO1xcXFxuICAgIH1cXFxcbn1cXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9zcmMvbG9hZGluZzIvZ2x0Zi1kZWNvZGVyLndvcmtlci5qc1xcXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFxcXFxcIkBAaXRlcmF0b3JcXFxcXFxcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcXFxcXCJudW1iZXJcXFxcXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cXFxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFxcXFxcXFwiT2JqZWN0XFxcXFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXFxcXFwiTWFwXFxcXFxcXCIgfHwgbiA9PT0gXFxcXFxcXCJTZXRcXFxcXFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcXFxcXFxcIkFyZ3VtZW50c1xcXFxcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxcXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cXFxcblxcXFxudmFyIHR5cGVkQXJyYXlNYXBwaW5nID0ge1xcXFxuICAnaW50OCc6IEludDhBcnJheSxcXFxcbiAgJ2ludDE2JzogSW50MTZBcnJheSxcXFxcbiAgJ2ludDMyJzogSW50MzJBcnJheSxcXFxcbiAgJ2ludDY0JzogRmxvYXQ2NEFycmF5LFxcXFxuICAndWludDgnOiBVaW50OEFycmF5LFxcXFxuICAndWludDE2JzogVWludDE2QXJyYXksXFxcXG4gICd1aW50MzInOiBVaW50MzJBcnJheSxcXFxcbiAgJ3VpbnQ2NCc6IEZsb2F0NjRBcnJheSxcXFxcbiAgJ2Zsb2F0JzogRmxvYXQzMkFycmF5LFxcXFxuICAnZG91YmxlJzogRmxvYXQ2NEFycmF5XFxcXG59O1xcXFxub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XFxcXG4gIHZhciBfZXZlbnQkZGF0YSA9IGV2ZW50LmRhdGEsXFxcXG4gICAgYnVmZmVyID0gX2V2ZW50JGRhdGEuYnVmZmVyLFxcXFxuICAgIHBvaW50QXR0cmlidXRlcyA9IF9ldmVudCRkYXRhLnBvaW50QXR0cmlidXRlcyxcXFxcbiAgICBzY2FsZSA9IF9ldmVudCRkYXRhLnNjYWxlLFxcXFxuICAgIG5hbWUgPSBfZXZlbnQkZGF0YS5uYW1lLFxcXFxuICAgIG1pbiA9IF9ldmVudCRkYXRhLm1pbixcXFxcbiAgICBtYXggPSBfZXZlbnQkZGF0YS5tYXgsXFxcXG4gICAgc2l6ZSA9IF9ldmVudCRkYXRhLnNpemUsXFxcXG4gICAgb2Zmc2V0ID0gX2V2ZW50JGRhdGEub2Zmc2V0LFxcXFxuICAgIG51bVBvaW50cyA9IF9ldmVudCRkYXRhLm51bVBvaW50cztcXFxcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcXFxcbiAgdmFyIGF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcXFxcbiAgdmFyIGJ5dGVzUGVyUG9pbnRQb3NpdGlvbiA9IDQgKiAzO1xcXFxuICB2YXIgZ3JpZFNpemUgPSAzMjtcXFxcbiAgdmFyIGdyaWQgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5wb3coZ3JpZFNpemUsIDMpKTtcXFxcbiAgdmFyIHRvSW5kZXggPSBmdW5jdGlvbiB0b0luZGV4KHgsIHksIHopIHtcXFxcbiAgICAvLyBtaW4gaXMgYWxyZWFkeSBzdWJ0cmFjdGVkXFxcXG4gICAgdmFyIGR4ID0gZ3JpZFNpemUgKiB4IC8gc2l6ZS54O1xcXFxuICAgIHZhciBkeSA9IGdyaWRTaXplICogeSAvIHNpemUueTtcXFxcbiAgICB2YXIgZHogPSBncmlkU2l6ZSAqIHogLyBzaXplLno7XFxcXG4gICAgdmFyIGl4ID0gTWF0aC5taW4ocGFyc2VJbnQoZHgpLCBncmlkU2l6ZSAtIDEpO1xcXFxuICAgIHZhciBpeSA9IE1hdGgubWluKHBhcnNlSW50KGR5KSwgZ3JpZFNpemUgLSAxKTtcXFxcbiAgICB2YXIgaXogPSBNYXRoLm1pbihwYXJzZUludChkeiksIGdyaWRTaXplIC0gMSk7XFxcXG4gICAgdmFyIGluZGV4ID0gaXggKyBpeSAqIGdyaWRTaXplICsgaXogKiBncmlkU2l6ZSAqIGdyaWRTaXplO1xcXFxuICAgIHJldHVybiBpbmRleDtcXFxcbiAgfTtcXFxcbiAgdmFyIG51bU9jY3VwaWVkQ2VsbHMgPSAwO1xcXFxuICB2YXIgdGlnaHRCb3hNaW4gPSBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV07XFxcXG4gIHZhciB0aWdodEJveE1heCA9IFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXTtcXFxcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIHBvaW50QXR0cmlidXRlID0gX3N0ZXAudmFsdWU7XFxcXG4gICAgICBpZiAoW1xcXFxcXFwiUE9TSVRJT05fQ0FSVEVTSUFOXFxcXFxcXCIsIFxcXFxcXFwicG9zaXRpb25cXFxcXFxcIl0uaW5jbHVkZXMocG9pbnRBdHRyaWJ1dGUubmFtZSkpIHtcXFxcbiAgICAgICAgdmFyIF9idWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmYpO1xcXFxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtUG9pbnRzOyBfaisrKSB7XFxcXG4gICAgICAgICAgdmFyIHBvaW50T2Zmc2V0ID0gX2ogKiBieXRlc1BlclBvaW50UG9zaXRpb247XFxcXG4gICAgICAgICAgdmFyIHggPSB2aWV3LmdldEZsb2F0MzIocG9pbnRPZmZzZXQgKyAwLCB0cnVlKSArIG9mZnNldFswXSAtIG1pbi54O1xcXFxuICAgICAgICAgIHZhciB5ID0gdmlldy5nZXRGbG9hdDMyKHBvaW50T2Zmc2V0ICsgNCwgdHJ1ZSkgKyBvZmZzZXRbMV0gLSBtaW4ueTtcXFxcbiAgICAgICAgICB2YXIgeiA9IHZpZXcuZ2V0RmxvYXQzMihwb2ludE9mZnNldCArIDgsIHRydWUpICsgb2Zmc2V0WzJdIC0gbWluLno7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMF0gPSBNYXRoLm1pbih0aWdodEJveE1pblswXSwgeCk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMV0gPSBNYXRoLm1pbih0aWdodEJveE1pblsxXSwgeSk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMl0gPSBNYXRoLm1pbih0aWdodEJveE1pblsyXSwgeik7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMF0gPSBNYXRoLm1heCh0aWdodEJveE1heFswXSwgeCk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMV0gPSBNYXRoLm1heCh0aWdodEJveE1heFsxXSwgeSk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heCh0aWdodEJveE1heFsyXSwgeik7XFxcXG4gICAgICAgICAgdmFyIGluZGV4ID0gdG9JbmRleCh4LCB5LCB6KTtcXFxcbiAgICAgICAgICB2YXIgY291bnQgPSBncmlkW2luZGV4XSsrO1xcXFxuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgbnVtT2NjdXBpZWRDZWxscysrO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBwb3NpdGlvbnNbMyAqIF9qICsgMF0gPSB4O1xcXFxuICAgICAgICAgIHBvc2l0aW9uc1szICogX2ogKyAxXSA9IHk7XFxcXG4gICAgICAgICAgcG9zaXRpb25zWzMgKiBfaiArIDJdID0gejtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmYsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChbXFxcXFxcXCJSR0JBXFxcXFxcXCIsIFxcXFxcXFwicmdiYVxcXFxcXFwiXS5pbmNsdWRlcyhwb2ludEF0dHJpYnV0ZS5uYW1lKSkge1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLnNsaWNlKG51bVBvaW50cyAqIGJ5dGVzUGVyUG9pbnRQb3NpdGlvbiksXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IuZigpO1xcXFxuICB9XFxcXG4gIHZhciBvY2N1cGFuY3kgPSBwYXJzZUludChudW1Qb2ludHMgLyBudW1PY2N1cGllZENlbGxzKTtcXFxcbiAge1xcXFxuICAgIC8vIGFkZCBpbmRpY2VzXFxcXG4gICAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCk7XFxcXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoYnVmZik7XFxcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xcXFxuICAgICAgaW5kaWNlc1tpXSA9IGk7XFxcXG4gICAgfVxcXFxuICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbXFxcXFxcXCJJTkRJQ0VTXFxcXFxcXCJdID0ge1xcXFxuICAgICAgYnVmZmVyOiBidWZmLFxcXFxuICAgICAgYXR0cmlidXRlOiBQb2ludEF0dHJpYnV0ZS5JTkRJQ0VTXFxcXG4gICAgfTtcXFxcbiAgfVxcXFxuICB7XFxcXG4gICAgLy8gaGFuZGxlIGF0dHJpYnV0ZSB2ZWN0b3JzXFxcXG4gICAgdmFyIHZlY3RvcnMgPSBwb2ludEF0dHJpYnV0ZXMudmVjdG9ycztcXFxcbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZlY3RvcnMpLFxcXFxuICAgICAgX3N0ZXAyO1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xcXFxuICAgICAgICB2YXIgdmVjdG9yID0gX3N0ZXAyLnZhbHVlO1xcXFxuICAgICAgICB2YXIgX25hbWUgPSB2ZWN0b3IubmFtZSxcXFxcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gdmVjdG9yLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgIHZhciBudW1WZWN0b3JFbGVtZW50cyA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xcXFxuICAgICAgICB2YXIgX2J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihudW1WZWN0b3JFbGVtZW50cyAqIG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShfYnVmZmVyKTtcXFxcbiAgICAgICAgdmFyIGlFbGVtZW50ID0gMDtcXFxcbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhdHRyaWJ1dGVzKSxcXFxcbiAgICAgICAgICBfc3RlcDM7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcXFxcbiAgICAgICAgICAgIHZhciBzb3VyY2VOYW1lID0gX3N0ZXAzLnZhbHVlO1xcXFxuICAgICAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IGF0dHJpYnV0ZUJ1ZmZlcnNbc291cmNlTmFtZV07XFxcXG4gICAgICAgICAgICB2YXIgX29mZnNldCA9IHNvdXJjZUJ1ZmZlci5vZmZzZXQsXFxcXG4gICAgICAgICAgICAgIF9zY2FsZSA9IHNvdXJjZUJ1ZmZlci5zY2FsZTtcXFxcbiAgICAgICAgICAgIHZhciBfdmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2VCdWZmZXIuYnVmZmVyKTtcXFxcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBfdmlldy5nZXRGbG9hdDMyLmJpbmQoX3ZpZXcpO1xcXFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIoaiAqIDQsIHRydWUpO1xcXFxuICAgICAgICAgICAgICBmMzJbaiAqIG51bVZlY3RvckVsZW1lbnRzICsgaUVsZW1lbnRdID0gdmFsdWUgLyBfc2NhbGUgKyBfb2Zmc2V0O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaUVsZW1lbnQrKztcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xcXFxuICAgICAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHZhciB2ZWNBdHRyaWJ1dGUgPSBuZXcgUG9pbnRBdHRyaWJ1dGUoX25hbWUsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKTtcXFxcbiAgICAgICAgYXR0cmlidXRlQnVmZmVyc1tfbmFtZV0gPSB7XFxcXG4gICAgICAgICAgYnVmZmVyOiBfYnVmZmVyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogdmVjQXR0cmlidXRlXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcXFxcbiAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgX2l0ZXJhdG9yMi5mKCk7XFxcXG4gICAgfVxcXFxuICB9XFxcXG4gIHZhciBtZXNzYWdlID0ge1xcXFxuICAgIGJ1ZmZlcjogYnVmZmVyLFxcXFxuICAgIGF0dHJpYnV0ZUJ1ZmZlcnM6IGF0dHJpYnV0ZUJ1ZmZlcnMsXFxcXG4gICAgZGVuc2l0eTogb2NjdXBhbmN5LFxcXFxuICAgIHRpZ2h0Qm91bmRpbmdCb3g6IHtcXFxcbiAgICAgIG1pbjogdGlnaHRCb3hNaW4sXFxcXG4gICAgICBtYXg6IHRpZ2h0Qm94TWF4XFxcXG4gICAgfVxcXFxuICB9O1xcXFxuICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcXFxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnMpIHtcXFxcbiAgICB0cmFuc2ZlcmFibGVzLnB1c2gobWVzc2FnZS5hdHRyaWJ1dGVCdWZmZXJzW3Byb3BlcnR5XS5idWZmZXIpO1xcXFxuICB9XFxcXG4gIHRyYW5zZmVyYWJsZXMucHVzaChidWZmZXIpO1xcXFxuICBwb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcXFxcbn07Ly8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuXFxcIil9fSxfX3dlYnBhY2tfZXhwb3J0c19fPXt9O19fd2VicGFja19tb2R1bGVzX19bMzc0XSgpfSkoKTtcIiwgXCJXb3JrZXJcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///218\n")},91:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()("(()=>{\\"use strict\\";var __webpack_modules__={717:()=>{eval(\'\\\\n;// CONCATENATED MODULE: ./src/point-attributes.ts\\\\n// -------------------------------------------------------------------------------------------------\\\\n// Converted to Typescript and adapted from https://github.com/potree/potree\\\\n// -------------------------------------------------------------------------------------------------\\\\nvar PointAttributeName;\\\\n(function (PointAttributeName) {\\\\n    PointAttributeName[PointAttributeName[\\"POSITION_CARTESIAN\\"] = 0] = \\"POSITION_CARTESIAN\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_PACKED\\"] = 1] = \\"COLOR_PACKED\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_1\\"] = 2] = \\"COLOR_FLOATS_1\\";\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_255\\"] = 3] = \\"COLOR_FLOATS_255\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_FLOATS\\"] = 4] = \\"NORMAL_FLOATS\\";\\\\n    PointAttributeName[PointAttributeName[\\"FILLER\\"] = 5] = \\"FILLER\\";\\\\n    PointAttributeName[PointAttributeName[\\"INTENSITY\\"] = 6] = \\"INTENSITY\\";\\\\n    PointAttributeName[PointAttributeName[\\"CLASSIFICATION\\"] = 7] = \\"CLASSIFICATION\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_SPHEREMAPPED\\"] = 8] = \\"NORMAL_SPHEREMAPPED\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_OCT16\\"] = 9] = \\"NORMAL_OCT16\\";\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL\\"] = 10] = \\"NORMAL\\";\\\\n})(PointAttributeName || (PointAttributeName = {}));\\\\nconst POINT_ATTRIBUTE_TYPES = {\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\\\\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\\\\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\\\\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\\\\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\\\\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\\\\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\\\\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\\\\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\\\\n};\\\\nfunction makePointAttribute(name, type, numElements) {\\\\n    return {\\\\n        name,\\\\n        type,\\\\n        numElements,\\\\n        byteSize: numElements * type.size,\\\\n    };\\\\n}\\\\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\\\\nconst POINT_ATTRIBUTES = {\\\\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n    RGBA_PACKED,\\\\n    COLOR_PACKED: RGBA_PACKED,\\\\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\\\\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\\\\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\n};\\\\nclass PointAttributes {\\\\n    constructor(pointAttributeNames = []) {\\\\n        this.attributes = [];\\\\n        this.byteSize = 0;\\\\n        this.size = 0;\\\\n        for (let i = 0; i < pointAttributeNames.length; i++) {\\\\n            const pointAttributeName = pointAttributeNames[i];\\\\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\n            this.attributes.push(pointAttribute);\\\\n            this.byteSize += pointAttribute.byteSize;\\\\n            this.size++;\\\\n        }\\\\n    }\\\\n    add(pointAttribute) {\\\\n        this.attributes.push(pointAttribute);\\\\n        this.byteSize += pointAttribute.byteSize;\\\\n        this.size++;\\\\n    }\\\\n    hasColors() {\\\\n        return this.attributes.find(isColorAttribute) !== undefined;\\\\n    }\\\\n    hasNormals() {\\\\n        return this.attributes.find(isNormalAttribute) !== undefined;\\\\n    }\\\\n}\\\\nfunction isColorAttribute({ name }) {\\\\n    return name === PointAttributeName.COLOR_PACKED;\\\\n}\\\\nfunction isNormalAttribute({ name }) {\\\\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\\\\n        name === PointAttributeName.NORMAL_FLOATS ||\\\\n        name === PointAttributeName.NORMAL ||\\\\n        name === PointAttributeName.NORMAL_OCT16);\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./src/version.ts\\\\nclass Version {\\\\n    constructor(version) {\\\\n        this.versionMinor = 0;\\\\n        this.version = version;\\\\n        const vmLength = version.indexOf(\\\\\'.\\\\\') === -1 ? version.length : version.indexOf(\\\\\'.\\\\\');\\\\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\\\\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\\\\n        if (isNaN(this.versionMinor)) {\\\\n            this.versionMinor = 0;\\\\n        }\\\\n    }\\\\n    newerThan(version) {\\\\n        const v = new Version(version);\\\\n        if (this.versionMajor > v.versionMajor) {\\\\n            return true;\\\\n        }\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\\\\n            return true;\\\\n        }\\\\n        else {\\\\n            return false;\\\\n        }\\\\n    }\\\\n    equalOrHigher(version) {\\\\n        const v = new Version(version);\\\\n        if (this.versionMajor > v.versionMajor) {\\\\n            return true;\\\\n        }\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\\\\n            return true;\\\\n        }\\\\n        else {\\\\n            return false;\\\\n        }\\\\n    }\\\\n    upTo(version) {\\\\n        return !this.newerThan(version);\\\\n    }\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/custom-array-view.ts\\\\n/**\\\\n * Adapted from Potree.js http://potree.org\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\n */\\\\n// http://jsperf.com/uint8array-vs-dataview3/3\\\\n// tslint:disable:no-bitwise\\\\nclass CustomArrayView {\\\\n    constructor(buffer) {\\\\n        this.tmp = new ArrayBuffer(4);\\\\n        this.tmpf = new Float32Array(this.tmp);\\\\n        this.tmpu8 = new Uint8Array(this.tmp);\\\\n        this.u8 = new Uint8Array(buffer);\\\\n    }\\\\n    getUint32(i) {\\\\n        return (this.u8[i + 3] << 24) | (this.u8[i + 2] << 16) | (this.u8[i + 1] << 8) | this.u8[i];\\\\n    }\\\\n    getUint16(i) {\\\\n        return (this.u8[i + 1] << 8) | this.u8[i];\\\\n    }\\\\n    getFloat32(i) {\\\\n        const tmpu8 = this.tmpu8;\\\\n        const u8 = this.u8;\\\\n        const tmpf = this.tmpf;\\\\n        tmpu8[0] = u8[i + 0];\\\\n        tmpu8[1] = u8[i + 1];\\\\n        tmpu8[2] = u8[i + 2];\\\\n        tmpu8[3] = u8[i + 3];\\\\n        return tmpf[0];\\\\n    }\\\\n    getUint8(i) {\\\\n        return this.u8[i];\\\\n    }\\\\n}\\\\n// tslint:enable:no-bitwise\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/binary-decoder-worker-internal.ts\\\\n/**\\\\n * Adapted from Potree.js http://potree.org\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\n */\\\\n\\\\n\\\\n\\\\n// IE11 does not have Math.sign(), this has been adapted from CoreJS es6.math.sign.js for TypeScript\\\\nconst mathSign = Math.sign ||\\\\n    function (x) {\\\\n        // tslint:disable-next-line:triple-equals\\\\n        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\\\\n    };\\\\nfunction handleMessage(event) {\\\\n    const buffer = event.data.buffer;\\\\n    const pointAttributes = event.data.pointAttributes;\\\\n    const ctx = {\\\\n        attributeBuffers: {},\\\\n        currentOffset: 0,\\\\n        data: new CustomArrayView(buffer),\\\\n        mean: [0, 0, 0],\\\\n        nodeOffset: event.data.offset,\\\\n        numPoints: event.data.buffer.byteLength / pointAttributes.byteSize,\\\\n        pointAttributes,\\\\n        scale: event.data.scale,\\\\n        tightBoxMax: [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\\\\n        tightBoxMin: [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\\\\n        transferables: [],\\\\n        version: new Version(event.data.version),\\\\n    };\\\\n    for (const pointAttribute of ctx.pointAttributes.attributes) {\\\\n        decodeAndAddAttribute(pointAttribute, ctx);\\\\n        ctx.currentOffset += pointAttribute.byteSize;\\\\n    }\\\\n    const indices = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const iIndices = new Uint32Array(indices);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        iIndices[i] = i;\\\\n    }\\\\n    if (!ctx.attributeBuffers[PointAttributeName.CLASSIFICATION]) {\\\\n        addEmptyClassificationBuffer(ctx);\\\\n    }\\\\n    const message = {\\\\n        buffer: buffer,\\\\n        mean: ctx.mean,\\\\n        attributeBuffers: ctx.attributeBuffers,\\\\n        tightBoundingBox: { min: ctx.tightBoxMin, max: ctx.tightBoxMax },\\\\n        indices,\\\\n    };\\\\n    postMessage(message, ctx.transferables);\\\\n}\\\\nfunction addEmptyClassificationBuffer(ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const classifications = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        classifications[i] = 0;\\\\n    }\\\\n    ctx.attributeBuffers[PointAttributeName.CLASSIFICATION] = {\\\\n        buffer,\\\\n        attribute: POINT_ATTRIBUTES.CLASSIFICATION,\\\\n    };\\\\n}\\\\nfunction decodeAndAddAttribute(attribute, ctx) {\\\\n    const decodedAttribute = decodePointAttribute(attribute, ctx);\\\\n    if (decodedAttribute === undefined) {\\\\n        return;\\\\n    }\\\\n    ctx.attributeBuffers[decodedAttribute.attribute.name] = decodedAttribute;\\\\n    ctx.transferables.push(decodedAttribute.buffer);\\\\n}\\\\nfunction decodePointAttribute(attribute, ctx) {\\\\n    switch (attribute.name) {\\\\n        case PointAttributeName.POSITION_CARTESIAN:\\\\n            return decodePositionCartesian(attribute, ctx);\\\\n        case PointAttributeName.COLOR_PACKED:\\\\n            return decodeColor(attribute, ctx);\\\\n        case PointAttributeName.INTENSITY:\\\\n            return decodeIntensity(attribute, ctx);\\\\n        case PointAttributeName.CLASSIFICATION:\\\\n            return decodeClassification(attribute, ctx);\\\\n        case PointAttributeName.NORMAL_SPHEREMAPPED:\\\\n            return decodeNormalSphereMapped(attribute, ctx);\\\\n        case PointAttributeName.NORMAL_OCT16:\\\\n            return decodeNormalOct16(attribute, ctx);\\\\n        case PointAttributeName.NORMAL:\\\\n            return decodeNormal(attribute, ctx);\\\\n        default:\\\\n            return undefined;\\\\n    }\\\\n}\\\\nfunction decodePositionCartesian(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const positions = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        let x;\\\\n        let y;\\\\n        let z;\\\\n        if (ctx.version.newerThan(\\\\\'1.3\\\\\')) {\\\\n            x = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0) * ctx.scale;\\\\n            y = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 4) * ctx.scale;\\\\n            z = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 8) * ctx.scale;\\\\n        }\\\\n        else {\\\\n            x = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 0) + ctx.nodeOffset[0];\\\\n            y = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 4) + ctx.nodeOffset[1];\\\\n            z = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 8) + ctx.nodeOffset[2];\\\\n        }\\\\n        positions[3 * i + 0] = x;\\\\n        positions[3 * i + 1] = y;\\\\n        positions[3 * i + 2] = z;\\\\n        ctx.mean[0] += x / ctx.numPoints;\\\\n        ctx.mean[1] += y / ctx.numPoints;\\\\n        ctx.mean[2] += z / ctx.numPoints;\\\\n        ctx.tightBoxMin[0] = Math.min(ctx.tightBoxMin[0], x);\\\\n        ctx.tightBoxMin[1] = Math.min(ctx.tightBoxMin[1], y);\\\\n        ctx.tightBoxMin[2] = Math.min(ctx.tightBoxMin[2], z);\\\\n        ctx.tightBoxMax[0] = Math.max(ctx.tightBoxMax[0], x);\\\\n        ctx.tightBoxMax[1] = Math.max(ctx.tightBoxMax[1], y);\\\\n        ctx.tightBoxMax[2] = Math.max(ctx.tightBoxMax[2], z);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeColor(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 3);\\\\n    const colors = new Uint8Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        colors[3 * i + 0] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0);\\\\n        colors[3 * i + 1] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 1);\\\\n        colors[3 * i + 2] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 2);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeIntensity(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\n    const intensities = new Float32Array(buffer);\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\n        intensities[i] = ctx.data.getUint16(ctx.currentOffset + i * ctx.pointAttributes.byteSize);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeClassification(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints);\\\\n    const classifications = new Uint8Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        classifications[j] = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize);\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeNormalSphereMapped(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\n        const ex = bx / 255;\\\\n        const ey = by / 255;\\\\n        let nx = ex * 2 - 1;\\\\n        let ny = ey * 2 - 1;\\\\n        let nz = 1;\\\\n        const nw = -1;\\\\n        const l = nx * -nx + ny * -ny + nz * -nw;\\\\n        nz = l;\\\\n        nx = nx * Math.sqrt(l);\\\\n        ny = ny * Math.sqrt(l);\\\\n        nx = nx * 2;\\\\n        ny = ny * 2;\\\\n        nz = nz * 2 - 1;\\\\n        normals[3 * j + 0] = nx;\\\\n        normals[3 * j + 1] = ny;\\\\n        normals[3 * j + 2] = nz;\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\nfunction decodeNormalOct16(attribute, ctx) {\\\\n    const buff = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buff);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\n        const u = (bx / 255) * 2 - 1;\\\\n        const v = (by / 255) * 2 - 1;\\\\n        let z = 1 - Math.abs(u) - Math.abs(v);\\\\n        let x = 0;\\\\n        let y = 0;\\\\n        if (z >= 0) {\\\\n            x = u;\\\\n            y = v;\\\\n        }\\\\n        else {\\\\n            x = -(v / mathSign(v) - 1) / mathSign(u);\\\\n            y = -(u / mathSign(u) - 1) / mathSign(v);\\\\n        }\\\\n        const length = Math.sqrt(x * x + y * y + z * z);\\\\n        x = x / length;\\\\n        y = y / length;\\\\n        z = z / length;\\\\n        normals[3 * j + 0] = x;\\\\n        normals[3 * j + 1] = y;\\\\n        normals[3 * j + 2] = z;\\\\n    }\\\\n    return { buffer: buff, attribute };\\\\n}\\\\nfunction decodeNormal(attribute, ctx) {\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\n    const normals = new Float32Array(buffer);\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\n        const x = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\n        const y = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 4);\\\\n        const z = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 8);\\\\n        normals[3 * j + 0] = x;\\\\n        normals[3 * j + 1] = y;\\\\n        normals[3 * j + 2] = z;\\\\n    }\\\\n    return { buffer, attribute };\\\\n}\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/workers/binary-decoder.worker.js\\\\n\\\\n\\\\n/*eslint-disable */\\\\nonmessage = handleMessage;//# sourceURL=[module]\\\\n\')}},__webpack_exports__={};__webpack_modules__[717]()})();", "Worker", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvd29ya2Vycy9iaW5hcnktZGVjb2Rlci53b3JrZXIuanM/YzYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB3b3JrZXIgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC9ydW50aW1lL2lubGluZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXb3JrZXJfZm4oKSB7XG4gIHJldHVybiB3b3JrZXIoXCIoKCk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIF9fd2VicGFja19tb2R1bGVzX189ezcxNzooKT0+e2V2YWwoJ1xcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BvaW50LWF0dHJpYnV0ZXMudHNcXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbi8vIENvbnZlcnRlZCB0byBUeXBlc2NyaXB0IGFuZCBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3BvdHJlZS9wb3RyZWVcXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcbnZhciBQb2ludEF0dHJpYnV0ZU5hbWU7XFxcXG4oZnVuY3Rpb24gKFBvaW50QXR0cmlidXRlTmFtZSkge1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIlBPU0lUSU9OX0NBUlRFU0lBTlxcXCJdID0gMF0gPSBcXFwiUE9TSVRJT05fQ0FSVEVTSUFOXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9QQUNLRURcXFwiXSA9IDFdID0gXFxcIkNPTE9SX1BBQ0tFRFxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiQ09MT1JfRkxPQVRTXzFcXFwiXSA9IDJdID0gXFxcIkNPTE9SX0ZMT0FUU18xXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9GTE9BVFNfMjU1XFxcIl0gPSAzXSA9IFxcXCJDT0xPUl9GTE9BVFNfMjU1XFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJOT1JNQUxfRkxPQVRTXFxcIl0gPSA0XSA9IFxcXCJOT1JNQUxfRkxPQVRTXFxcIjtcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJGSUxMRVJcXFwiXSA9IDVdID0gXFxcIkZJTExFUlxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiSU5URU5TSVRZXFxcIl0gPSA2XSA9IFxcXCJJTlRFTlNJVFlcXFwiO1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIkNMQVNTSUZJQ0FUSU9OXFxcIl0gPSA3XSA9IFxcXCJDTEFTU0lGSUNBVElPTlxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiTk9STUFMX1NQSEVSRU1BUFBFRFxcXCJdID0gOF0gPSBcXFwiTk9STUFMX1NQSEVSRU1BUFBFRFxcXCI7XFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiTk9STUFMX09DVDE2XFxcIl0gPSA5XSA9IFxcXCJOT1JNQUxfT0NUMTZcXFwiO1xcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIk5PUk1BTFxcXCJdID0gMTBdID0gXFxcIk5PUk1BTFxcXCI7XFxcXG59KShQb2ludEF0dHJpYnV0ZU5hbWUgfHwgKFBvaW50QXR0cmlidXRlTmFtZSA9IHt9KSk7XFxcXG5jb25zdCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMgPSB7XFxcXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBzaXplOiA4IH0sXFxcXG4gICAgREFUQV9UWVBFX0ZMT0FUOiB7IG9yZGluYWw6IDEsIHNpemU6IDQgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UODogeyBvcmRpbmFsOiAyLCBzaXplOiAxIH0sXFxcXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIHNpemU6IDEgfSxcXFxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgc2l6ZTogMiB9LFxcXFxuICAgIERBVEFfVFlQRV9VSU5UMTY6IHsgb3JkaW5hbDogNSwgc2l6ZTogMiB9LFxcXFxuICAgIERBVEFfVFlQRV9JTlQzMjogeyBvcmRpbmFsOiA2LCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX1VJTlQzMjogeyBvcmRpbmFsOiA3LCBzaXplOiA0IH0sXFxcXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIHNpemU6IDggfSxcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIHNpemU6IDggfSxcXFxcbn07XFxcXG5mdW5jdGlvbiBtYWtlUG9pbnRBdHRyaWJ1dGUobmFtZSwgdHlwZSwgbnVtRWxlbWVudHMpIHtcXFxcbiAgICByZXR1cm4ge1xcXFxuICAgICAgICBuYW1lLFxcXFxuICAgICAgICB0eXBlLFxcXFxuICAgICAgICBudW1FbGVtZW50cyxcXFxcbiAgICAgICAgYnl0ZVNpemU6IG51bUVsZW1lbnRzICogdHlwZS5zaXplLFxcXFxuICAgIH07XFxcXG59XFxcXG5jb25zdCBSR0JBX1BBQ0tFRCA9IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDQpO1xcXFxuY29uc3QgUE9JTlRfQVRUUklCVVRFUyA9IHtcXFxcbiAgICBQT1NJVElPTl9DQVJURVNJQU46IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuUE9TSVRJT05fQ0FSVEVTSUFOLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcbiAgICBSR0JBX1BBQ0tFRCxcXFxcbiAgICBDT0xPUl9QQUNLRUQ6IFJHQkFfUEFDS0VELFxcXFxuICAgIFJHQl9QQUNLRUQ6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDMpLFxcXFxuICAgIE5PUk1BTF9GTE9BVFM6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX0ZMT0FUUywgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXFxcXG4gICAgRklMTEVSXzFCOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkZJTExFUiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXG4gICAgSU5URU5TSVRZOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWSwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UMTYsIDEpLFxcXFxuICAgIENMQVNTSUZJQ0FUSU9OOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcbiAgICBOT1JNQUxfU1BIRVJFTUFQUEVEOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxuICAgIE5PUk1BTDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUwsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxufTtcXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlcyB7XFxcXG4gICAgY29uc3RydWN0b3IocG9pbnRBdHRyaWJ1dGVOYW1lcyA9IFtdKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcXFxcbiAgICAgICAgdGhpcy5zaXplID0gMDtcXFxcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZU5hbWVzW2ldO1xcXFxuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XFxcXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgICAgICAgICAgdGhpcy5zaXplKys7XFxcXG4gICAgICAgIH1cXFxcbiAgICB9XFxcXG4gICAgYWRkKHBvaW50QXR0cmlidXRlKSB7XFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICAgICAgdGhpcy5zaXplKys7XFxcXG4gICAgfVxcXFxuICAgIGhhc0NvbG9ycygpIHtcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGlzQ29sb3JBdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQ7XFxcXG4gICAgfVxcXFxuICAgIGhhc05vcm1hbHMoKSB7XFxcXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZmluZChpc05vcm1hbEF0dHJpYnV0ZSkgIT09IHVuZGVmaW5lZDtcXFxcbiAgICB9XFxcXG59XFxcXG5mdW5jdGlvbiBpc0NvbG9yQXR0cmlidXRlKHsgbmFtZSB9KSB7XFxcXG4gICAgcmV0dXJuIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQ7XFxcXG59XFxcXG5mdW5jdGlvbiBpc05vcm1hbEF0dHJpYnV0ZSh7IG5hbWUgfSkge1xcXFxuICAgIHJldHVybiAobmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQgfHxcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9GTE9BVFMgfHxcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCB8fFxcXFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2KTtcXFxcbn1cXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3ZlcnNpb24udHNcXFxcbmNsYXNzIFZlcnNpb24ge1xcXFxuICAgIGNvbnN0cnVjdG9yKHZlcnNpb24pIHtcXFxcbiAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uO1xcXFxuICAgICAgICBjb25zdCB2bUxlbmd0aCA9IHZlcnNpb24uaW5kZXhPZihcXFxcJy5cXFxcJykgPT09IC0xID8gdmVyc2lvbi5sZW5ndGggOiB2ZXJzaW9uLmluZGV4T2YoXFxcXCcuXFxcXCcpO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSwgMTApO1xcXFxuICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKHZtTGVuZ3RoICsgMSksIDEwKTtcXFxcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMudmVyc2lvbk1pbm9yKSkge1xcXFxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxuICAgICAgICB9XFxcXG4gICAgfVxcXFxuICAgIG5ld2VyVGhhbih2ZXJzaW9uKSB7XFxcXG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVmVyc2lvbih2ZXJzaW9uKTtcXFxcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+IHYudmVyc2lvbk1pbm9yKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICBlcXVhbE9ySGlnaGVyKHZlcnNpb24pIHtcXFxcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xcXFxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcikge1xcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKSB7XFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcbiAgICAgICAgfVxcXFxuICAgIH1cXFxcbiAgICB1cFRvKHZlcnNpb24pIHtcXFxcbiAgICAgICAgcmV0dXJuICF0aGlzLm5ld2VyVGhhbih2ZXJzaW9uKTtcXFxcbiAgICB9XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93b3JrZXJzL2N1c3RvbS1hcnJheS12aWV3LnRzXFxcXG4vKipcXFxcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcXFxcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXFxcXG4gKi9cXFxcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3VpbnQ4YXJyYXktdnMtZGF0YXZpZXczLzNcXFxcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcXFxcbmNsYXNzIEN1c3RvbUFycmF5VmlldyB7XFxcXG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XFxcXG4gICAgICAgIHRoaXMudG1wID0gbmV3IEFycmF5QnVmZmVyKDQpO1xcXFxuICAgICAgICB0aGlzLnRtcGYgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudG1wKTtcXFxcbiAgICAgICAgdGhpcy50bXB1OCA9IG5ldyBVaW50OEFycmF5KHRoaXMudG1wKTtcXFxcbiAgICAgICAgdGhpcy51OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXG4gICAgfVxcXFxuICAgIGdldFVpbnQzMihpKSB7XFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgM10gPDwgMjQpIHwgKHRoaXMudThbaSArIDJdIDw8IDE2KSB8ICh0aGlzLnU4W2kgKyAxXSA8PCA4KSB8IHRoaXMudThbaV07XFxcXG4gICAgfVxcXFxuICAgIGdldFVpbnQxNihpKSB7XFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgMV0gPDwgOCkgfCB0aGlzLnU4W2ldO1xcXFxuICAgIH1cXFxcbiAgICBnZXRGbG9hdDMyKGkpIHtcXFxcbiAgICAgICAgY29uc3QgdG1wdTggPSB0aGlzLnRtcHU4O1xcXFxuICAgICAgICBjb25zdCB1OCA9IHRoaXMudTg7XFxcXG4gICAgICAgIGNvbnN0IHRtcGYgPSB0aGlzLnRtcGY7XFxcXG4gICAgICAgIHRtcHU4WzBdID0gdThbaSArIDBdO1xcXFxuICAgICAgICB0bXB1OFsxXSA9IHU4W2kgKyAxXTtcXFxcbiAgICAgICAgdG1wdThbMl0gPSB1OFtpICsgMl07XFxcXG4gICAgICAgIHRtcHU4WzNdID0gdThbaSArIDNdO1xcXFxuICAgICAgICByZXR1cm4gdG1wZlswXTtcXFxcbiAgICB9XFxcXG4gICAgZ2V0VWludDgoaSkge1xcXFxuICAgICAgICByZXR1cm4gdGhpcy51OFtpXTtcXFxcbiAgICB9XFxcXG59XFxcXG4vLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3dvcmtlcnMvYmluYXJ5LWRlY29kZXItd29ya2VyLWludGVybmFsLnRzXFxcXG4vKipcXFxcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcXFxcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXFxcXG4gKi9cXFxcblxcXFxuXFxcXG5cXFxcbi8vIElFMTEgZG9lcyBub3QgaGF2ZSBNYXRoLnNpZ24oKSwgdGhpcyBoYXMgYmVlbiBhZGFwdGVkIGZyb20gQ29yZUpTIGVzNi5tYXRoLnNpZ24uanMgZm9yIFR5cGVTY3JpcHRcXFxcbmNvbnN0IG1hdGhTaWduID0gTWF0aC5zaWduIHx8XFxcXG4gICAgZnVuY3Rpb24gKHgpIHtcXFxcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcXFxcbiAgICAgICAgcmV0dXJuICh4ID0gK3gpID09IDAgfHwgeCAhPSB4ID8geCA6IHggPCAwID8gLTEgOiAxO1xcXFxuICAgIH07XFxcXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gZXZlbnQuZGF0YS5idWZmZXI7XFxcXG4gICAgY29uc3QgcG9pbnRBdHRyaWJ1dGVzID0gZXZlbnQuZGF0YS5wb2ludEF0dHJpYnV0ZXM7XFxcXG4gICAgY29uc3QgY3R4ID0ge1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzOiB7fSxcXFxcbiAgICAgICAgY3VycmVudE9mZnNldDogMCxcXFxcbiAgICAgICAgZGF0YTogbmV3IEN1c3RvbUFycmF5VmlldyhidWZmZXIpLFxcXFxuICAgICAgICBtZWFuOiBbMCwgMCwgMF0sXFxcXG4gICAgICAgIG5vZGVPZmZzZXQ6IGV2ZW50LmRhdGEub2Zmc2V0LFxcXFxuICAgICAgICBudW1Qb2ludHM6IGV2ZW50LmRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLyBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUsXFxcXG4gICAgICAgIHBvaW50QXR0cmlidXRlcyxcXFxcbiAgICAgICAgc2NhbGU6IGV2ZW50LmRhdGEuc2NhbGUsXFxcXG4gICAgICAgIHRpZ2h0Qm94TWF4OiBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXFxcXG4gICAgICAgIHRpZ2h0Qm94TWluOiBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV0sXFxcXG4gICAgICAgIHRyYW5zZmVyYWJsZXM6IFtdLFxcXFxuICAgICAgICB2ZXJzaW9uOiBuZXcgVmVyc2lvbihldmVudC5kYXRhLnZlcnNpb24pLFxcXFxuICAgIH07XFxcXG4gICAgZm9yIChjb25zdCBwb2ludEF0dHJpYnV0ZSBvZiBjdHgucG9pbnRBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpIHtcXFxcbiAgICAgICAgZGVjb2RlQW5kQWRkQXR0cmlidXRlKHBvaW50QXR0cmlidXRlLCBjdHgpO1xcXFxuICAgICAgICBjdHguY3VycmVudE9mZnNldCArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcbiAgICB9XFxcXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXG4gICAgY29uc3QgaUluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoaW5kaWNlcyk7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgaUluZGljZXNbaV0gPSBpO1xcXFxuICAgIH1cXFxcbiAgICBpZiAoIWN0eC5hdHRyaWJ1dGVCdWZmZXJzW1BvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTl0pIHtcXFxcbiAgICAgICAgYWRkRW1wdHlDbGFzc2lmaWNhdGlvbkJ1ZmZlcihjdHgpO1xcXFxuICAgIH1cXFxcbiAgICBjb25zdCBtZXNzYWdlID0ge1xcXFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcXFxcbiAgICAgICAgbWVhbjogY3R4Lm1lYW4sXFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnM6IGN0eC5hdHRyaWJ1dGVCdWZmZXJzLFxcXFxuICAgICAgICB0aWdodEJvdW5kaW5nQm94OiB7IG1pbjogY3R4LnRpZ2h0Qm94TWluLCBtYXg6IGN0eC50aWdodEJveE1heCB9LFxcXFxuICAgICAgICBpbmRpY2VzLFxcXFxuICAgIH07XFxcXG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSwgY3R4LnRyYW5zZmVyYWJsZXMpO1xcXFxufVxcXFxuZnVuY3Rpb24gYWRkRW1wdHlDbGFzc2lmaWNhdGlvbkJ1ZmZlcihjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQpO1xcXFxuICAgIGNvbnN0IGNsYXNzaWZpY2F0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5udW1Qb2ludHM7IGkrKykge1xcXFxuICAgICAgICBjbGFzc2lmaWNhdGlvbnNbaV0gPSAwO1xcXFxuICAgIH1cXFxcbiAgICBjdHguYXR0cmlidXRlQnVmZmVyc1tQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT05dID0ge1xcXFxuICAgICAgICBidWZmZXIsXFxcXG4gICAgICAgIGF0dHJpYnV0ZTogUE9JTlRfQVRUUklCVVRFUy5DTEFTU0lGSUNBVElPTixcXFxcbiAgICB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlQW5kQWRkQXR0cmlidXRlKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgZGVjb2RlZEF0dHJpYnV0ZSA9IGRlY29kZVBvaW50QXR0cmlidXRlKGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICBpZiAoZGVjb2RlZEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XFxcXG4gICAgICAgIHJldHVybjtcXFxcbiAgICB9XFxcXG4gICAgY3R4LmF0dHJpYnV0ZUJ1ZmZlcnNbZGVjb2RlZEF0dHJpYnV0ZS5hdHRyaWJ1dGUubmFtZV0gPSBkZWNvZGVkQXR0cmlidXRlO1xcXFxuICAgIGN0eC50cmFuc2ZlcmFibGVzLnB1c2goZGVjb2RlZEF0dHJpYnV0ZS5idWZmZXIpO1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlUG9pbnRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBzd2l0Y2ggKGF0dHJpYnV0ZS5uYW1lKSB7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLlBPU0lUSU9OX0NBUlRFU0lBTjpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVQb3NpdGlvbkNhcnRlc2lhbihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRDpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVDb2xvcihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWTpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVJbnRlbnNpdHkoYXR0cmlidXRlLCBjdHgpO1xcXFxuICAgICAgICBjYXNlIFBvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTjpcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVDbGFzc2lmaWNhdGlvbihhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQ6XFxcXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlTm9ybWFsU3BoZXJlTWFwcGVkKGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2OlxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbE9jdDE2KGF0dHJpYnV0ZSwgY3R4KTtcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMOlxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbChhdHRyaWJ1dGUsIGN0eCk7XFxcXG4gICAgICAgIGRlZmF1bHQ6XFxcXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xcXFxuICAgIH1cXFxcbn1cXFxcbmZ1bmN0aW9uIGRlY29kZVBvc2l0aW9uQ2FydGVzaWFuKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXG4gICAgY29uc3QgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lm51bVBvaW50czsgaSsrKSB7XFxcXG4gICAgICAgIGxldCB4O1xcXFxuICAgICAgICBsZXQgeTtcXFxcbiAgICAgICAgbGV0IHo7XFxcXG4gICAgICAgIGlmIChjdHgudmVyc2lvbi5uZXdlclRoYW4oXFxcXCcxLjNcXFxcJykpIHtcXFxcbiAgICAgICAgICAgIHggPSBjdHguZGF0YS5nZXRVaW50MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApICogY3R4LnNjYWxlO1xcXFxuICAgICAgICAgICAgeSA9IGN0eC5kYXRhLmdldFVpbnQzMihjdHguY3VycmVudE9mZnNldCArIGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgNCkgKiBjdHguc2NhbGU7XFxcXG4gICAgICAgICAgICB6ID0gY3R4LmRhdGEuZ2V0VWludDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA4KSAqIGN0eC5zY2FsZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBlbHNlIHtcXFxcbiAgICAgICAgICAgIHggPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCkgKyBjdHgubm9kZU9mZnNldFswXTtcXFxcbiAgICAgICAgICAgIHkgPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgNCkgKyBjdHgubm9kZU9mZnNldFsxXTtcXFxcbiAgICAgICAgICAgIHogPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgOCkgKyBjdHgubm9kZU9mZnNldFsyXTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBwb3NpdGlvbnNbMyAqIGkgKyAwXSA9IHg7XFxcXG4gICAgICAgIHBvc2l0aW9uc1szICogaSArIDFdID0geTtcXFxcbiAgICAgICAgcG9zaXRpb25zWzMgKiBpICsgMl0gPSB6O1xcXFxuICAgICAgICBjdHgubWVhblswXSArPSB4IC8gY3R4Lm51bVBvaW50cztcXFxcbiAgICAgICAgY3R4Lm1lYW5bMV0gKz0geSAvIGN0eC5udW1Qb2ludHM7XFxcXG4gICAgICAgIGN0eC5tZWFuWzJdICs9IHogLyBjdHgubnVtUG9pbnRzO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMF0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMF0sIHgpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMV0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMV0sIHkpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMl0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMl0sIHopO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMF0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMF0sIHgpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMV0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMV0sIHkpO1xcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMl0sIHopO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlQ29sb3IoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDMpO1xcXFxuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgY29sb3JzWzMgKiBpICsgMF0gPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCk7XFxcXG4gICAgICAgIGNvbG9yc1szICogaSArIDFdID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDEpO1xcXFxuICAgICAgICBjb2xvcnNbMyAqIGkgKyAyXSA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAyKTtcXFxcbiAgICB9XFxcXG4gICAgcmV0dXJuIHsgYnVmZmVyLCBhdHRyaWJ1dGUgfTtcXFxcbn1cXFxcbmZ1bmN0aW9uIGRlY29kZUludGVuc2l0eShhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXG4gICAgY29uc3QgaW50ZW5zaXRpZXMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgICAgaW50ZW5zaXRpZXNbaV0gPSBjdHguZGF0YS5nZXRVaW50MTYoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSk7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVDbGFzc2lmaWNhdGlvbihhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzKTtcXFxcbiAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgIGNsYXNzaWZpY2F0aW9uc1tqXSA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUpO1xcXFxuICAgIH1cXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxufVxcXFxuZnVuY3Rpb24gZGVjb2RlTm9ybWFsU3BoZXJlTWFwcGVkKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXG4gICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN0eC5udW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICBjb25zdCBieCA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgYnkgPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7XFxcXG4gICAgICAgIGNvbnN0IGV4ID0gYnggLyAyNTU7XFxcXG4gICAgICAgIGNvbnN0IGV5ID0gYnkgLyAyNTU7XFxcXG4gICAgICAgIGxldCBueCA9IGV4ICogMiAtIDE7XFxcXG4gICAgICAgIGxldCBueSA9IGV5ICogMiAtIDE7XFxcXG4gICAgICAgIGxldCBueiA9IDE7XFxcXG4gICAgICAgIGNvbnN0IG53ID0gLTE7XFxcXG4gICAgICAgIGNvbnN0IGwgPSBueCAqIC1ueCArIG55ICogLW55ICsgbnogKiAtbnc7XFxcXG4gICAgICAgIG56ID0gbDtcXFxcbiAgICAgICAgbnggPSBueCAqIE1hdGguc3FydChsKTtcXFxcbiAgICAgICAgbnkgPSBueSAqIE1hdGguc3FydChsKTtcXFxcbiAgICAgICAgbnggPSBueCAqIDI7XFxcXG4gICAgICAgIG55ID0gbnkgKiAyO1xcXFxuICAgICAgICBueiA9IG56ICogMiAtIDE7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IG54O1xcXFxuICAgICAgICBub3JtYWxzWzMgKiBqICsgMV0gPSBueTtcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDJdID0gbno7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVOb3JtYWxPY3QxNihhdHRyaWJ1dGUsIGN0eCkge1xcXFxuICAgIGNvbnN0IGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmKTtcXFxcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN0eC5udW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICBjb25zdCBieCA9IGN0eC5kYXRhLmdldFVpbnQ4KGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgYnkgPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7XFxcXG4gICAgICAgIGNvbnN0IHUgPSAoYnggLyAyNTUpICogMiAtIDE7XFxcXG4gICAgICAgIGNvbnN0IHYgPSAoYnkgLyAyNTUpICogMiAtIDE7XFxcXG4gICAgICAgIGxldCB6ID0gMSAtIE1hdGguYWJzKHUpIC0gTWF0aC5hYnModik7XFxcXG4gICAgICAgIGxldCB4ID0gMDtcXFxcbiAgICAgICAgbGV0IHkgPSAwO1xcXFxuICAgICAgICBpZiAoeiA+PSAwKSB7XFxcXG4gICAgICAgICAgICB4ID0gdTtcXFxcbiAgICAgICAgICAgIHkgPSB2O1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGVsc2Uge1xcXFxuICAgICAgICAgICAgeCA9IC0odiAvIG1hdGhTaWduKHYpIC0gMSkgLyBtYXRoU2lnbih1KTtcXFxcbiAgICAgICAgICAgIHkgPSAtKHUgLyBtYXRoU2lnbih1KSAtIDEpIC8gbWF0aFNpZ24odik7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XFxcXG4gICAgICAgIHggPSB4IC8gbGVuZ3RoO1xcXFxuICAgICAgICB5ID0geSAvIGxlbmd0aDtcXFxcbiAgICAgICAgeiA9IHogLyBsZW5ndGg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IHg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAxXSA9IHk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAyXSA9IHo7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlcjogYnVmZiwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5mdW5jdGlvbiBkZWNvZGVOb3JtYWwoYXR0cmlidXRlLCBjdHgpIHtcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgIGNvbnN0IHggPSBjdHguZGF0YS5nZXRGbG9hdDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyAwKTtcXFxcbiAgICAgICAgY29uc3QgeSA9IGN0eC5kYXRhLmdldEZsb2F0MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBqICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDQpO1xcXFxuICAgICAgICBjb25zdCB6ID0gY3R4LmRhdGEuZ2V0RmxvYXQzMihjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgOCk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IHg7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAxXSA9IHk7XFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAyXSA9IHo7XFxcXG4gICAgfVxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXG59XFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vc3JjL3dvcmtlcnMvYmluYXJ5LWRlY29kZXIud29ya2VyLmpzXFxcXG5cXFxcblxcXFxuLyplc2xpbnQtZGlzYWJsZSAqL1xcXFxub25tZXNzYWdlID0gaGFuZGxlTWVzc2FnZTsvLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG4nKX19LF9fd2VicGFja19leHBvcnRzX189e307X193ZWJwYWNrX21vZHVsZXNfX1s3MTddKCl9KSgpO1wiLCBcIldvcmtlclwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///91\n')},512:module=>{eval('\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error("Inline worker is not supported");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanM/ZWNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLCBuby11c2UtYmVmb3JlLWRlZmluZSwgbmV3LWNhcCAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgd29ya2VyQ29uc3RydWN0b3IsIHdvcmtlck9wdGlvbnMsIHVybCkge1xuICB2YXIgZ2xvYmFsU2NvcGUgPSBzZWxmIHx8IHdpbmRvdztcblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgYmxvYjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTmV3IEFQSVxuICAgICAgICBibG9iID0gbmV3IGdsb2JhbFNjb3BlLkJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQmxvYkJ1aWxkZXIgPSBEZXByZWNhdGVkLCBidXQgd2lkZWx5IGltcGxlbWVudGVkXG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbFNjb3BlLkJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLldlYktpdEJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1vekJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgIGJsb2IgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYi5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFVSTCA9IGdsb2JhbFNjb3BlLlVSTCB8fCBnbG9iYWxTY29wZS53ZWJraXRVUkw7XG4gICAgICB2YXIgb2JqZWN0VVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKG9iamVjdFVSTCwgd29ya2VyT3B0aW9ucyk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpLCB3b3JrZXJPcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZVt3b3JrZXJDb25zdHJ1Y3Rvcl0odXJsLCB3b3JrZXJPcHRpb25zKTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///512\n')},604:g=>{g.exports=__WEBPACK_EXTERNAL_MODULE__604__}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var t=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var t in I)__webpack_require__.o(I,t)&&!__webpack_require__.o(g,t)&&Object.defineProperty(g,t,{enumerable:!0,get:I[t]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(238);return __webpack_exports__})()));
\ No newline at end of file
+!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I(require("three")):"function"==typeof define&&define.amd?define("potree",["three"],I):"object"==typeof exports?exports.potree=I(require("three")):g.potree=I(g.three)}(self,(__WEBPACK_EXTERNAL_MODULE__604__=>(()=>{"use strict";var __webpack_modules__={414:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nuniform mat4 projectionMatrix;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D map;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n\\tfloat dx = 1.0 / screenWidth;\\n\\tfloat dy = 1.0 / screenHeight;\\n\\n\\tvec3 color = vec3(0.0, 0.0, 0.0);\\n\\tcolor += texture2D(map, vUv + vec2(-dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx, -dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,   0)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(-dx,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(  0,  dy)).rgb;\\n\\tcolor += texture2D(map, vUv + vec2(+dx,  dy)).rgb;\\n    \\n\\tcolor = color / 9.0;\\n\\t\\n\\tgl_FragColor = vec4(color, 1.0);\\n\\t\\n\\t\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDE0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLmZyYWc/MjI5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbnVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0cml4O1xcblxcbnVuaWZvcm0gZmxvYXQgc2NyZWVuV2lkdGg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5IZWlnaHQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcblxcbnZhcnlpbmcgdmVjMiB2VXY7XFxuXFxudm9pZCBtYWluKCkge1xcblxcblxcdGZsb2F0IGR4ID0gMS4wIC8gc2NyZWVuV2lkdGg7XFxuXFx0ZmxvYXQgZHkgPSAxLjAgLyBzY3JlZW5IZWlnaHQ7XFxuXFxuXFx0dmVjMyBjb2xvciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsIC1keSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgLWR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAtZHkpKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICAgMCkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgICAwKSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgIDApKS5yZ2I7XFxuXFx0Y29sb3IgKz0gdGV4dHVyZTJEKG1hcCwgdlV2ICsgdmVjMigtZHgsICBkeSkpLnJnYjtcXG5cXHRjb2xvciArPSB0ZXh0dXJlMkQobWFwLCB2VXYgKyB2ZWMyKCAgMCwgIGR5KSkucmdiO1xcblxcdGNvbG9yICs9IHRleHR1cmUyRChtYXAsIHZVdiArIHZlYzIoK2R4LCAgZHkpKS5yZ2I7XFxuICAgIFxcblxcdGNvbG9yID0gY29sb3IgLyA5LjA7XFxuXFx0XFxuXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgMS4wKTtcXG5cXHRcXG5cXHRcXG59XCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///414\n')},575:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n\\n    gl_Position =   projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTc1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvc2hhZGVycy9ibHVyLnZlcnQ/NWRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5wcmVjaXNpb24gaGlnaHAgaW50O1xcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMyIHV2O1xcblxcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxuXFxudmFyeWluZyB2ZWMyIHZVdjtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZVdiA9IHV2O1xcblxcbiAgICBnbF9Qb3NpdGlvbiA9ICAgcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XFxufVwiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///575\n')},168:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#if defined paraboloid_point_shape\\n\\t#extension GL_EXT_frag_depth : enable\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform vec3 cameraPosition;\\n\\nuniform mat4 projectionMatrix;\\nuniform float opacity;\\n\\nuniform float blendHardness;\\nuniform float blendDepthSupplement;\\nuniform float fov;\\nuniform float spacing;\\nuniform float pcIndex;\\nuniform float screenWidth;\\nuniform float screenHeight;\\n\\nuniform sampler2D depthMap;\\n\\n#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tuniform vec4 clipExtent;\\n#endif\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec4 highlightedPointColor;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\nfloat specularStrength = 1.0;\\n\\nvoid main() {\\n\\tvec3 color = vColor;\\n\\tfloat depth = gl_FragCoord.z;\\n\\n\\t#if defined (clip_horizontally) || defined (clip_vertically)\\n\\tvec2 ndc = vec2((gl_FragCoord.x / screenWidth), 1.0 - (gl_FragCoord.y / screenHeight));\\n\\n\\tif(step(clipExtent.x, ndc.x) * step(ndc.x, clipExtent.z) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\n\\tif(step(clipExtent.y, ndc.y) * step(ndc.y, clipExtent.w) < 1.0)\\n\\t{\\n\\t\\tdiscard;\\n\\t}\\n\\t#endif  \\n\\n\\t#if defined(circle_point_shape) || defined(paraboloid_point_shape) || defined (weighted_splats)\\n\\t\\tfloat u = 2.0 * gl_PointCoord.x - 1.0;\\n\\t\\tfloat v = 2.0 * gl_PointCoord.y - 1.0;\\n\\t#endif\\n\\n\\t#if defined(circle_point_shape) || defined (weighted_splats)\\n\\t\\tfloat cc = u*u + v*v;\\n\\t\\tif(cc > 1.0){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvec2 uv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\t\\tfloat sDepth = texture2D(depthMap, uv).r;\\n\\t\\tif(vLinearDepth > sDepth + vRadius + blendDepthSupplement){\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#if defined color_type_point_index\\n\\t\\tgl_FragColor = vec4(color, pcIndex / 255.0);\\n\\t#else\\n\\t\\tgl_FragColor = vec4(color, vOpacity);\\n\\t#endif\\n\\n\\t#ifdef use_point_cloud_mixing\\n\\t\\tbool discardFragment = false;\\n\\n\\t\\tif (pointCloudMixingMode == 1) {  // Checkboard\\n\\t\\t\\tfloat vPointCloudID = pointCloudID > 10. ? pointCloudID/10.: pointCloudID;\\n\\t\\t\\tdiscardFragment = mod(gl_FragCoord.x, vPointCloudID) > 0.5 && mod(gl_FragCoord.y, vPointCloudID) > 0.5;\\n\\t\\t}\\n\\t\\telse if (pointCloudMixingMode == 2) {  // Stripes\\n\\t\\t\\tfloat angle = pointCloudMixAngle * pointCloudID / 180.;\\n\\t\\t\\tfloat u = cos(angle) * gl_FragCoord.x + sin(angle) * gl_FragCoord.y;\\n\\t\\t\\tfloat v = -sin(angle) * gl_FragCoord.x + cos(angle) * gl_FragCoord.y;\\n\\n\\t\\t\\tdiscardFragment = mod(u, stripeDistanceX) >= stripeDistanceX/stripeDivisorX && mod(v, stripeDistanceY) >= stripeDistanceY/stripeDivisorY;\\n\\t\\t}\\n\\t\\tif (discardFragment) {\\n\\t\\t\\tdiscard;\\n\\t\\t}\\n\\t#endif\\n\\n\\t#ifdef use_texture_blending\\n\\t\\tvec2 vUv = gl_FragCoord.xy / vec2(screenWidth, screenHeight);\\n\\n\\t\\tvec4 tColor = texture2D(backgroundMap, vUv);\\n\\t\\tgl_FragColor = vec4(vOpacity * color, 1.) + vec4((1. - vOpacity) * tColor.rgb, 0.);\\n\\t#endif\\n\\n\\t#if defined(color_type_phong)\\n\\t\\t#if MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0\\n\\t\\t\\tvec3 normal = normalize( vNormal );\\n\\t\\t\\tnormal.z = abs(normal.z);\\n\\n\\t\\t\\tvec3 viewPosition = normalize( vViewPosition );\\n\\t\\t#endif\\n\\n\\t\\t// code taken from three.js phong light fragment shader\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\tvec3 pointDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 pointSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\\n\\t\\t\\t\\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\\n\\n\\t\\t\\t\\tfloat lDistance = 1.0;\\n\\t\\t\\t\\tif ( pointLightDistance[ i ] > 0.0 )\\n\\t\\t\\t\\t\\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\\n\\n\\t\\t\\t\\tlVector = normalize( lVector );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, lVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 pointHalfVector = normalize( lVector + viewPosition );\\n\\t\\t\\t\\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\\n\\t\\t\\t\\tpointSpecular = vec3(0.0, 0.0, 0.0);\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\tvec3 dirDiffuse = vec3( 0.0 );\\n\\t\\t\\tvec3 dirSpecular = vec3( 0.0 );\\n\\n\\t\\t\\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\\n\\n\\t\\t\\t\\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\\n\\t\\t\\t\\tvec3 dirVector = normalize( lDirection.xyz );\\n\\n\\t\\t\\t\\t\\t\\t// diffuse\\n\\n\\t\\t\\t\\tfloat dotProduct = dot( normal, dirVector );\\n\\n\\t\\t\\t\\t#ifdef WRAP_AROUND\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\\n\\n\\t\\t\\t\\t#else\\n\\n\\t\\t\\t\\t\\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\\n\\n\\t\\t\\t\\t#endif\\n\\n\\t\\t\\t\\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\\n\\n\\t\\t\\t\\t// specular\\n\\n\\t\\t\\t\\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\\n\\t\\t\\t\\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\\n\\t\\t\\t\\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\\n\\n\\t\\t\\t\\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\\n\\n\\t\\t\\t\\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\\n\\t\\t\\t\\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\\n\\t\\t\\t}\\n\\n\\t\\t#endif\\n\\n\\t\\tvec3 totalDiffuse = vec3( 0.0 );\\n\\t\\tvec3 totalSpecular = vec3( 0.0 );\\n\\n\\t\\t#if MAX_POINT_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += pointDiffuse;\\n\\t\\t\\ttotalSpecular += pointSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\t#if MAX_DIR_LIGHTS > 0\\n\\n\\t\\t\\ttotalDiffuse += dirDiffuse;\\n\\t\\t\\ttotalSpecular += dirSpecular;\\n\\n\\t\\t#endif\\n\\n\\t\\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\\n\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t    //float w = pow(1.0 - (u*u + v*v), blendHardness);\\n\\n\\t\\tfloat wx = 2.0 * length(2.0 * gl_PointCoord - 1.0);\\n\\t\\tfloat w = exp(-wx * wx * 0.5);\\n\\n\\t\\t//float distance = length(2.0 * gl_PointCoord - 1.0);\\n\\t\\t//float w = exp( -(distance * distance) / blendHardness);\\n\\n\\t\\tgl_FragColor.rgb = gl_FragColor.rgb * w;\\n\\t\\tgl_FragColor.a = w;\\n\\t#endif\\n\\n\\t#if defined paraboloid_point_shape\\n\\t\\tfloat wi = 0.0 - ( u*u + v*v);\\n\\t\\tvec4 pos = vec4(vViewPosition, 1.0);\\n\\t\\tpos.z += wi * vRadius;\\n\\t\\tfloat linearDepth = -pos.z;\\n\\t\\tpos = projectionMatrix * pos;\\n\\t\\tpos = pos / pos.w;\\n\\t\\tfloat expDepth = pos.z;\\n\\t\\tdepth = (pos.z + 1.0) / 2.0;\\n\\t\\tgl_FragDepthEXT = depth;\\n\\n\\t\\t#if defined(color_type_depth)\\n\\t\\t\\tgl_FragColor.r = linearDepth;\\n\\t\\t\\tgl_FragColor.g = expDepth;\\n\\t\\t#endif\\n\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = log2(linearDepth);\\n\\t\\t#endif\\n\\n\\t#else\\n\\t\\t#if defined(use_edl)\\n\\t\\t\\tgl_FragColor.a = vLogDepth;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t#ifdef highlight_point\\n\\t\\tif (vHighlight > 0.0) {\\n\\t\\t\\tgl_FragColor = highlightedPointColor;\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQuZnJhZz8wNTA1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2lmIGRlZmluZWQgcGFyYWJvbG9pZF9wb2ludF9zaGFwZVxcblxcdCNleHRlbnNpb24gR0xfRVhUX2ZyYWdfZGVwdGggOiBlbmFibGVcXG4jZW5kaWZcXG5cXG51bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcXG51bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247XFxuXFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnVuaWZvcm0gZmxvYXQgYmxlbmRIYXJkbmVzcztcXG51bmlmb3JtIGZsb2F0IGJsZW5kRGVwdGhTdXBwbGVtZW50O1xcbnVuaWZvcm0gZmxvYXQgZm92O1xcbnVuaWZvcm0gZmxvYXQgc3BhY2luZztcXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCBkZXB0aE1hcDtcXG5cXG4jaWYgZGVmaW5lZCAoY2xpcF9ob3Jpem9udGFsbHkpIHx8IGRlZmluZWQgKGNsaXBfdmVydGljYWxseSlcXG5cXHR1bmlmb3JtIHZlYzQgY2xpcEV4dGVudDtcXG4jZW5kaWZcXG5cXG4jaWZkZWYgdXNlX3RleHR1cmVfYmxlbmRpbmdcXG5cXHR1bmlmb3JtIHNhbXBsZXIyRCBiYWNrZ3JvdW5kTWFwO1xcbiNlbmRpZlxcblxcblxcbiNpZmRlZiB1c2VfcG9pbnRfY2xvdWRfbWl4aW5nXFxuXFx0dW5pZm9ybSBpbnQgcG9pbnRDbG91ZE1peGluZ01vZGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkSUQ7XFxuXFx0dW5pZm9ybSBmbG9hdCBwb2ludENsb3VkTWl4QW5nbGU7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVg7XFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXN0YW5jZVk7XFxuXFxuXFx0dW5pZm9ybSBmbG9hdCBzdHJpcGVEaXZpc29yWDtcXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpdmlzb3JZO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBoaWdobGlnaHRfcG9pbnRcXG5cXHR1bmlmb3JtIHZlYzQgaGlnaGxpZ2h0ZWRQb2ludENvbG9yO1xcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2lmICFkZWZpbmVkKGNvbG9yX3R5cGVfcG9pbnRfaW5kZXgpXFxuXFx0dmFyeWluZyBmbG9hdCB2T3BhY2l0eTtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZCh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0dmFyeWluZyBmbG9hdCB2TGluZWFyRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmICFkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpICYmIGRlZmluZWQodXNlX2VkbClcXG5cXHR2YXJ5aW5nIGZsb2F0IHZMb2dEZXB0aDtcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0dmFyeWluZyBmbG9hdCB2UmFkaXVzO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHZhcnlpbmcgZmxvYXQgdkhpZ2hsaWdodDtcXG4jZW5kaWZcXG5cXG5mbG9hdCBzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWMzIGNvbG9yID0gdkNvbG9yO1xcblxcdGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLno7XFxuXFxuXFx0I2lmIGRlZmluZWQgKGNsaXBfaG9yaXpvbnRhbGx5KSB8fCBkZWZpbmVkIChjbGlwX3ZlcnRpY2FsbHkpXFxuXFx0dmVjMiBuZGMgPSB2ZWMyKChnbF9GcmFnQ29vcmQueCAvIHNjcmVlbldpZHRoKSwgMS4wIC0gKGdsX0ZyYWdDb29yZC55IC8gc2NyZWVuSGVpZ2h0KSk7XFxuXFxuXFx0aWYoc3RlcChjbGlwRXh0ZW50LngsIG5kYy54KSAqIHN0ZXAobmRjLngsIGNsaXBFeHRlbnQueikgPCAxLjApXFxuXFx0e1xcblxcdFxcdGRpc2NhcmQ7XFxuXFx0fVxcblxcblxcdGlmKHN0ZXAoY2xpcEV4dGVudC55LCBuZGMueSkgKiBzdGVwKG5kYy55LCBjbGlwRXh0ZW50LncpIDwgMS4wKVxcblxcdHtcXG5cXHRcXHRkaXNjYXJkO1xcblxcdH1cXG5cXHQjZW5kaWYgIFxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKSB8fCBkZWZpbmVkICh3ZWlnaHRlZF9zcGxhdHMpXFxuXFx0XFx0ZmxvYXQgdSA9IDIuMCAqIGdsX1BvaW50Q29vcmQueCAtIDEuMDtcXG5cXHRcXHRmbG9hdCB2ID0gMi4wICogZ2xfUG9pbnRDb29yZC55IC0gMS4wO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkKGNpcmNsZV9wb2ludF9zaGFwZSkgfHwgZGVmaW5lZCAod2VpZ2h0ZWRfc3BsYXRzKVxcblxcdFxcdGZsb2F0IGNjID0gdSp1ICsgdip2O1xcblxcdFxcdGlmKGNjID4gMS4wKXtcXG5cXHRcXHRcXHRkaXNjYXJkO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCB3ZWlnaHRlZF9zcGxhdHNcXG5cXHRcXHR2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdmVjMihzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcXG5cXHRcXHRmbG9hdCBzRGVwdGggPSB0ZXh0dXJlMkQoZGVwdGhNYXAsIHV2KS5yO1xcblxcdFxcdGlmKHZMaW5lYXJEZXB0aCA+IHNEZXB0aCArIHZSYWRpdXMgKyBibGVuZERlcHRoU3VwcGxlbWVudCl7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIGRlZmluZWQgY29sb3JfdHlwZV9wb2ludF9pbmRleFxcblxcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIHBjSW5kZXggLyAyNTUuMCk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCB2T3BhY2l0eSk7XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV9wb2ludF9jbG91ZF9taXhpbmdcXG5cXHRcXHRib29sIGRpc2NhcmRGcmFnbWVudCA9IGZhbHNlO1xcblxcblxcdFxcdGlmIChwb2ludENsb3VkTWl4aW5nTW9kZSA9PSAxKSB7ICAvLyBDaGVja2JvYXJkXFxuXFx0XFx0XFx0ZmxvYXQgdlBvaW50Q2xvdWRJRCA9IHBvaW50Q2xvdWRJRCA+IDEwLiA/IHBvaW50Q2xvdWRJRC8xMC46IHBvaW50Q2xvdWRJRDtcXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QoZ2xfRnJhZ0Nvb3JkLngsIHZQb2ludENsb3VkSUQpID4gMC41ICYmIG1vZChnbF9GcmFnQ29vcmQueSwgdlBvaW50Q2xvdWRJRCkgPiAwLjU7XFxuXFx0XFx0fVxcblxcdFxcdGVsc2UgaWYgKHBvaW50Q2xvdWRNaXhpbmdNb2RlID09IDIpIHsgIC8vIFN0cmlwZXNcXG5cXHRcXHRcXHRmbG9hdCBhbmdsZSA9IHBvaW50Q2xvdWRNaXhBbmdsZSAqIHBvaW50Q2xvdWRJRCAvIDE4MC47XFxuXFx0XFx0XFx0ZmxvYXQgdSA9IGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIHNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXHRcXHRcXHRmbG9hdCB2ID0gLXNpbihhbmdsZSkgKiBnbF9GcmFnQ29vcmQueCArIGNvcyhhbmdsZSkgKiBnbF9GcmFnQ29vcmQueTtcXG5cXG5cXHRcXHRcXHRkaXNjYXJkRnJhZ21lbnQgPSBtb2QodSwgc3RyaXBlRGlzdGFuY2VYKSA+PSBzdHJpcGVEaXN0YW5jZVgvc3RyaXBlRGl2aXNvclggJiYgbW9kKHYsIHN0cmlwZURpc3RhbmNlWSkgPj0gc3RyaXBlRGlzdGFuY2VZL3N0cmlwZURpdmlzb3JZO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoZGlzY2FyZEZyYWdtZW50KSB7XFxuXFx0XFx0XFx0ZGlzY2FyZDtcXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmZGVmIHVzZV90ZXh0dXJlX2JsZW5kaW5nXFxuXFx0XFx0dmVjMiB2VXYgPSBnbF9GcmFnQ29vcmQueHkgLyB2ZWMyKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpO1xcblxcblxcdFxcdHZlYzQgdENvbG9yID0gdGV4dHVyZTJEKGJhY2tncm91bmRNYXAsIHZVdik7XFxuXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh2T3BhY2l0eSAqIGNvbG9yLCAxLikgKyB2ZWM0KCgxLiAtIHZPcGFjaXR5KSAqIHRDb2xvci5yZ2IsIDAuKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKVxcblxcdFxcdCNpZiBNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXHRcXHRcXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcdFxcdFxcdG5vcm1hbC56ID0gYWJzKG5vcm1hbC56KTtcXG5cXG5cXHRcXHRcXHR2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdC8vIGNvZGUgdGFrZW4gZnJvbSB0aHJlZS5qcyBwaG9uZyBsaWdodCBmcmFnbWVudCBzaGFkZXJcXG5cXG5cXHRcXHQjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZSA9IHZlYzMoIDAuMCApO1xcblxcdFxcdFxcdHZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1xcblxcblxcdFxcdFxcdGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1xcblxcdFxcdFxcdFxcdHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XFxuXFx0XFx0XFx0XFx0aWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXFxuXFx0XFx0XFx0XFx0XFx0bERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0bFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGRpZmZ1c2VcXG5cXG5cXHRcXHRcXHRcXHRmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMzIHBvaW50RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjZWxzZVxcblxcblxcdFxcdFxcdFxcdFxcdGZsb2F0IHBvaW50RGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0cG9pbnREaWZmdXNlICs9IGRpZmZ1c2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzcGVjdWxhclxcblxcblxcdFxcdFxcdFxcdHZlYzMgcG9pbnRIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0ZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1xcblxcdFxcdFxcdFxcdGZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggbFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0XFx0cG9pbnRTcGVjdWxhciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdCNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG5cXHRcXHRcXHR2ZWMzIGRpckRpZmZ1c2UgPSB2ZWMzKCAwLjAgKTtcXG5cXHRcXHRcXHR2ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0XFx0Zm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfRElSX0xJR0hUUzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBkaWZmdXNlXFxuXFxuXFx0XFx0XFx0XFx0ZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKTtcXG5cXG5cXHRcXHRcXHRcXHQjaWZkZWYgV1JBUF9BUk9VTkRcXG5cXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodEhhbGYgPSBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1xcblxcblxcdFxcdFxcdFxcdCNlbHNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgZGlyRGlmZnVzZVdlaWdodCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XFxuXFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0XFx0XFx0ZGlyRGlmZnVzZSArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1xcblxcblxcdFxcdFxcdFxcdC8vIHNwZWN1bGFyXFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBkaXJIYWxmVmVjdG9yID0gbm9ybWFsaXplKCBkaXJWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcXG5cXHRcXHRcXHRcXHRmbG9hdCBkaXJTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggZGlyRG90Tm9ybWFsSGFsZiwgc2hpbmluZXNzICksIDAuMCApO1xcblxcblxcdFxcdFxcdFxcdGZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wICkgLyA4LjA7XFxuXFxuXFx0XFx0XFx0XFx0dmVjMyBzY2hsaWNrID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCBtYXgoIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDAuMCApLCA1LjAgKTtcXG5cXHRcXHRcXHRcXHRkaXJTcGVjdWxhciArPSBzY2hsaWNrICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdCNlbmRpZlxcblxcblxcdFxcdHZlYzMgdG90YWxEaWZmdXNlID0gdmVjMyggMC4wICk7XFxuXFx0XFx0dmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XFxuXFxuXFx0XFx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFxuXFx0XFx0XFx0dG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcXG5cXHRcXHRcXHR0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcblxcdFxcdFxcdHRvdGFsRGlmZnVzZSArPSBkaXJEaWZmdXNlO1xcblxcdFxcdFxcdHRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XFxuXFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiAoIGVtaXNzaXZlICsgdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiBhbWJpZW50ICkgKyB0b3RhbFNwZWN1bGFyO1xcblxcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkIHdlaWdodGVkX3NwbGF0c1xcblxcdCAgICAvL2Zsb2F0IHcgPSBwb3coMS4wIC0gKHUqdSArIHYqdiksIGJsZW5kSGFyZG5lc3MpO1xcblxcblxcdFxcdGZsb2F0IHd4ID0gMi4wICogbGVuZ3RoKDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjApO1xcblxcdFxcdGZsb2F0IHcgPSBleHAoLXd4ICogd3ggKiAwLjUpO1xcblxcblxcdFxcdC8vZmxvYXQgZGlzdGFuY2UgPSBsZW5ndGgoMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMCk7XFxuXFx0XFx0Ly9mbG9hdCB3ID0gZXhwKCAtKGRpc3RhbmNlICogZGlzdGFuY2UpIC8gYmxlbmRIYXJkbmVzcyk7XFxuXFxuXFx0XFx0Z2xfRnJhZ0NvbG9yLnJnYiA9IGdsX0ZyYWdDb2xvci5yZ2IgKiB3O1xcblxcdFxcdGdsX0ZyYWdDb2xvci5hID0gdztcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCBwYXJhYm9sb2lkX3BvaW50X3NoYXBlXFxuXFx0XFx0ZmxvYXQgd2kgPSAwLjAgLSAoIHUqdSArIHYqdik7XFxuXFx0XFx0dmVjNCBwb3MgPSB2ZWM0KHZWaWV3UG9zaXRpb24sIDEuMCk7XFxuXFx0XFx0cG9zLnogKz0gd2kgKiB2UmFkaXVzO1xcblxcdFxcdGZsb2F0IGxpbmVhckRlcHRoID0gLXBvcy56O1xcblxcdFxcdHBvcyA9IHByb2plY3Rpb25NYXRyaXggKiBwb3M7XFxuXFx0XFx0cG9zID0gcG9zIC8gcG9zLnc7XFxuXFx0XFx0ZmxvYXQgZXhwRGVwdGggPSBwb3MuejtcXG5cXHRcXHRkZXB0aCA9IChwb3MueiArIDEuMCkgLyAyLjA7XFxuXFx0XFx0Z2xfRnJhZ0RlcHRoRVhUID0gZGVwdGg7XFxuXFxuXFx0XFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9kZXB0aClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuciA9IGxpbmVhckRlcHRoO1xcblxcdFxcdFxcdGdsX0ZyYWdDb2xvci5nID0gZXhwRGVwdGg7XFxuXFx0XFx0I2VuZGlmXFxuXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IGxvZzIobGluZWFyRGVwdGgpO1xcblxcdFxcdCNlbmRpZlxcblxcblxcdCNlbHNlXFxuXFx0XFx0I2lmIGRlZmluZWQodXNlX2VkbClcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IuYSA9IHZMb2dEZXB0aDtcXG5cXHRcXHQjZW5kaWZcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWZkZWYgaGlnaGxpZ2h0X3BvaW50XFxuXFx0XFx0aWYgKHZIaWdobGlnaHQgPiAwLjApIHtcXG5cXHRcXHRcXHRnbF9GcmFnQ29sb3IgPSBoaWdobGlnaHRlZFBvaW50Q29sb3I7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbn1cXG5cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///168\n')},245:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("precision highp float;\\nprecision highp int;\\n\\n#define max_clip_boxes 30\\n\\nattribute vec3 position;\\nattribute vec3 color;\\n\\n#ifdef color_rgba\\n\\tattribute vec4 rgba;\\n#endif\\n\\nattribute vec3 normal;\\nattribute float intensity;\\nattribute float classification;\\nattribute float returnNumber;\\nattribute float numberOfReturns;\\nattribute float pointSourceID;\\nattribute vec4 indices;\\nattribute vec2 uv;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 modelViewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 viewMatrix;\\nuniform mat3 normalMatrix;\\n\\nuniform float pcIndex;\\n\\nuniform float screenWidth;\\nuniform float screenHeight;\\nuniform float fov;\\nuniform float spacing;\\n\\n#if defined use_clip_box\\n\\tuniform mat4 clipBoxes[max_clip_boxes];\\n\\tuniform vec3 clipHighlightColors[max_clip_boxes];\\n#endif\\n\\nuniform float heightMin;\\nuniform float heightMax;\\nuniform float size; // pixel size factor\\nuniform float minSize; // minimum pixel size\\nuniform float maxSize; // maximum pixel size\\nuniform float octreeSize;\\nuniform vec3 bbSize;\\nuniform vec3 uColor;\\nuniform float opacity;\\nuniform float clipBoxCount;\\nuniform float level;\\nuniform float vnStart;\\nuniform bool isLeafNode;\\n\\nuniform float filterByNormalThreshold;\\nuniform vec2 intensityRange;\\nuniform float opacityAttenuation;\\nuniform float intensityGamma;\\nuniform float intensityContrast;\\nuniform float intensityBrightness;\\nuniform float rgbGamma;\\nuniform float rgbContrast;\\nuniform float rgbBrightness;\\nuniform float transition;\\nuniform float wRGB;\\nuniform float wIntensity;\\nuniform float wElevation;\\nuniform float wClassification;\\nuniform float wReturnNumber;\\nuniform float wSourceID;\\n\\nuniform sampler2D visibleNodes;\\nuniform sampler2D gradient;\\nuniform sampler2D classificationLUT;\\nuniform sampler2D depthMap;\\n\\n#ifdef use_texture_blending\\n\\tuniform sampler2D backgroundMap;\\n#endif\\n\\n#ifdef use_point_cloud_mixing\\n\\tuniform int pointCloudMixingMode;\\n\\tuniform float pointCloudID;\\n\\n\\tuniform float pointCloudMixAngle;\\n\\tuniform float stripeDistanceX;\\n\\tuniform float stripeDistanceY;\\n\\n\\tuniform float stripeDivisorX;\\n\\tuniform float stripeDivisorY;\\n#endif\\n\\n#ifdef highlight_point\\n\\tuniform vec3 highlightedPointCoordinate;\\n\\tuniform bool enablePointHighlighting;\\n\\tuniform float highlightedPointScale;\\n#endif\\n\\n#ifdef use_filter_by_normal\\n\\tuniform int normalFilteringMode;\\n#endif\\n\\nvarying vec3 vColor;\\n\\n#if !defined(color_type_point_index)\\n\\tvarying float vOpacity;\\n#endif\\n\\n#if defined(weighted_splats)\\n\\tvarying float vLinearDepth;\\n#endif\\n\\n#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\tvarying float vLogDepth;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\tvarying vec3 vViewPosition;\\n#endif\\n\\n#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\tvarying float vRadius;\\n#endif\\n\\n#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\tvarying vec3 vNormal;\\n#endif\\n\\n#ifdef highlight_point\\n\\tvarying float vHighlight;\\n#endif\\n\\n// ---------------------\\n// OCTREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_octree)\\n\\n/**\\n * Rounds the specified number to the closest integer.\\n */\\nfloat round(float number){\\n\\treturn floor(number + 0.5);\\n}\\n\\n/**\\n * Gets the number of 1-bits up to inclusive index position.\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nint numberOfOnes(int number, int index) {\\n\\tint numOnes = 0;\\n\\tint tmp = 128;\\n\\tfor (int i = 7; i >= 0; i--) {\\n\\n\\t\\tif (number >= tmp) {\\n\\t\\t\\tnumber = number - tmp;\\n\\n\\t\\t\\tif (i <= index) {\\n\\t\\t\\t\\tnumOnes++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\ttmp = tmp / 2;\\n\\t}\\n\\n\\treturn numOnes;\\n}\\n\\n/**\\n * Checks whether the bit at index is 1.0\\n *\\n * number is treated as if it were an integer in the range 0-255\\n */\\nbool isBitSet(int number, int index){\\n\\n\\t// weird multi else if due to lack of proper array, int and bitwise support in WebGL 1.0\\n\\tint powi = 1;\\n\\tif (index == 0) {\\n\\t\\tpowi = 1;\\n\\t} else if (index == 1) {\\n\\t\\tpowi = 2;\\n\\t} else if (index == 2) {\\n\\t\\tpowi = 4;\\n\\t} else if (index == 3) {\\n\\t\\tpowi = 8;\\n\\t} else if (index == 4) {\\n\\t\\tpowi = 16;\\n\\t} else if (index == 5) {\\n\\t\\tpowi = 32;\\n\\t} else if (index == 6) {\\n\\t\\tpowi = 64;\\n\\t} else if (index == 7) {\\n\\t\\tpowi = 128;\\n\\t}\\n\\n\\tint ndp = number / powi;\\n\\n\\treturn mod(float(ndp), 2.0) != 0.0;\\n}\\n\\n/**\\n * Gets the the LOD at the point position.\\n */\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tint iOffset = int(vnStart);\\n\\tfloat depth = level;\\n\\n\\tfor (float i = 0.0; i <= 30.0; i++) {\\n\\t\\tfloat nodeSizeAtLevel = octreeSize  / pow(2.0, i + level + 0.0);\\n\\n\\t\\tvec3 index3d = (position-offset) / nodeSizeAtLevel;\\n\\t\\tindex3d = floor(index3d + 0.5);\\n\\t\\tint index = int(round(4.0 * index3d.x + 2.0 * index3d.y + index3d.z));\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(float(iOffset) / 2048.0, 0.0));\\n\\t\\tint mask = int(round(value.r * 255.0));\\n\\n\\t\\tif (isBitSet(mask, index)) {\\n\\t\\t\\t// there are more visible child nodes at this position\\n\\t\\t\\tint advanceG = int(round(value.g * 255.0)) * 256;\\n\\t\\t\\tint advanceB = int(round(value.b * 255.0));\\n\\t\\t\\tint advanceChild = numberOfOnes(mask, index - 1);\\n\\t\\t\\tint advance = advanceG + advanceB + advanceChild;\\n\\n\\t\\t\\tiOffset = iOffset + advance;\\n\\n\\t\\t\\tdepth++;\\n\\t\\t} else {\\n\\t\\t\\treturn value.a * 255.0; // no more visible child nodes at this position\\n\\t\\t}\\n\\n\\t\\toffset = offset + (vec3(1.0, 1.0, 1.0) * nodeSizeAtLevel * 0.5) * index3d;\\n\\t}\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(2.0, getLOD());\\n}\\n\\n#endif\\n\\n// ---------------------\\n// KD-TREE\\n// ---------------------\\n\\n#if (defined(adaptive_point_size) || defined(color_type_lod)) && defined(tree_type_kdtree)\\n\\nfloat getLOD() {\\n\\tvec3 offset = vec3(0.0, 0.0, 0.0);\\n\\tfloat intOffset = 0.0;\\n\\tfloat depth = 0.0;\\n\\n\\tvec3 size = bbSize;\\n\\tvec3 pos = position;\\n\\n\\tfor (float i = 0.0; i <= 1000.0; i++) {\\n\\n\\t\\tvec4 value = texture2D(visibleNodes, vec2(intOffset / 2048.0, 0.0));\\n\\n\\t\\tint children = int(value.r * 255.0);\\n\\t\\tfloat next = value.g * 255.0;\\n\\t\\tint split = int(value.b * 255.0);\\n\\n\\t\\tif (next == 0.0) {\\n\\t\\t \\treturn depth;\\n\\t\\t}\\n\\n\\t\\tvec3 splitv = vec3(0.0, 0.0, 0.0);\\n\\t\\tif (split == 1) {\\n\\t\\t\\tsplitv.x = 1.0;\\n\\t\\t} else if (split == 2) {\\n\\t\\t \\tsplitv.y = 1.0;\\n\\t\\t} else if (split == 4) {\\n\\t\\t \\tsplitv.z = 1.0;\\n\\t\\t}\\n\\n\\t\\tintOffset = intOffset + next;\\n\\n\\t\\tfloat factor = length(pos * splitv / size);\\n\\t\\tif (factor < 0.5) {\\n\\t\\t \\t// left\\n\\t\\t\\tif (children == 0 || children == 2) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// right\\n\\t\\t\\tpos = pos - size * splitv * 0.5;\\n\\t\\t\\tif (children == 0 || children == 1) {\\n\\t\\t\\t\\treturn depth;\\n\\t\\t\\t}\\n\\t\\t\\tif (children == 3) {\\n\\t\\t\\t\\tintOffset = intOffset + 1.0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tsize = size * ((1.0 - (splitv + 1.0) / 2.0) + 0.5);\\n\\n\\t\\tdepth++;\\n\\t}\\n\\n\\n\\treturn depth;\\n}\\n\\nfloat getPointSizeAttenuation() {\\n\\treturn 0.5 * pow(1.3, getLOD());\\n}\\n\\n#endif\\n\\n// formula adapted from: http://www.dfstudios.co.uk/articles/programming/image-programming-algorithms/image-processing-algorithms-part-5-contrast-adjustment/\\nfloat getContrastFactor(float contrast) {\\n\\treturn (1.0158730158730156 * (contrast + 1.0)) / (1.0158730158730156 - contrast);\\n}\\n\\nvec3 getRGB() {\\n\\t\\n\\t#ifdef color_rgba\\n\\t\\tvec3 rgb = rgba.rgb;\\n\\t#else\\t\\n\\t\\tvec3 rgb = color;\\n\\t#endif\\t\\t\\n\\n\\t#if defined(use_rgb_gamma_contrast_brightness)\\n\\t\\trgb = pow(rgb, vec3(rgbGamma));\\n\\t\\trgb = rgb + rgbBrightness;\\n\\t\\trgb = (rgb - 0.5) * getContrastFactor(rgbContrast) + 0.5;\\n\\t\\trgb = clamp(rgb, 0.0, 1.0);\\n\\t\\treturn rgb;\\n\\t#else\\n\\t\\treturn rgb;\\n\\t#endif\\n}\\n\\nfloat getIntensity() {\\n\\tfloat w = (intensity - intensityRange.x) / (intensityRange.y - intensityRange.x);\\n\\tw = pow(w, intensityGamma);\\n\\tw = w + intensityBrightness;\\n\\tw = (w - 0.5) * getContrastFactor(intensityContrast) + 0.5;\\n\\tw = clamp(w, 0.0, 1.0);\\n\\n\\treturn w;\\n}\\n\\nvec3 getElevation() {\\n\\tvec4 world = modelMatrix * vec4( position, 1.0 );\\n\\tfloat w = (world.z - heightMin) / (heightMax-heightMin);\\n\\tvec3 cElevation = texture2D(gradient, vec2(w,1.0-w)).rgb;\\n\\n\\treturn cElevation;\\n}\\n\\nvec4 getClassification() {\\n\\tvec2 uv = vec2(classification / 255.0, 0.5);\\n\\tvec4 classColor = texture2D(classificationLUT, uv);\\n\\n\\treturn classColor;\\n}\\n\\nvec3 getReturnNumber() {\\n\\tif (numberOfReturns == 1.0) {\\n\\t\\treturn vec3(1.0, 1.0, 0.0);\\n\\t} else {\\n\\t\\tif (returnNumber == 1.0) {\\n\\t\\t\\treturn vec3(1.0, 0.0, 0.0);\\n\\t\\t} else if (returnNumber == numberOfReturns) {\\n\\t\\t\\treturn vec3(0.0, 0.0, 1.0);\\n\\t\\t} else {\\n\\t\\t\\treturn vec3(0.0, 1.0, 0.0);\\n\\t\\t}\\n\\t}\\n}\\n\\nvec3 getSourceID() {\\n\\tfloat w = mod(pointSourceID, 10.0) / 10.0;\\n\\treturn texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n}\\n\\nvec3 getCompositeColor() {\\n\\tvec3 c;\\n\\tfloat w;\\n\\n\\tc += wRGB * getRGB();\\n\\tw += wRGB;\\n\\n\\tc += wIntensity * getIntensity() * vec3(1.0, 1.0, 1.0);\\n\\tw += wIntensity;\\n\\n\\tc += wElevation * getElevation();\\n\\tw += wElevation;\\n\\n\\tc += wReturnNumber * getReturnNumber();\\n\\tw += wReturnNumber;\\n\\n\\tc += wSourceID * getSourceID();\\n\\tw += wSourceID;\\n\\n\\tvec4 cl = wClassification * getClassification();\\n\\tc += cl.a * cl.rgb;\\n\\tw += wClassification * cl.a;\\n\\n\\tc = c / w;\\n\\n\\tif (w == 0.0) {\\n\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t}\\n\\n\\treturn c;\\n}\\n\\nvoid main() {\\n\\tvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\\n\\n\\tgl_Position = projectionMatrix * mvPosition;\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0) || defined(paraboloid_point_shape)\\n\\t\\tvViewPosition = mvPosition.xyz;\\n\\t#endif\\n\\n\\t#if defined weighted_splats\\n\\t\\tvLinearDepth = gl_Position.w;\\n\\t#endif\\n\\n\\t#if defined(color_type_phong) && (MAX_POINT_LIGHTS > 0 || MAX_DIR_LIGHTS > 0)\\n\\t\\tvNormal = normalize(normalMatrix * normal);\\n\\t#endif\\n\\n\\t#if !defined(paraboloid_point_shape) && defined(use_edl)\\n\\t\\tvLogDepth = log2(-mvPosition.z);\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT SIZE\\n\\t// ---------------------\\n\\n\\tfloat pointSize = 1.0;\\n\\tfloat slope = tan(fov / 2.0);\\n\\tfloat projFactor =  -0.5 * screenHeight / (slope * mvPosition.z);\\n\\n\\t#if defined fixed_point_size\\n\\t\\tpointSize = size;\\n\\t#elif defined attenuated_point_size\\n\\t\\tpointSize = size * spacing * projFactor;\\n\\t#elif defined adaptive_point_size\\n\\t\\tfloat worldSpaceSize = 2.0 * size * spacing / getPointSizeAttenuation();\\n\\t\\tpointSize = worldSpaceSize * projFactor;\\n\\t#endif\\n\\n\\tpointSize = max(minSize, pointSize);\\n\\tpointSize = min(maxSize, pointSize);\\n\\n\\t#if defined(weighted_splats) || defined(paraboloid_point_shape)\\n\\t\\tvRadius = pointSize / projFactor;\\n\\t#endif\\n\\n\\tgl_PointSize = pointSize;\\n\\n\\t// ---------------------\\n\\t// HIGHLIGHTING\\n\\t// ---------------------\\n\\n\\t#ifdef highlight_point\\n\\t\\tvec4 mPosition = modelMatrix * vec4(position, 1.0);\\n\\t\\tif (enablePointHighlighting && abs(mPosition.x - highlightedPointCoordinate.x) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.y - highlightedPointCoordinate.y) < 0.0001 &&\\n\\t\\t\\tabs(mPosition.z - highlightedPointCoordinate.z) < 0.0001) {\\n\\t\\t\\tvHighlight = 1.0;\\n\\t\\t\\tgl_PointSize = pointSize * highlightedPointScale;\\n\\t\\t} else {\\n\\t\\t\\tvHighlight = 0.0;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// OPACITY\\n\\t// ---------------------\\n\\n\\t#ifndef color_type_point_index\\n\\t\\t#ifdef attenuated_opacity\\n\\t\\t\\tvOpacity = opacity * exp(-length(-mvPosition.xyz) / opacityAttenuation);\\n\\t\\t#else\\n\\t\\t\\tvOpacity = opacity;\\n\\t\\t#endif\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// FILTERING\\n\\t// ---------------------\\n\\n\\t#ifdef use_filter_by_normal\\n\\t\\tbool discardPoint = false;\\n\\t\\t// Absolute normal filtering\\n\\t\\tif (normalFilteringMode == 1) {\\n\\t\\t\\tdiscardPoint = (abs((modelViewMatrix * vec4(normal, 0.0)).z) > filterByNormalThreshold);\\n\\t\\t}\\n\\t\\t// less than equal to\\n\\t\\telse if (normalFilteringMode == 2) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z <= filterByNormalThreshold;\\n\\t\\t\\t}\\n\\t\\t// greater than\\n\\t\\telse if(normalFilteringMode == 3) {\\n\\t\\t\\tdiscardPoint = (modelViewMatrix * vec4(normal, 0.0)).z > filterByNormalThreshold;\\n\\t\\t\\t}\\n\\n\\t\\tif (discardPoint)\\n\\t\\t{\\n\\t\\t\\tgl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// POINT COLOR\\n\\t// ---------------------\\n\\n\\t#ifdef color_type_rgb\\n\\t\\tvColor = getRGB();\\n\\t#elif defined color_type_height\\n\\t\\tvColor = getElevation();\\n\\t#elif defined color_type_rgb_height\\n\\t\\tvec3 cHeight = getElevation();\\n\\t\\tvColor = (1.0 - transition) * getRGB() + transition * cHeight;\\n\\t#elif defined color_type_depth\\n\\t\\tfloat linearDepth = -mvPosition.z ;\\n\\t\\tfloat expDepth = (gl_Position.z / gl_Position.w) * 0.5 + 0.5;\\n\\t\\tvColor = vec3(linearDepth, expDepth, 0.0);\\n\\t#elif defined color_type_intensity\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = vec3(w, w, w);\\n\\t#elif defined color_type_intensity_gradient\\n\\t\\tfloat w = getIntensity();\\n\\t\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_color\\n\\t\\tvColor = uColor;\\n\\t#elif defined color_type_lod\\n\\tfloat w = getLOD() / 10.0;\\n\\tvColor = texture2D(gradient, vec2(w, 1.0 - w)).rgb;\\n\\t#elif defined color_type_point_index\\n\\t\\tvColor = indices.rgb;\\n\\t#elif defined color_type_classification\\n\\t  vec4 cl = getClassification();\\n\\t\\tvColor = cl.rgb;\\n\\t#elif defined color_type_return_number\\n\\t\\tvColor = getReturnNumber();\\n\\t#elif defined color_type_source\\n\\t\\tvColor = getSourceID();\\n\\t#elif defined color_type_normal\\n\\t\\tvColor = (modelMatrix * vec4(normal, 0.0)).xyz;\\n\\t#elif defined color_type_phong\\n\\t\\tvColor = color;\\n\\t#elif defined color_type_composite\\n\\t\\tvColor = getCompositeColor();\\n\\t#endif\\n\\n\\t#if !defined color_type_composite && defined color_type_classification\\n\\t\\tif (cl.a == 0.0) {\\n\\t\\t\\tgl_Position = vec4(100.0, 100.0, 100.0, 0.0);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t#endif\\n\\n\\t// ---------------------\\n\\t// CLIPPING\\n\\t// ---------------------\\n\\n\\t#if defined use_clip_box\\n\\t\\tbool insideAny = false;\\n\\t\\tvec3 highlightColor = vec3(0.0);\\n\\t\\tfor (int i = 0; i < max_clip_boxes; i++) {\\n\\t\\t\\tif (i == int(clipBoxCount)) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec4 clipPosition = clipBoxes[i] * modelMatrix * vec4(position, 1.0);\\n\\t\\t\\tbool inside = -0.5 <= clipPosition.x && clipPosition.x <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;\\n\\t\\t\\tinside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;\\n\\t\\t\\tinsideAny = insideAny || inside;\\n\\t\\t\\tif (inside) {\\n\\t\\t\\t\\thighlightColor += clipHighlightColors[i].xyz;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (!insideAny) {\\n\\t\\t\\t#if defined clip_outside\\n\\t\\t\\t\\tgl_Position = vec4(1000.0, 1000.0, 1000.0, 1.0);\\n\\t\\t\\t#elif defined clip_highlight_inside && !defined(color_type_depth)\\n\\t\\t\\t\\tfloat c = (vColor.r + vColor.g + vColor.b) / 6.0;\\n\\t\\t\\t#endif\\n\\t\\t} else {\\n\\t\\t\\t#if defined clip_highlight_inside\\n\\t\\t\\t\\tvColor.rgb += highlightColor; \\n\\t\\t\\t#endif\\n\\t\\t}\\n\\t#endif\\n}\\n");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ1LmpzIiwibWFwcGluZ3MiOiI7OztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9zaGFkZXJzL3BvaW50Y2xvdWQudmVydD9lZmM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcbnByZWNpc2lvbiBoaWdocCBpbnQ7XFxuXFxuI2RlZmluZSBtYXhfY2xpcF9ib3hlcyAzMFxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1xcbmF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1xcblxcbiNpZmRlZiBjb2xvcl9yZ2JhXFxuXFx0YXR0cmlidXRlIHZlYzQgcmdiYTtcXG4jZW5kaWZcXG5cXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGludGVuc2l0eTtcXG5hdHRyaWJ1dGUgZmxvYXQgY2xhc3NpZmljYXRpb247XFxuYXR0cmlidXRlIGZsb2F0IHJldHVybk51bWJlcjtcXG5hdHRyaWJ1dGUgZmxvYXQgbnVtYmVyT2ZSZXR1cm5zO1xcbmF0dHJpYnV0ZSBmbG9hdCBwb2ludFNvdXJjZUlEO1xcbmF0dHJpYnV0ZSB2ZWM0IGluZGljZXM7XFxuYXR0cmlidXRlIHZlYzIgdXY7XFxuXFxudW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xcbnVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XFxudW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XFxudW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDtcXG5cXG51bmlmb3JtIGZsb2F0IHBjSW5kZXg7XFxuXFxudW5pZm9ybSBmbG9hdCBzY3JlZW5XaWR0aDtcXG51bmlmb3JtIGZsb2F0IHNjcmVlbkhlaWdodDtcXG51bmlmb3JtIGZsb2F0IGZvdjtcXG51bmlmb3JtIGZsb2F0IHNwYWNpbmc7XFxuXFxuI2lmIGRlZmluZWQgdXNlX2NsaXBfYm94XFxuXFx0dW5pZm9ybSBtYXQ0IGNsaXBCb3hlc1ttYXhfY2xpcF9ib3hlc107XFxuXFx0dW5pZm9ybSB2ZWMzIGNsaXBIaWdobGlnaHRDb2xvcnNbbWF4X2NsaXBfYm94ZXNdO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gZmxvYXQgaGVpZ2h0TWluO1xcbnVuaWZvcm0gZmxvYXQgaGVpZ2h0TWF4O1xcbnVuaWZvcm0gZmxvYXQgc2l6ZTsgLy8gcGl4ZWwgc2l6ZSBmYWN0b3JcXG51bmlmb3JtIGZsb2F0IG1pblNpemU7IC8vIG1pbmltdW0gcGl4ZWwgc2l6ZVxcbnVuaWZvcm0gZmxvYXQgbWF4U2l6ZTsgLy8gbWF4aW11bSBwaXhlbCBzaXplXFxudW5pZm9ybSBmbG9hdCBvY3RyZWVTaXplO1xcbnVuaWZvcm0gdmVjMyBiYlNpemU7XFxudW5pZm9ybSB2ZWMzIHVDb2xvcjtcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCBjbGlwQm94Q291bnQ7XFxudW5pZm9ybSBmbG9hdCBsZXZlbDtcXG51bmlmb3JtIGZsb2F0IHZuU3RhcnQ7XFxudW5pZm9ybSBib29sIGlzTGVhZk5vZGU7XFxuXFxudW5pZm9ybSBmbG9hdCBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZDtcXG51bmlmb3JtIHZlYzIgaW50ZW5zaXR5UmFuZ2U7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5QXR0ZW51YXRpb247XFxudW5pZm9ybSBmbG9hdCBpbnRlbnNpdHlHYW1tYTtcXG51bmlmb3JtIGZsb2F0IGludGVuc2l0eUNvbnRyYXN0O1xcbnVuaWZvcm0gZmxvYXQgaW50ZW5zaXR5QnJpZ2h0bmVzcztcXG51bmlmb3JtIGZsb2F0IHJnYkdhbW1hO1xcbnVuaWZvcm0gZmxvYXQgcmdiQ29udHJhc3Q7XFxudW5pZm9ybSBmbG9hdCByZ2JCcmlnaHRuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdHJhbnNpdGlvbjtcXG51bmlmb3JtIGZsb2F0IHdSR0I7XFxudW5pZm9ybSBmbG9hdCB3SW50ZW5zaXR5O1xcbnVuaWZvcm0gZmxvYXQgd0VsZXZhdGlvbjtcXG51bmlmb3JtIGZsb2F0IHdDbGFzc2lmaWNhdGlvbjtcXG51bmlmb3JtIGZsb2F0IHdSZXR1cm5OdW1iZXI7XFxudW5pZm9ybSBmbG9hdCB3U291cmNlSUQ7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgdmlzaWJsZU5vZGVzO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGdyYWRpZW50O1xcbnVuaWZvcm0gc2FtcGxlcjJEIGNsYXNzaWZpY2F0aW9uTFVUO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGRlcHRoTWFwO1xcblxcbiNpZmRlZiB1c2VfdGV4dHVyZV9ibGVuZGluZ1xcblxcdHVuaWZvcm0gc2FtcGxlcjJEIGJhY2tncm91bmRNYXA7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIHVzZV9wb2ludF9jbG91ZF9taXhpbmdcXG5cXHR1bmlmb3JtIGludCBwb2ludENsb3VkTWl4aW5nTW9kZTtcXG5cXHR1bmlmb3JtIGZsb2F0IHBvaW50Q2xvdWRJRDtcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IHBvaW50Q2xvdWRNaXhBbmdsZTtcXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpc3RhbmNlWDtcXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpc3RhbmNlWTtcXG5cXG5cXHR1bmlmb3JtIGZsb2F0IHN0cmlwZURpdmlzb3JYO1xcblxcdHVuaWZvcm0gZmxvYXQgc3RyaXBlRGl2aXNvclk7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIGhpZ2hsaWdodF9wb2ludFxcblxcdHVuaWZvcm0gdmVjMyBoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZTtcXG5cXHR1bmlmb3JtIGJvb2wgZW5hYmxlUG9pbnRIaWdobGlnaHRpbmc7XFxuXFx0dW5pZm9ybSBmbG9hdCBoaWdobGlnaHRlZFBvaW50U2NhbGU7XFxuI2VuZGlmXFxuXFxuI2lmZGVmIHVzZV9maWx0ZXJfYnlfbm9ybWFsXFxuXFx0dW5pZm9ybSBpbnQgbm9ybWFsRmlsdGVyaW5nTW9kZTtcXG4jZW5kaWZcXG5cXG52YXJ5aW5nIHZlYzMgdkNvbG9yO1xcblxcbiNpZiAhZGVmaW5lZChjb2xvcl90eXBlX3BvaW50X2luZGV4KVxcblxcdHZhcnlpbmcgZmxvYXQgdk9wYWNpdHk7XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKVxcblxcdHZhcnlpbmcgZmxvYXQgdkxpbmVhckRlcHRoO1xcbiNlbmRpZlxcblxcbiNpZiAhZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKSAmJiBkZWZpbmVkKHVzZV9lZGwpXFxuXFx0dmFyeWluZyBmbG9hdCB2TG9nRGVwdGg7XFxuI2VuZGlmXFxuXFxuI2lmIGRlZmluZWQoY29sb3JfdHlwZV9waG9uZykgJiYgKE1BWF9QT0lOVF9MSUdIVFMgPiAwIHx8IE1BWF9ESVJfTElHSFRTID4gMCkgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKVxcblxcdHZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcbiNlbmRpZlxcblxcbiNpZiBkZWZpbmVkKHdlaWdodGVkX3NwbGF0cykgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKVxcblxcdHZhcnlpbmcgZmxvYXQgdlJhZGl1cztcXG4jZW5kaWZcXG5cXG4jaWYgZGVmaW5lZChjb2xvcl90eXBlX3Bob25nKSAmJiAoTUFYX1BPSU5UX0xJR0hUUyA+IDAgfHwgTUFYX0RJUl9MSUdIVFMgPiAwKVxcblxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcbiNlbmRpZlxcblxcbiNpZmRlZiBoaWdobGlnaHRfcG9pbnRcXG5cXHR2YXJ5aW5nIGZsb2F0IHZIaWdobGlnaHQ7XFxuI2VuZGlmXFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gT0NUUkVFXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuI2lmIChkZWZpbmVkKGFkYXB0aXZlX3BvaW50X3NpemUpIHx8IGRlZmluZWQoY29sb3JfdHlwZV9sb2QpKSAmJiBkZWZpbmVkKHRyZWVfdHlwZV9vY3RyZWUpXFxuXFxuLyoqXFxuICogUm91bmRzIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHRvIHRoZSBjbG9zZXN0IGludGVnZXIuXFxuICovXFxuZmxvYXQgcm91bmQoZmxvYXQgbnVtYmVyKXtcXG5cXHRyZXR1cm4gZmxvb3IobnVtYmVyICsgMC41KTtcXG59XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgbnVtYmVyIG9mIDEtYml0cyB1cCB0byBpbmNsdXNpdmUgaW5kZXggcG9zaXRpb24uXFxuICpcXG4gKiBudW1iZXIgaXMgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlIDAtMjU1XFxuICovXFxuaW50IG51bWJlck9mT25lcyhpbnQgbnVtYmVyLCBpbnQgaW5kZXgpIHtcXG5cXHRpbnQgbnVtT25lcyA9IDA7XFxuXFx0aW50IHRtcCA9IDEyODtcXG5cXHRmb3IgKGludCBpID0gNzsgaSA+PSAwOyBpLS0pIHtcXG5cXG5cXHRcXHRpZiAobnVtYmVyID49IHRtcCkge1xcblxcdFxcdFxcdG51bWJlciA9IG51bWJlciAtIHRtcDtcXG5cXG5cXHRcXHRcXHRpZiAoaSA8PSBpbmRleCkge1xcblxcdFxcdFxcdFxcdG51bU9uZXMrKztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRtcCA9IHRtcCAvIDI7XFxuXFx0fVxcblxcblxcdHJldHVybiBudW1PbmVzO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgYml0IGF0IGluZGV4IGlzIDEuMFxcbiAqXFxuICogbnVtYmVyIGlzIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBhbiBpbnRlZ2VyIGluIHRoZSByYW5nZSAwLTI1NVxcbiAqL1xcbmJvb2wgaXNCaXRTZXQoaW50IG51bWJlciwgaW50IGluZGV4KXtcXG5cXG5cXHQvLyB3ZWlyZCBtdWx0aSBlbHNlIGlmIGR1ZSB0byBsYWNrIG9mIHByb3BlciBhcnJheSwgaW50IGFuZCBiaXR3aXNlIHN1cHBvcnQgaW4gV2ViR0wgMS4wXFxuXFx0aW50IHBvd2kgPSAxO1xcblxcdGlmIChpbmRleCA9PSAwKSB7XFxuXFx0XFx0cG93aSA9IDE7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSAxKSB7XFxuXFx0XFx0cG93aSA9IDI7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSAyKSB7XFxuXFx0XFx0cG93aSA9IDQ7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSAzKSB7XFxuXFx0XFx0cG93aSA9IDg7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSA0KSB7XFxuXFx0XFx0cG93aSA9IDE2O1xcblxcdH0gZWxzZSBpZiAoaW5kZXggPT0gNSkge1xcblxcdFxcdHBvd2kgPSAzMjtcXG5cXHR9IGVsc2UgaWYgKGluZGV4ID09IDYpIHtcXG5cXHRcXHRwb3dpID0gNjQ7XFxuXFx0fSBlbHNlIGlmIChpbmRleCA9PSA3KSB7XFxuXFx0XFx0cG93aSA9IDEyODtcXG5cXHR9XFxuXFxuXFx0aW50IG5kcCA9IG51bWJlciAvIHBvd2k7XFxuXFxuXFx0cmV0dXJuIG1vZChmbG9hdChuZHApLCAyLjApICE9IDAuMDtcXG59XFxuXFxuLyoqXFxuICogR2V0cyB0aGUgdGhlIExPRCBhdCB0aGUgcG9pbnQgcG9zaXRpb24uXFxuICovXFxuZmxvYXQgZ2V0TE9EKCkge1xcblxcdHZlYzMgb2Zmc2V0ID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcXG5cXHRpbnQgaU9mZnNldCA9IGludCh2blN0YXJ0KTtcXG5cXHRmbG9hdCBkZXB0aCA9IGxldmVsO1xcblxcblxcdGZvciAoZmxvYXQgaSA9IDAuMDsgaSA8PSAzMC4wOyBpKyspIHtcXG5cXHRcXHRmbG9hdCBub2RlU2l6ZUF0TGV2ZWwgPSBvY3RyZWVTaXplICAvIHBvdygyLjAsIGkgKyBsZXZlbCArIDAuMCk7XFxuXFxuXFx0XFx0dmVjMyBpbmRleDNkID0gKHBvc2l0aW9uLW9mZnNldCkgLyBub2RlU2l6ZUF0TGV2ZWw7XFxuXFx0XFx0aW5kZXgzZCA9IGZsb29yKGluZGV4M2QgKyAwLjUpO1xcblxcdFxcdGludCBpbmRleCA9IGludChyb3VuZCg0LjAgKiBpbmRleDNkLnggKyAyLjAgKiBpbmRleDNkLnkgKyBpbmRleDNkLnopKTtcXG5cXG5cXHRcXHR2ZWM0IHZhbHVlID0gdGV4dHVyZTJEKHZpc2libGVOb2RlcywgdmVjMihmbG9hdChpT2Zmc2V0KSAvIDIwNDguMCwgMC4wKSk7XFxuXFx0XFx0aW50IG1hc2sgPSBpbnQocm91bmQodmFsdWUuciAqIDI1NS4wKSk7XFxuXFxuXFx0XFx0aWYgKGlzQml0U2V0KG1hc2ssIGluZGV4KSkge1xcblxcdFxcdFxcdC8vIHRoZXJlIGFyZSBtb3JlIHZpc2libGUgY2hpbGQgbm9kZXMgYXQgdGhpcyBwb3NpdGlvblxcblxcdFxcdFxcdGludCBhZHZhbmNlRyA9IGludChyb3VuZCh2YWx1ZS5nICogMjU1LjApKSAqIDI1NjtcXG5cXHRcXHRcXHRpbnQgYWR2YW5jZUIgPSBpbnQocm91bmQodmFsdWUuYiAqIDI1NS4wKSk7XFxuXFx0XFx0XFx0aW50IGFkdmFuY2VDaGlsZCA9IG51bWJlck9mT25lcyhtYXNrLCBpbmRleCAtIDEpO1xcblxcdFxcdFxcdGludCBhZHZhbmNlID0gYWR2YW5jZUcgKyBhZHZhbmNlQiArIGFkdmFuY2VDaGlsZDtcXG5cXG5cXHRcXHRcXHRpT2Zmc2V0ID0gaU9mZnNldCArIGFkdmFuY2U7XFxuXFxuXFx0XFx0XFx0ZGVwdGgrKztcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJldHVybiB2YWx1ZS5hICogMjU1LjA7IC8vIG5vIG1vcmUgdmlzaWJsZSBjaGlsZCBub2RlcyBhdCB0aGlzIHBvc2l0aW9uXFxuXFx0XFx0fVxcblxcblxcdFxcdG9mZnNldCA9IG9mZnNldCArICh2ZWMzKDEuMCwgMS4wLCAxLjApICogbm9kZVNpemVBdExldmVsICogMC41KSAqIGluZGV4M2Q7XFxuXFx0fVxcblxcblxcdHJldHVybiBkZXB0aDtcXG59XFxuXFxuZmxvYXQgZ2V0UG9pbnRTaXplQXR0ZW51YXRpb24oKSB7XFxuXFx0cmV0dXJuIDAuNSAqIHBvdygyLjAsIGdldExPRCgpKTtcXG59XFxuXFxuI2VuZGlmXFxuXFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuLy8gS0QtVFJFRVxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcbiNpZiAoZGVmaW5lZChhZGFwdGl2ZV9wb2ludF9zaXplKSB8fCBkZWZpbmVkKGNvbG9yX3R5cGVfbG9kKSkgJiYgZGVmaW5lZCh0cmVlX3R5cGVfa2R0cmVlKVxcblxcbmZsb2F0IGdldExPRCgpIHtcXG5cXHR2ZWMzIG9mZnNldCA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0ZmxvYXQgaW50T2Zmc2V0ID0gMC4wO1xcblxcdGZsb2F0IGRlcHRoID0gMC4wO1xcblxcblxcdHZlYzMgc2l6ZSA9IGJiU2l6ZTtcXG5cXHR2ZWMzIHBvcyA9IHBvc2l0aW9uO1xcblxcblxcdGZvciAoZmxvYXQgaSA9IDAuMDsgaSA8PSAxMDAwLjA7IGkrKykge1xcblxcblxcdFxcdHZlYzQgdmFsdWUgPSB0ZXh0dXJlMkQodmlzaWJsZU5vZGVzLCB2ZWMyKGludE9mZnNldCAvIDIwNDguMCwgMC4wKSk7XFxuXFxuXFx0XFx0aW50IGNoaWxkcmVuID0gaW50KHZhbHVlLnIgKiAyNTUuMCk7XFxuXFx0XFx0ZmxvYXQgbmV4dCA9IHZhbHVlLmcgKiAyNTUuMDtcXG5cXHRcXHRpbnQgc3BsaXQgPSBpbnQodmFsdWUuYiAqIDI1NS4wKTtcXG5cXG5cXHRcXHRpZiAobmV4dCA9PSAwLjApIHtcXG5cXHRcXHQgXFx0cmV0dXJuIGRlcHRoO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR2ZWMzIHNwbGl0diA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0aWYgKHNwbGl0ID09IDEpIHtcXG5cXHRcXHRcXHRzcGxpdHYueCA9IDEuMDtcXG5cXHRcXHR9IGVsc2UgaWYgKHNwbGl0ID09IDIpIHtcXG5cXHRcXHQgXFx0c3BsaXR2LnkgPSAxLjA7XFxuXFx0XFx0fSBlbHNlIGlmIChzcGxpdCA9PSA0KSB7XFxuXFx0XFx0IFxcdHNwbGl0di56ID0gMS4wO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpbnRPZmZzZXQgPSBpbnRPZmZzZXQgKyBuZXh0O1xcblxcblxcdFxcdGZsb2F0IGZhY3RvciA9IGxlbmd0aChwb3MgKiBzcGxpdHYgLyBzaXplKTtcXG5cXHRcXHRpZiAoZmFjdG9yIDwgMC41KSB7XFxuXFx0XFx0IFxcdC8vIGxlZnRcXG5cXHRcXHRcXHRpZiAoY2hpbGRyZW4gPT0gMCB8fCBjaGlsZHJlbiA9PSAyKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRlcHRoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdC8vIHJpZ2h0XFxuXFx0XFx0XFx0cG9zID0gcG9zIC0gc2l6ZSAqIHNwbGl0diAqIDAuNTtcXG5cXHRcXHRcXHRpZiAoY2hpbGRyZW4gPT0gMCB8fCBjaGlsZHJlbiA9PSAxKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRlcHRoO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoY2hpbGRyZW4gPT0gMykge1xcblxcdFxcdFxcdFxcdGludE9mZnNldCA9IGludE9mZnNldCArIDEuMDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdFxcdHNpemUgPSBzaXplICogKCgxLjAgLSAoc3BsaXR2ICsgMS4wKSAvIDIuMCkgKyAwLjUpO1xcblxcblxcdFxcdGRlcHRoKys7XFxuXFx0fVxcblxcblxcblxcdHJldHVybiBkZXB0aDtcXG59XFxuXFxuZmxvYXQgZ2V0UG9pbnRTaXplQXR0ZW51YXRpb24oKSB7XFxuXFx0cmV0dXJuIDAuNSAqIHBvdygxLjMsIGdldExPRCgpKTtcXG59XFxuXFxuI2VuZGlmXFxuXFxuLy8gZm9ybXVsYSBhZGFwdGVkIGZyb206IGh0dHA6Ly93d3cuZGZzdHVkaW9zLmNvLnVrL2FydGljbGVzL3Byb2dyYW1taW5nL2ltYWdlLXByb2dyYW1taW5nLWFsZ29yaXRobXMvaW1hZ2UtcHJvY2Vzc2luZy1hbGdvcml0aG1zLXBhcnQtNS1jb250cmFzdC1hZGp1c3RtZW50L1xcbmZsb2F0IGdldENvbnRyYXN0RmFjdG9yKGZsb2F0IGNvbnRyYXN0KSB7XFxuXFx0cmV0dXJuICgxLjAxNTg3MzAxNTg3MzAxNTYgKiAoY29udHJhc3QgKyAxLjApKSAvICgxLjAxNTg3MzAxNTg3MzAxNTYgLSBjb250cmFzdCk7XFxufVxcblxcbnZlYzMgZ2V0UkdCKCkge1xcblxcdFxcblxcdCNpZmRlZiBjb2xvcl9yZ2JhXFxuXFx0XFx0dmVjMyByZ2IgPSByZ2JhLnJnYjtcXG5cXHQjZWxzZVxcdFxcblxcdFxcdHZlYzMgcmdiID0gY29sb3I7XFxuXFx0I2VuZGlmXFx0XFx0XFxuXFxuXFx0I2lmIGRlZmluZWQodXNlX3JnYl9nYW1tYV9jb250cmFzdF9icmlnaHRuZXNzKVxcblxcdFxcdHJnYiA9IHBvdyhyZ2IsIHZlYzMocmdiR2FtbWEpKTtcXG5cXHRcXHRyZ2IgPSByZ2IgKyByZ2JCcmlnaHRuZXNzO1xcblxcdFxcdHJnYiA9IChyZ2IgLSAwLjUpICogZ2V0Q29udHJhc3RGYWN0b3IocmdiQ29udHJhc3QpICsgMC41O1xcblxcdFxcdHJnYiA9IGNsYW1wKHJnYiwgMC4wLCAxLjApO1xcblxcdFxcdHJldHVybiByZ2I7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gcmdiO1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRJbnRlbnNpdHkoKSB7XFxuXFx0ZmxvYXQgdyA9IChpbnRlbnNpdHkgLSBpbnRlbnNpdHlSYW5nZS54KSAvIChpbnRlbnNpdHlSYW5nZS55IC0gaW50ZW5zaXR5UmFuZ2UueCk7XFxuXFx0dyA9IHBvdyh3LCBpbnRlbnNpdHlHYW1tYSk7XFxuXFx0dyA9IHcgKyBpbnRlbnNpdHlCcmlnaHRuZXNzO1xcblxcdHcgPSAodyAtIDAuNSkgKiBnZXRDb250cmFzdEZhY3RvcihpbnRlbnNpdHlDb250cmFzdCkgKyAwLjU7XFxuXFx0dyA9IGNsYW1wKHcsIDAuMCwgMS4wKTtcXG5cXG5cXHRyZXR1cm4gdztcXG59XFxuXFxudmVjMyBnZXRFbGV2YXRpb24oKSB7XFxuXFx0dmVjNCB3b3JsZCA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcdGZsb2F0IHcgPSAod29ybGQueiAtIGhlaWdodE1pbikgLyAoaGVpZ2h0TWF4LWhlaWdodE1pbik7XFxuXFx0dmVjMyBjRWxldmF0aW9uID0gdGV4dHVyZTJEKGdyYWRpZW50LCB2ZWMyKHcsMS4wLXcpKS5yZ2I7XFxuXFxuXFx0cmV0dXJuIGNFbGV2YXRpb247XFxufVxcblxcbnZlYzQgZ2V0Q2xhc3NpZmljYXRpb24oKSB7XFxuXFx0dmVjMiB1diA9IHZlYzIoY2xhc3NpZmljYXRpb24gLyAyNTUuMCwgMC41KTtcXG5cXHR2ZWM0IGNsYXNzQ29sb3IgPSB0ZXh0dXJlMkQoY2xhc3NpZmljYXRpb25MVVQsIHV2KTtcXG5cXG5cXHRyZXR1cm4gY2xhc3NDb2xvcjtcXG59XFxuXFxudmVjMyBnZXRSZXR1cm5OdW1iZXIoKSB7XFxuXFx0aWYgKG51bWJlck9mUmV0dXJucyA9PSAxLjApIHtcXG5cXHRcXHRyZXR1cm4gdmVjMygxLjAsIDEuMCwgMC4wKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdGlmIChyZXR1cm5OdW1iZXIgPT0gMS4wKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoMS4wLCAwLjAsIDAuMCk7XFxuXFx0XFx0fSBlbHNlIGlmIChyZXR1cm5OdW1iZXIgPT0gbnVtYmVyT2ZSZXR1cm5zKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYzMoMC4wLCAwLjAsIDEuMCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjMygwLjAsIDEuMCwgMC4wKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG52ZWMzIGdldFNvdXJjZUlEKCkge1xcblxcdGZsb2F0IHcgPSBtb2QocG9pbnRTb3VyY2VJRCwgMTAuMCkgLyAxMC4wO1xcblxcdHJldHVybiB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywgMS4wIC0gdykpLnJnYjtcXG59XFxuXFxudmVjMyBnZXRDb21wb3NpdGVDb2xvcigpIHtcXG5cXHR2ZWMzIGM7XFxuXFx0ZmxvYXQgdztcXG5cXG5cXHRjICs9IHdSR0IgKiBnZXRSR0IoKTtcXG5cXHR3ICs9IHdSR0I7XFxuXFxuXFx0YyArPSB3SW50ZW5zaXR5ICogZ2V0SW50ZW5zaXR5KCkgKiB2ZWMzKDEuMCwgMS4wLCAxLjApO1xcblxcdHcgKz0gd0ludGVuc2l0eTtcXG5cXG5cXHRjICs9IHdFbGV2YXRpb24gKiBnZXRFbGV2YXRpb24oKTtcXG5cXHR3ICs9IHdFbGV2YXRpb247XFxuXFxuXFx0YyArPSB3UmV0dXJuTnVtYmVyICogZ2V0UmV0dXJuTnVtYmVyKCk7XFxuXFx0dyArPSB3UmV0dXJuTnVtYmVyO1xcblxcblxcdGMgKz0gd1NvdXJjZUlEICogZ2V0U291cmNlSUQoKTtcXG5cXHR3ICs9IHdTb3VyY2VJRDtcXG5cXG5cXHR2ZWM0IGNsID0gd0NsYXNzaWZpY2F0aW9uICogZ2V0Q2xhc3NpZmljYXRpb24oKTtcXG5cXHRjICs9IGNsLmEgKiBjbC5yZ2I7XFxuXFx0dyArPSB3Q2xhc3NpZmljYXRpb24gKiBjbC5hO1xcblxcblxcdGMgPSBjIC8gdztcXG5cXG5cXHRpZiAodyA9PSAwLjApIHtcXG5cXHRcXHRnbF9Qb3NpdGlvbiA9IHZlYzQoMTAwLjAsIDEwMC4wLCAxMDAuMCwgMC4wKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGM7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG5cXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1xcblxcblxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxuXFxuXFx0I2lmIGRlZmluZWQoY29sb3JfdHlwZV9waG9uZykgJiYgKE1BWF9QT0lOVF9MSUdIVFMgPiAwIHx8IE1BWF9ESVJfTElHSFRTID4gMCkgfHwgZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKVxcblxcdFxcdHZWaWV3UG9zaXRpb24gPSBtdlBvc2l0aW9uLnh5ejtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgZGVmaW5lZCB3ZWlnaHRlZF9zcGxhdHNcXG5cXHRcXHR2TGluZWFyRGVwdGggPSBnbF9Qb3NpdGlvbi53O1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiBkZWZpbmVkKGNvbG9yX3R5cGVfcGhvbmcpICYmIChNQVhfUE9JTlRfTElHSFRTID4gMCB8fCBNQVhfRElSX0xJR0hUUyA+IDApXFxuXFx0XFx0dk5vcm1hbCA9IG5vcm1hbGl6ZShub3JtYWxNYXRyaXggKiBub3JtYWwpO1xcblxcdCNlbmRpZlxcblxcblxcdCNpZiAhZGVmaW5lZChwYXJhYm9sb2lkX3BvaW50X3NoYXBlKSAmJiBkZWZpbmVkKHVzZV9lZGwpXFxuXFx0XFx0dkxvZ0RlcHRoID0gbG9nMigtbXZQb3NpdGlvbi56KTtcXG5cXHQjZW5kaWZcXG5cXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHQvLyBQT0lOVCBTSVpFXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0ZmxvYXQgcG9pbnRTaXplID0gMS4wO1xcblxcdGZsb2F0IHNsb3BlID0gdGFuKGZvdiAvIDIuMCk7XFxuXFx0ZmxvYXQgcHJvakZhY3RvciA9ICAtMC41ICogc2NyZWVuSGVpZ2h0IC8gKHNsb3BlICogbXZQb3NpdGlvbi56KTtcXG5cXG5cXHQjaWYgZGVmaW5lZCBmaXhlZF9wb2ludF9zaXplXFxuXFx0XFx0cG9pbnRTaXplID0gc2l6ZTtcXG5cXHQjZWxpZiBkZWZpbmVkIGF0dGVudWF0ZWRfcG9pbnRfc2l6ZVxcblxcdFxcdHBvaW50U2l6ZSA9IHNpemUgKiBzcGFjaW5nICogcHJvakZhY3RvcjtcXG5cXHQjZWxpZiBkZWZpbmVkIGFkYXB0aXZlX3BvaW50X3NpemVcXG5cXHRcXHRmbG9hdCB3b3JsZFNwYWNlU2l6ZSA9IDIuMCAqIHNpemUgKiBzcGFjaW5nIC8gZ2V0UG9pbnRTaXplQXR0ZW51YXRpb24oKTtcXG5cXHRcXHRwb2ludFNpemUgPSB3b3JsZFNwYWNlU2l6ZSAqIHByb2pGYWN0b3I7XFxuXFx0I2VuZGlmXFxuXFxuXFx0cG9pbnRTaXplID0gbWF4KG1pblNpemUsIHBvaW50U2l6ZSk7XFxuXFx0cG9pbnRTaXplID0gbWluKG1heFNpemUsIHBvaW50U2l6ZSk7XFxuXFxuXFx0I2lmIGRlZmluZWQod2VpZ2h0ZWRfc3BsYXRzKSB8fCBkZWZpbmVkKHBhcmFib2xvaWRfcG9pbnRfc2hhcGUpXFxuXFx0XFx0dlJhZGl1cyA9IHBvaW50U2l6ZSAvIHByb2pGYWN0b3I7XFxuXFx0I2VuZGlmXFxuXFxuXFx0Z2xfUG9pbnRTaXplID0gcG9pbnRTaXplO1xcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIEhJR0hMSUdIVElOR1xcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcblxcdCNpZmRlZiBoaWdobGlnaHRfcG9pbnRcXG5cXHRcXHR2ZWM0IG1Qb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHRcXHRpZiAoZW5hYmxlUG9pbnRIaWdobGlnaHRpbmcgJiYgYWJzKG1Qb3NpdGlvbi54IC0gaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGUueCkgPCAwLjAwMDEgJiZcXG5cXHRcXHRcXHRhYnMobVBvc2l0aW9uLnkgLSBoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZS55KSA8IDAuMDAwMSAmJlxcblxcdFxcdFxcdGFicyhtUG9zaXRpb24ueiAtIGhpZ2hsaWdodGVkUG9pbnRDb29yZGluYXRlLnopIDwgMC4wMDAxKSB7XFxuXFx0XFx0XFx0dkhpZ2hsaWdodCA9IDEuMDtcXG5cXHRcXHRcXHRnbF9Qb2ludFNpemUgPSBwb2ludFNpemUgKiBoaWdobGlnaHRlZFBvaW50U2NhbGU7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2SGlnaGxpZ2h0ID0gMC4wO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHQvLyBPUEFDSVRZXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmbmRlZiBjb2xvcl90eXBlX3BvaW50X2luZGV4XFxuXFx0XFx0I2lmZGVmIGF0dGVudWF0ZWRfb3BhY2l0eVxcblxcdFxcdFxcdHZPcGFjaXR5ID0gb3BhY2l0eSAqIGV4cCgtbGVuZ3RoKC1tdlBvc2l0aW9uLnh5eikgLyBvcGFjaXR5QXR0ZW51YXRpb24pO1xcblxcdFxcdCNlbHNlXFxuXFx0XFx0XFx0dk9wYWNpdHkgPSBvcGFjaXR5O1xcblxcdFxcdCNlbmRpZlxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIEZJTFRFUklOR1xcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcblxcdCNpZmRlZiB1c2VfZmlsdGVyX2J5X25vcm1hbFxcblxcdFxcdGJvb2wgZGlzY2FyZFBvaW50ID0gZmFsc2U7XFxuXFx0XFx0Ly8gQWJzb2x1dGUgbm9ybWFsIGZpbHRlcmluZ1xcblxcdFxcdGlmIChub3JtYWxGaWx0ZXJpbmdNb2RlID09IDEpIHtcXG5cXHRcXHRcXHRkaXNjYXJkUG9pbnQgPSAoYWJzKChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueikgPiBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZCk7XFxuXFx0XFx0fVxcblxcdFxcdC8vIGxlc3MgdGhhbiBlcXVhbCB0b1xcblxcdFxcdGVsc2UgaWYgKG5vcm1hbEZpbHRlcmluZ01vZGUgPT0gMikge1xcblxcdFxcdFxcdGRpc2NhcmRQb2ludCA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KG5vcm1hbCwgMC4wKSkueiA8PSBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0Ly8gZ3JlYXRlciB0aGFuXFxuXFx0XFx0ZWxzZSBpZihub3JtYWxGaWx0ZXJpbmdNb2RlID09IDMpIHtcXG5cXHRcXHRcXHRkaXNjYXJkUG9pbnQgPSAobW9kZWxWaWV3TWF0cml4ICogdmVjNChub3JtYWwsIDAuMCkpLnogPiBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZDtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGRpc2NhcmRQb2ludClcXG5cXHRcXHR7XFxuXFx0XFx0XFx0Z2xfUG9zaXRpb24gPSB2ZWM0KDAuMCwgMC4wLCAyLjAsIDEuMCk7XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcdC8vIFBPSU5UIENPTE9SXFxuXFx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFx0I2lmZGVmIGNvbG9yX3R5cGVfcmdiXFxuXFx0XFx0dkNvbG9yID0gZ2V0UkdCKCk7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX2hlaWdodFxcblxcdFxcdHZDb2xvciA9IGdldEVsZXZhdGlvbigpO1xcblxcdCNlbGlmIGRlZmluZWQgY29sb3JfdHlwZV9yZ2JfaGVpZ2h0XFxuXFx0XFx0dmVjMyBjSGVpZ2h0ID0gZ2V0RWxldmF0aW9uKCk7XFxuXFx0XFx0dkNvbG9yID0gKDEuMCAtIHRyYW5zaXRpb24pICogZ2V0UkdCKCkgKyB0cmFuc2l0aW9uICogY0hlaWdodDtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfZGVwdGhcXG5cXHRcXHRmbG9hdCBsaW5lYXJEZXB0aCA9IC1tdlBvc2l0aW9uLnogO1xcblxcdFxcdGZsb2F0IGV4cERlcHRoID0gKGdsX1Bvc2l0aW9uLnogLyBnbF9Qb3NpdGlvbi53KSAqIDAuNSArIDAuNTtcXG5cXHRcXHR2Q29sb3IgPSB2ZWMzKGxpbmVhckRlcHRoLCBleHBEZXB0aCwgMC4wKTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfaW50ZW5zaXR5XFxuXFx0XFx0ZmxvYXQgdyA9IGdldEludGVuc2l0eSgpO1xcblxcdFxcdHZDb2xvciA9IHZlYzModywgdywgdyk7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX2ludGVuc2l0eV9ncmFkaWVudFxcblxcdFxcdGZsb2F0IHcgPSBnZXRJbnRlbnNpdHkoKTtcXG5cXHRcXHR2Q29sb3IgPSB0ZXh0dXJlMkQoZ3JhZGllbnQsIHZlYzIodywgMS4wIC0gdykpLnJnYjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfY29sb3JcXG5cXHRcXHR2Q29sb3IgPSB1Q29sb3I7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX2xvZFxcblxcdGZsb2F0IHcgPSBnZXRMT0QoKSAvIDEwLjA7XFxuXFx0dkNvbG9yID0gdGV4dHVyZTJEKGdyYWRpZW50LCB2ZWMyKHcsIDEuMCAtIHcpKS5yZ2I7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX3BvaW50X2luZGV4XFxuXFx0XFx0dkNvbG9yID0gaW5kaWNlcy5yZ2I7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX2NsYXNzaWZpY2F0aW9uXFxuXFx0ICB2ZWM0IGNsID0gZ2V0Q2xhc3NpZmljYXRpb24oKTtcXG5cXHRcXHR2Q29sb3IgPSBjbC5yZ2I7XFxuXFx0I2VsaWYgZGVmaW5lZCBjb2xvcl90eXBlX3JldHVybl9udW1iZXJcXG5cXHRcXHR2Q29sb3IgPSBnZXRSZXR1cm5OdW1iZXIoKTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfc291cmNlXFxuXFx0XFx0dkNvbG9yID0gZ2V0U291cmNlSUQoKTtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfbm9ybWFsXFxuXFx0XFx0dkNvbG9yID0gKG1vZGVsTWF0cml4ICogdmVjNChub3JtYWwsIDAuMCkpLnh5ejtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfcGhvbmdcXG5cXHRcXHR2Q29sb3IgPSBjb2xvcjtcXG5cXHQjZWxpZiBkZWZpbmVkIGNvbG9yX3R5cGVfY29tcG9zaXRlXFxuXFx0XFx0dkNvbG9yID0gZ2V0Q29tcG9zaXRlQ29sb3IoKTtcXG5cXHQjZW5kaWZcXG5cXG5cXHQjaWYgIWRlZmluZWQgY29sb3JfdHlwZV9jb21wb3NpdGUgJiYgZGVmaW5lZCBjb2xvcl90eXBlX2NsYXNzaWZpY2F0aW9uXFxuXFx0XFx0aWYgKGNsLmEgPT0gMC4wKSB7XFxuXFx0XFx0XFx0Z2xfUG9zaXRpb24gPSB2ZWM0KDEwMC4wLCAxMDAuMCwgMTAwLjAsIDAuMCk7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXHQjZW5kaWZcXG5cXG5cXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHQvLyBDTElQUElOR1xcblxcdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcblxcdCNpZiBkZWZpbmVkIHVzZV9jbGlwX2JveFxcblxcdFxcdGJvb2wgaW5zaWRlQW55ID0gZmFsc2U7XFxuXFx0XFx0dmVjMyBoaWdobGlnaHRDb2xvciA9IHZlYzMoMC4wKTtcXG5cXHRcXHRmb3IgKGludCBpID0gMDsgaSA8IG1heF9jbGlwX2JveGVzOyBpKyspIHtcXG5cXHRcXHRcXHRpZiAoaSA9PSBpbnQoY2xpcEJveENvdW50KSkge1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2ZWM0IGNsaXBQb3NpdGlvbiA9IGNsaXBCb3hlc1tpXSAqIG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcXG5cXHRcXHRcXHRib29sIGluc2lkZSA9IC0wLjUgPD0gY2xpcFBvc2l0aW9uLnggJiYgY2xpcFBvc2l0aW9uLnggPD0gMC41O1xcblxcdFxcdFxcdGluc2lkZSA9IGluc2lkZSAmJiAtMC41IDw9IGNsaXBQb3NpdGlvbi55ICYmIGNsaXBQb3NpdGlvbi55IDw9IDAuNTtcXG5cXHRcXHRcXHRpbnNpZGUgPSBpbnNpZGUgJiYgLTAuNSA8PSBjbGlwUG9zaXRpb24ueiAmJiBjbGlwUG9zaXRpb24ueiA8PSAwLjU7XFxuXFx0XFx0XFx0aW5zaWRlQW55ID0gaW5zaWRlQW55IHx8IGluc2lkZTtcXG5cXHRcXHRcXHRpZiAoaW5zaWRlKSB7XFxuXFx0XFx0XFx0XFx0aGlnaGxpZ2h0Q29sb3IgKz0gY2xpcEhpZ2hsaWdodENvbG9yc1tpXS54eXo7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIWluc2lkZUFueSkge1xcblxcdFxcdFxcdCNpZiBkZWZpbmVkIGNsaXBfb3V0c2lkZVxcblxcdFxcdFxcdFxcdGdsX1Bvc2l0aW9uID0gdmVjNCgxMDAwLjAsIDEwMDAuMCwgMTAwMC4wLCAxLjApO1xcblxcdFxcdFxcdCNlbGlmIGRlZmluZWQgY2xpcF9oaWdobGlnaHRfaW5zaWRlICYmICFkZWZpbmVkKGNvbG9yX3R5cGVfZGVwdGgpXFxuXFx0XFx0XFx0XFx0ZmxvYXQgYyA9ICh2Q29sb3IuciArIHZDb2xvci5nICsgdkNvbG9yLmIpIC8gNi4wO1xcblxcdFxcdFxcdCNlbmRpZlxcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0I2lmIGRlZmluZWQgY2xpcF9oaWdobGlnaHRfaW5zaWRlXFxuXFx0XFx0XFx0XFx0dkNvbG9yLnJnYiArPSBoaWdobGlnaHRDb2xvcjsgXFxuXFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcbn1cXG5cIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///245\n')},238:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  BlurMaterial: () => (/* reexport */ BlurMaterial),\n  ClipMode: () => (/* reexport */ ClipMode),\n  GRAYSCALE: () => (/* reexport */ GRAYSCALE),\n  INFERNO: () => (/* reexport */ INFERNO),\n  NormalFilteringMode: () => (/* reexport */ NormalFilteringMode),\n  PLASMA: () => (/* reexport */ PLASMA),\n  POINT_ATTRIBUTES: () => (/* reexport */ POINT_ATTRIBUTES),\n  POINT_ATTRIBUTE_TYPES: () => (/* reexport */ POINT_ATTRIBUTE_TYPES),\n  PointAttributeName: () => (/* reexport */ PointAttributeName),\n  PointAttributes: () => (/* reexport */ PointAttributes),\n  PointCloudMaterial: () => (/* reexport */ PointCloudMaterial),\n  PointCloudMixingMode: () => (/* reexport */ PointCloudMixingMode),\n  PointCloudOctree: () => (/* reexport */ PointCloudOctree),\n  PointCloudOctreeGeometry: () => (/* reexport */ PointCloudOctreeGeometry),\n  PointCloudOctreeGeometryNode: () => (/* reexport */ PointCloudOctreeGeometryNode),\n  PointCloudOctreeNode: () => (/* reexport */ PointCloudOctreeNode),\n  PointCloudOctreePicker: () => (/* reexport */ PointCloudOctreePicker),\n  PointCloudTree: () => (/* reexport */ PointCloudTree),\n  PointColorType: () => (/* reexport */ PointColorType),\n  PointOpacityType: () => (/* reexport */ PointOpacityType),\n  PointShape: () => (/* reexport */ PointShape),\n  PointSizeType: () => (/* reexport */ PointSizeType),\n  Potree: () => (/* reexport */ Potree),\n  QueueItem: () => (/* reexport */ QueueItem),\n  RAINBOW: () => (/* reexport */ RAINBOW),\n  SPECTRAL: () => (/* reexport */ SPECTRAL),\n  TreeType: () => (/* reexport */ TreeType),\n  V1_LOADER: () => (/* reexport */ loadPOC),\n  V2_LOADER: () => (/* reexport */ loadOctree),\n  VIRIDIS: () => (/* reexport */ VIRIDIS),\n  Version: () => (/* reexport */ Version),\n  YELLOW_GREEN: () => (/* reexport */ YELLOW_GREEN),\n  generateClassificationTexture: () => (/* reexport */ generateClassificationTexture),\n  generateDataTexture: () => (/* reexport */ generateDataTexture),\n  generateGradientTexture: () => (/* reexport */ generateGradientTexture)\n});\n\n// EXTERNAL MODULE: external \"three\"\nvar external_three_ = __webpack_require__(604);\n;// CONCATENATED MODULE: ./src/materials/blur-material.ts\n\r\nclass BlurMaterial extends external_three_.ShaderMaterial {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.vertexShader = __webpack_require__(575);\r\n        this.fragmentShader = __webpack_require__(414);\r\n        this.uniforms = {\r\n            screenWidth: { type: 'f', value: 0 },\r\n            screenHeight: { type: 'f', value: 0 },\r\n            map: { type: 't', value: null },\r\n        };\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/materials/clipping.ts\nvar ClipMode;\r\n(function (ClipMode) {\r\n    ClipMode[ClipMode[\"DISABLED\"] = 0] = \"DISABLED\";\r\n    ClipMode[ClipMode[\"CLIP_OUTSIDE\"] = 1] = \"CLIP_OUTSIDE\";\r\n    ClipMode[ClipMode[\"HIGHLIGHT_INSIDE\"] = 2] = \"HIGHLIGHT_INSIDE\";\r\n    ClipMode[ClipMode[\"CLIP_HORIZONTALLY\"] = 3] = \"CLIP_HORIZONTALLY\";\r\n    ClipMode[ClipMode[\"CLIP_VERTICALLY\"] = 4] = \"CLIP_VERTICALLY\";\r\n})(ClipMode || (ClipMode = {}));\r\n\n;// CONCATENATED MODULE: ./src/materials/enums.ts\nvar PointSizeType;\r\n(function (PointSizeType) {\r\n    PointSizeType[PointSizeType[\"FIXED\"] = 0] = \"FIXED\";\r\n    PointSizeType[PointSizeType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\r\n    PointSizeType[PointSizeType[\"ADAPTIVE\"] = 2] = \"ADAPTIVE\";\r\n})(PointSizeType || (PointSizeType = {}));\r\nvar PointShape;\r\n(function (PointShape) {\r\n    PointShape[PointShape[\"SQUARE\"] = 0] = \"SQUARE\";\r\n    PointShape[PointShape[\"CIRCLE\"] = 1] = \"CIRCLE\";\r\n    PointShape[PointShape[\"PARABOLOID\"] = 2] = \"PARABOLOID\";\r\n})(PointShape || (PointShape = {}));\r\nvar TreeType;\r\n(function (TreeType) {\r\n    TreeType[TreeType[\"OCTREE\"] = 0] = \"OCTREE\";\r\n    TreeType[TreeType[\"KDTREE\"] = 1] = \"KDTREE\";\r\n})(TreeType || (TreeType = {}));\r\nvar PointOpacityType;\r\n(function (PointOpacityType) {\r\n    PointOpacityType[PointOpacityType[\"FIXED\"] = 0] = \"FIXED\";\r\n    PointOpacityType[PointOpacityType[\"ATTENUATED\"] = 1] = \"ATTENUATED\";\r\n})(PointOpacityType || (PointOpacityType = {}));\r\nvar PointColorType;\r\n(function (PointColorType) {\r\n    PointColorType[PointColorType[\"RGB\"] = 0] = \"RGB\";\r\n    PointColorType[PointColorType[\"COLOR\"] = 1] = \"COLOR\";\r\n    PointColorType[PointColorType[\"DEPTH\"] = 2] = \"DEPTH\";\r\n    PointColorType[PointColorType[\"HEIGHT\"] = 3] = \"HEIGHT\";\r\n    PointColorType[PointColorType[\"ELEVATION\"] = 3] = \"ELEVATION\";\r\n    PointColorType[PointColorType[\"INTENSITY\"] = 4] = \"INTENSITY\";\r\n    PointColorType[PointColorType[\"INTENSITY_GRADIENT\"] = 5] = \"INTENSITY_GRADIENT\";\r\n    PointColorType[PointColorType[\"LOD\"] = 6] = \"LOD\";\r\n    PointColorType[PointColorType[\"LEVEL_OF_DETAIL\"] = 6] = \"LEVEL_OF_DETAIL\";\r\n    PointColorType[PointColorType[\"POINT_INDEX\"] = 7] = \"POINT_INDEX\";\r\n    PointColorType[PointColorType[\"CLASSIFICATION\"] = 8] = \"CLASSIFICATION\";\r\n    PointColorType[PointColorType[\"RETURN_NUMBER\"] = 9] = \"RETURN_NUMBER\";\r\n    PointColorType[PointColorType[\"SOURCE\"] = 10] = \"SOURCE\";\r\n    PointColorType[PointColorType[\"NORMAL\"] = 11] = \"NORMAL\";\r\n    PointColorType[PointColorType[\"PHONG\"] = 12] = \"PHONG\";\r\n    PointColorType[PointColorType[\"RGB_HEIGHT\"] = 13] = \"RGB_HEIGHT\";\r\n    PointColorType[PointColorType[\"COMPOSITE\"] = 50] = \"COMPOSITE\";\r\n})(PointColorType || (PointColorType = {}));\r\nvar NormalFilteringMode;\r\n(function (NormalFilteringMode) {\r\n    NormalFilteringMode[NormalFilteringMode[\"ABSOLUTE_NORMAL_FILTERING_MODE\"] = 1] = \"ABSOLUTE_NORMAL_FILTERING_MODE\";\r\n    NormalFilteringMode[NormalFilteringMode[\"LESS_EQUAL_NORMAL_FILTERING_MODE\"] = 2] = \"LESS_EQUAL_NORMAL_FILTERING_MODE\";\r\n    NormalFilteringMode[NormalFilteringMode[\"GREATER_NORMAL_FILTERING_MODE\"] = 3] = \"GREATER_NORMAL_FILTERING_MODE\";\r\n})(NormalFilteringMode || (NormalFilteringMode = {}));\r\nvar PointCloudMixingMode;\r\n(function (PointCloudMixingMode) {\r\n    PointCloudMixingMode[PointCloudMixingMode[\"CHECKBOARD\"] = 1] = \"CHECKBOARD\";\r\n    PointCloudMixingMode[PointCloudMixingMode[\"STRIPES\"] = 2] = \"STRIPES\";\r\n})(PointCloudMixingMode || (PointCloudMixingMode = {}));\r\n\n;// CONCATENATED MODULE: ./src/constants.ts\n\r\nconst DEFAULT_RGB_BRIGHTNESS = 0;\r\nconst DEFAULT_RGB_CONTRAST = 0;\r\nconst DEFAULT_RGB_GAMMA = 1;\r\nconst DEFAULT_MAX_POINT_SIZE = 50;\r\nconst DEFAULT_MIN_NODE_PIXEL_SIZE = 50;\r\nconst DEFAULT_MIN_POINT_SIZE = 2;\r\nconst DEFAULT_PICK_WINDOW_SIZE = 15;\r\nconst DEFAULT_POINT_BUDGET = 1000000;\r\nconst MAX_LOADS_TO_GPU = 2;\r\nconst MAX_NUM_NODES_LOADING = 4;\r\nconst PERSPECTIVE_CAMERA = 'PerspectiveCamera';\r\nconst COLOR_BLACK = new external_three_.Color(0, 0, 0);\r\nconst DEFAULT_HIGHLIGHT_COLOR = new external_three_.Vector4(1, 0, 0, 1);\r\n\n;// CONCATENATED MODULE: ./src/utils/utils.ts\nfunction getIndexFromName(name) {\r\n    return parseInt(name.charAt(name.length - 1), 10);\r\n}\r\n/**\r\n * When passed to `[].sort`, sorts the array by level and index: r, r0, r3, r4, r01, r07, r30, ...\r\n */\r\nfunction byLevelAndIndex(a, b) {\r\n    const na = a.name;\r\n    const nb = b.name;\r\n    if (na.length !== nb.length) {\r\n        return na.length - nb.length;\r\n    }\r\n    else if (na < nb) {\r\n        return -1;\r\n    }\r\n    else if (na > nb) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\nfunction handleFailedRequest(response) {\r\n    if (response.status !== 200) {\r\n        throw Error('Response error');\r\n    }\r\n    return response;\r\n}\r\nfunction handleEmptyBuffer(buffer) {\r\n    if (!buffer || buffer.byteLength === 0) {\r\n        throw Error('Empty buffer');\r\n    }\r\n    return buffer;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/materials/classification.ts\n\r\nconst DEFAULT_CLASSIFICATION = {\r\n    0: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\r\n    1: new external_three_.Vector4(0.5, 0.5, 0.5, 1.0),\r\n    2: new external_three_.Vector4(0.63, 0.32, 0.18, 1.0),\r\n    3: new external_three_.Vector4(0.0, 1.0, 0.0, 1.0),\r\n    4: new external_three_.Vector4(0.0, 0.8, 0.0, 1.0),\r\n    5: new external_three_.Vector4(0.0, 0.6, 0.0, 1.0),\r\n    6: new external_three_.Vector4(1.0, 0.66, 0.0, 1.0),\r\n    7: new external_three_.Vector4(1.0, 0, 1.0, 1.0),\r\n    8: new external_three_.Vector4(1.0, 0, 0.0, 1.0),\r\n    9: new external_three_.Vector4(0.0, 0.0, 1.0, 1.0),\r\n    12: new external_three_.Vector4(1.0, 1.0, 0.0, 1.0),\r\n    DEFAULT: new external_three_.Vector4(0.3, 0.6, 0.6, 0.5),\r\n};\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/grayscale.ts\n\r\nconst GRAYSCALE = [\r\n    [0, new external_three_.Color(0, 0, 0)],\r\n    [1, new external_three_.Color(1, 1, 1)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/inferno.ts\n\r\nconst INFERNO = [\r\n    [0.0, new external_three_.Color(0.077, 0.042, 0.206)],\r\n    [0.1, new external_three_.Color(0.225, 0.036, 0.388)],\r\n    [0.2, new external_three_.Color(0.373, 0.074, 0.432)],\r\n    [0.3, new external_three_.Color(0.522, 0.128, 0.42)],\r\n    [0.4, new external_three_.Color(0.665, 0.182, 0.37)],\r\n    [0.5, new external_three_.Color(0.797, 0.255, 0.287)],\r\n    [0.6, new external_three_.Color(0.902, 0.364, 0.184)],\r\n    [0.7, new external_three_.Color(0.969, 0.516, 0.063)],\r\n    [0.8, new external_three_.Color(0.988, 0.683, 0.072)],\r\n    [0.9, new external_three_.Color(0.961, 0.859, 0.298)],\r\n    [1.0, new external_three_.Color(0.988, 0.998, 0.645)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/plasma.ts\n\r\nconst PLASMA = [\r\n    [0.0, new external_three_.Color(0.241, 0.015, 0.61)],\r\n    [0.1, new external_three_.Color(0.387, 0.001, 0.654)],\r\n    [0.2, new external_three_.Color(0.524, 0.025, 0.653)],\r\n    [0.3, new external_three_.Color(0.651, 0.125, 0.596)],\r\n    [0.4, new external_three_.Color(0.752, 0.227, 0.513)],\r\n    [0.5, new external_three_.Color(0.837, 0.329, 0.431)],\r\n    [0.6, new external_three_.Color(0.907, 0.435, 0.353)],\r\n    [0.7, new external_three_.Color(0.963, 0.554, 0.272)],\r\n    [0.8, new external_three_.Color(0.992, 0.681, 0.195)],\r\n    [0.9, new external_three_.Color(0.987, 0.822, 0.144)],\r\n    [1.0, new external_three_.Color(0.94, 0.975, 0.131)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/rainbow.ts\n\r\nconst RAINBOW = [\r\n    [0, new external_three_.Color(0.278, 0, 0.714)],\r\n    [1 / 6, new external_three_.Color(0, 0, 1)],\r\n    [2 / 6, new external_three_.Color(0, 1, 1)],\r\n    [3 / 6, new external_three_.Color(0, 1, 0)],\r\n    [4 / 6, new external_three_.Color(1, 1, 0)],\r\n    [5 / 6, new external_three_.Color(1, 0.64, 0)],\r\n    [1, new external_three_.Color(1, 0, 0)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/spectral.ts\n\r\n// From chroma spectral http://gka.github.io/chroma.js/\r\nconst SPECTRAL = [\r\n    [0, new external_three_.Color(0.3686, 0.3098, 0.6353)],\r\n    [0.1, new external_three_.Color(0.1961, 0.5333, 0.7412)],\r\n    [0.2, new external_three_.Color(0.4, 0.7608, 0.6471)],\r\n    [0.3, new external_three_.Color(0.6706, 0.8667, 0.6431)],\r\n    [0.4, new external_three_.Color(0.902, 0.9608, 0.5961)],\r\n    [0.5, new external_three_.Color(1.0, 1.0, 0.749)],\r\n    [0.6, new external_three_.Color(0.9961, 0.8784, 0.5451)],\r\n    [0.7, new external_three_.Color(0.9922, 0.6824, 0.3804)],\r\n    [0.8, new external_three_.Color(0.9569, 0.4275, 0.2627)],\r\n    [0.9, new external_three_.Color(0.8353, 0.2431, 0.3098)],\r\n    [1, new external_three_.Color(0.6196, 0.0039, 0.2588)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/vidris.ts\n\r\nconst VIRIDIS = [\r\n    [0.0, new external_three_.Color(0.267, 0.005, 0.329)],\r\n    [0.1, new external_three_.Color(0.283, 0.141, 0.458)],\r\n    [0.2, new external_three_.Color(0.254, 0.265, 0.53)],\r\n    [0.3, new external_three_.Color(0.207, 0.372, 0.553)],\r\n    [0.4, new external_three_.Color(0.164, 0.471, 0.558)],\r\n    [0.5, new external_three_.Color(0.128, 0.567, 0.551)],\r\n    [0.6, new external_three_.Color(0.135, 0.659, 0.518)],\r\n    [0.7, new external_three_.Color(0.267, 0.749, 0.441)],\r\n    [0.8, new external_three_.Color(0.478, 0.821, 0.318)],\r\n    [0.9, new external_three_.Color(0.741, 0.873, 0.15)],\r\n    [1.0, new external_three_.Color(0.993, 0.906, 0.144)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/yellow-green.ts\n\r\nconst YELLOW_GREEN = [\r\n    [0, new external_three_.Color(0.1647, 0.2824, 0.3451)],\r\n    [0.1, new external_three_.Color(0.1338, 0.3555, 0.4227)],\r\n    [0.2, new external_three_.Color(0.061, 0.4319, 0.4864)],\r\n    [0.3, new external_three_.Color(0.0, 0.5099, 0.5319)],\r\n    [0.4, new external_three_.Color(0.0, 0.5881, 0.5569)],\r\n    [0.5, new external_three_.Color(0.137, 0.665, 0.5614)],\r\n    [0.6, new external_three_.Color(0.2906, 0.7395, 0.5477)],\r\n    [0.7, new external_three_.Color(0.4453, 0.8099, 0.5201)],\r\n    [0.8, new external_three_.Color(0.6102, 0.8748, 0.485)],\r\n    [0.9, new external_three_.Color(0.7883, 0.9323, 0.4514)],\r\n    [1, new external_three_.Color(0.9804, 0.9804, 0.4314)],\r\n];\r\n\n;// CONCATENATED MODULE: ./src/materials/gradients/index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./src/materials/texture-generation.ts\n\r\nfunction generateDataTexture(width, height, color) {\r\n    const size = width * height;\r\n    const data = new Uint8Array(4 * size);\r\n    const r = Math.floor(color.r * 255);\r\n    const g = Math.floor(color.g * 255);\r\n    const b = Math.floor(color.b * 255);\r\n    for (let i = 0; i < size; i++) {\r\n        data[i * 3] = r;\r\n        data[i * 3 + 1] = g;\r\n        data[i * 3 + 2] = b;\r\n    }\r\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\r\n    texture.needsUpdate = true;\r\n    texture.magFilter = external_three_.NearestFilter;\r\n    return texture;\r\n}\r\nfunction generateGradientTexture(gradient) {\r\n    const size = 64;\r\n    const canvas = document.createElement('canvas');\r\n    canvas.width = size;\r\n    canvas.height = size;\r\n    const context = canvas.getContext('2d');\r\n    context.rect(0, 0, size, size);\r\n    const ctxGradient = context.createLinearGradient(0, 0, size, size);\r\n    for (let i = 0; i < gradient.length; i++) {\r\n        const step = gradient[i];\r\n        ctxGradient.addColorStop(step[0], `#${step[1].getHexString()}`);\r\n    }\r\n    context.fillStyle = ctxGradient;\r\n    context.fill();\r\n    const texture = new external_three_.CanvasTexture(canvas);\r\n    texture.needsUpdate = true;\r\n    texture.minFilter = external_three_.LinearFilter;\r\n    // textureImage = texture.image;\r\n    return texture;\r\n}\r\nfunction generateClassificationTexture(classification) {\r\n    const width = 256;\r\n    const height = 256;\r\n    const size = width * height;\r\n    const data = new Uint8Array(4 * size);\r\n    for (let x = 0; x < width; x++) {\r\n        for (let y = 0; y < height; y++) {\r\n            const i = x + width * y;\r\n            let color;\r\n            if (classification[x]) {\r\n                color = classification[x];\r\n            }\r\n            else if (classification[x % 32]) {\r\n                color = classification[x % 32];\r\n            }\r\n            else {\r\n                color = classification.DEFAULT;\r\n            }\r\n            data[4 * i + 0] = 255 * color.x;\r\n            data[4 * i + 1] = 255 * color.y;\r\n            data[4 * i + 2] = 255 * color.z;\r\n            data[4 * i + 3] = 255 * color.w;\r\n        }\r\n    }\r\n    const texture = new external_three_.DataTexture(data, width, height, external_three_.RGBAFormat);\r\n    texture.magFilter = external_three_.NearestFilter;\r\n    texture.needsUpdate = true;\r\n    return texture;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/materials/point-cloud-material.ts\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst TREE_TYPE_DEFS = {\r\n    [TreeType.OCTREE]: 'tree_type_octree',\r\n    [TreeType.KDTREE]: 'tree_type_kdtree',\r\n};\r\nconst SIZE_TYPE_DEFS = {\r\n    [PointSizeType.FIXED]: 'fixed_point_size',\r\n    [PointSizeType.ATTENUATED]: 'attenuated_point_size',\r\n    [PointSizeType.ADAPTIVE]: 'adaptive_point_size',\r\n};\r\nconst OPACITY_DEFS = {\r\n    [PointOpacityType.ATTENUATED]: 'attenuated_opacity',\r\n    [PointOpacityType.FIXED]: 'fixed_opacity',\r\n};\r\nconst SHAPE_DEFS = {\r\n    [PointShape.SQUARE]: 'square_point_shape',\r\n    [PointShape.CIRCLE]: 'circle_point_shape',\r\n    [PointShape.PARABOLOID]: 'paraboloid_point_shape',\r\n};\r\nconst COLOR_DEFS = {\r\n    [PointColorType.RGB]: 'color_type_rgb',\r\n    [PointColorType.COLOR]: 'color_type_color',\r\n    [PointColorType.DEPTH]: 'color_type_depth',\r\n    [PointColorType.HEIGHT]: 'color_type_height',\r\n    [PointColorType.INTENSITY]: 'color_type_intensity',\r\n    [PointColorType.INTENSITY_GRADIENT]: 'color_type_intensity_gradient',\r\n    [PointColorType.LOD]: 'color_type_lod',\r\n    [PointColorType.POINT_INDEX]: 'color_type_point_index',\r\n    [PointColorType.CLASSIFICATION]: 'color_type_classification',\r\n    [PointColorType.RETURN_NUMBER]: 'color_type_return_number',\r\n    [PointColorType.SOURCE]: 'color_type_source',\r\n    [PointColorType.NORMAL]: 'color_type_normal',\r\n    [PointColorType.PHONG]: 'color_type_phong',\r\n    [PointColorType.RGB_HEIGHT]: 'color_type_rgb_height',\r\n    [PointColorType.COMPOSITE]: 'color_type_composite',\r\n};\r\nconst CLIP_MODE_DEFS = {\r\n    [ClipMode.DISABLED]: 'clip_disabled',\r\n    [ClipMode.CLIP_OUTSIDE]: 'clip_outside',\r\n    [ClipMode.HIGHLIGHT_INSIDE]: 'clip_highlight_inside',\r\n    [ClipMode.CLIP_HORIZONTALLY]: 'clip_horizontally',\r\n    [ClipMode.CLIP_VERTICALLY]: 'clip_vertically',\r\n};\r\nclass PointCloudMaterial extends external_three_.RawShaderMaterial {\r\n    constructor(parameters = {}) {\r\n        super();\r\n        /**\r\n         * Use the drawing buffer size instead of the dom client width and height when passing the screen height and screen width uniforms to the\r\n         * shader. This is useful if you have offscreen canvases (which in some browsers return 0 as client width and client height).\r\n         */\r\n        this.useDrawingBufferSize = false;\r\n        this.lights = false;\r\n        this.fog = false;\r\n        this.colorRgba = false;\r\n        this.numClipBoxes = 0;\r\n        this.clipBoxes = [];\r\n        this.visibleNodeTextureOffsets = new Map();\r\n        this._gradient = SPECTRAL;\r\n        this.gradientTexture = generateGradientTexture(this._gradient);\r\n        this._classification = DEFAULT_CLASSIFICATION;\r\n        this.classificationTexture = generateClassificationTexture(this._classification);\r\n        this.uniforms = {\r\n            bbSize: makeUniform('fv', [0, 0, 0]),\r\n            blendDepthSupplement: makeUniform('f', 0.0),\r\n            blendHardness: makeUniform('f', 2.0),\r\n            classificationLUT: makeUniform('t', this.classificationTexture || new external_three_.Texture()),\r\n            clipBoxCount: makeUniform('f', 0),\r\n            clipBoxes: makeUniform('Matrix4fv', []),\r\n            clipHighlightColors: makeUniform('fv', new Float32Array()),\r\n            clipExtent: makeUniform('fv', [0.0, 0.0, 1.0, 1.0]),\r\n            depthMap: makeUniform('t', null),\r\n            diffuse: makeUniform('fv', [1, 1, 1]),\r\n            fov: makeUniform('f', 1.0),\r\n            gradient: makeUniform('t', this.gradientTexture || new external_three_.Texture()),\r\n            heightMax: makeUniform('f', 1.0),\r\n            heightMin: makeUniform('f', 0.0),\r\n            intensityBrightness: makeUniform('f', 0),\r\n            intensityContrast: makeUniform('f', 0),\r\n            intensityGamma: makeUniform('f', 1),\r\n            intensityRange: makeUniform('fv', [0, 65000]),\r\n            isLeafNode: makeUniform('b', 0),\r\n            level: makeUniform('f', 0.0),\r\n            maxSize: makeUniform('f', DEFAULT_MAX_POINT_SIZE),\r\n            minSize: makeUniform('f', DEFAULT_MIN_POINT_SIZE),\r\n            octreeSize: makeUniform('f', 0),\r\n            opacity: makeUniform('f', 1.0),\r\n            pcIndex: makeUniform('f', 0),\r\n            rgbBrightness: makeUniform('f', DEFAULT_RGB_BRIGHTNESS),\r\n            rgbContrast: makeUniform('f', DEFAULT_RGB_CONTRAST),\r\n            rgbGamma: makeUniform('f', DEFAULT_RGB_GAMMA),\r\n            screenHeight: makeUniform('f', 1.0),\r\n            screenWidth: makeUniform('f', 1.0),\r\n            size: makeUniform('f', 1),\r\n            spacing: makeUniform('f', 1.0),\r\n            toModel: makeUniform('Matrix4f', []),\r\n            transition: makeUniform('f', 0.5),\r\n            uColor: makeUniform('c', new external_three_.Color(0xffffff)),\r\n            // @ts-ignore\r\n            visibleNodes: makeUniform('t', this.visibleNodesTexture || new external_three_.Texture()),\r\n            vnStart: makeUniform('f', 0.0),\r\n            wClassification: makeUniform('f', 0),\r\n            wElevation: makeUniform('f', 0),\r\n            wIntensity: makeUniform('f', 0),\r\n            wReturnNumber: makeUniform('f', 0),\r\n            wRGB: makeUniform('f', 1),\r\n            wSourceID: makeUniform('f', 0),\r\n            opacityAttenuation: makeUniform('f', 1),\r\n            filterByNormalThreshold: makeUniform('f', 0),\r\n            highlightedPointCoordinate: makeUniform('fv', new external_three_.Vector3()),\r\n            highlightedPointColor: makeUniform('fv', DEFAULT_HIGHLIGHT_COLOR.clone()),\r\n            enablePointHighlighting: makeUniform('b', true),\r\n            highlightedPointScale: makeUniform('f', 2.0),\r\n            backgroundMap: makeUniform('t', null),\r\n            normalFilteringMode: makeUniform('i', NormalFilteringMode.ABSOLUTE_NORMAL_FILTERING_MODE),\r\n            pointCloudID: makeUniform('f', 2),\r\n            pointCloudMixingMode: makeUniform('i', PointCloudMixingMode.CHECKBOARD),\r\n            stripeDistanceX: makeUniform('f', 5),\r\n            stripeDistanceY: makeUniform('f', 5),\r\n            stripeDivisorX: makeUniform('f', 2),\r\n            stripeDivisorY: makeUniform('f', 2),\r\n            pointCloudMixAngle: makeUniform('f', 31),\r\n        };\r\n        this.useClipBox = false;\r\n        this.weighted = false;\r\n        this.pointColorType = PointColorType.RGB;\r\n        this.pointSizeType = PointSizeType.ADAPTIVE;\r\n        this.clipMode = ClipMode.DISABLED;\r\n        this.useEDL = false;\r\n        this.shape = PointShape.SQUARE;\r\n        this.treeType = TreeType.OCTREE;\r\n        this.pointOpacityType = PointOpacityType.FIXED;\r\n        this.useFilterByNormal = false;\r\n        this.useTextureBlending = false;\r\n        this.usePointCloudMixing = false;\r\n        this.highlightPoint = false;\r\n        this.attributes = {\r\n            position: { type: 'fv', value: [] },\r\n            color: { type: 'fv', value: [] },\r\n            normal: { type: 'fv', value: [] },\r\n            intensity: { type: 'f', value: [] },\r\n            classification: { type: 'f', value: [] },\r\n            returnNumber: { type: 'f', value: [] },\r\n            numberOfReturns: { type: 'f', value: [] },\r\n            pointSourceID: { type: 'f', value: [] },\r\n            indices: { type: 'fv', value: [] },\r\n        };\r\n        const tex = (this.visibleNodesTexture = generateDataTexture(2048, 1, new external_three_.Color(0xffffff)));\r\n        tex.minFilter = external_three_.NearestFilter;\r\n        tex.magFilter = external_three_.NearestFilter;\r\n        this.setUniform('visibleNodes', tex);\r\n        this.treeType = getValid(parameters.treeType, TreeType.OCTREE);\r\n        this.size = getValid(parameters.size, 1.0);\r\n        this.minSize = getValid(parameters.minSize, 2.0);\r\n        this.maxSize = getValid(parameters.maxSize, 50.0);\r\n        this.colorRgba = Boolean(parameters.colorRgba);\r\n        this.classification = DEFAULT_CLASSIFICATION;\r\n        this.defaultAttributeValues.normal = [0, 0, 0];\r\n        this.defaultAttributeValues.classification = [0, 0, 0];\r\n        this.defaultAttributeValues.indices = [0, 0, 0, 0];\r\n        this.vertexColors = true;\r\n        this.updateShaderSource();\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        if (this.gradientTexture) {\r\n            this.gradientTexture.dispose();\r\n            this.gradientTexture = undefined;\r\n        }\r\n        if (this.visibleNodesTexture) {\r\n            this.visibleNodesTexture.dispose();\r\n            this.visibleNodesTexture = undefined;\r\n        }\r\n        this.clearVisibleNodeTextureOffsets();\r\n        if (this.classificationTexture) {\r\n            this.classificationTexture.dispose();\r\n            this.classificationTexture = undefined;\r\n        }\r\n        if (this.depthMap) {\r\n            this.depthMap.dispose();\r\n            this.depthMap = undefined;\r\n        }\r\n        if (this.backgroundMap) {\r\n            this.backgroundMap.dispose();\r\n            this.backgroundMap = undefined;\r\n        }\r\n    }\r\n    clearVisibleNodeTextureOffsets() {\r\n        this.visibleNodeTextureOffsets.clear();\r\n    }\r\n    updateShaderSource() {\r\n        this.vertexShader = this.applyDefines((__webpack_require__(245)/* [\"default\"] */ .A));\r\n        this.fragmentShader = this.applyDefines((__webpack_require__(168)/* [\"default\"] */ .A));\r\n        if (this.opacity === 1.0) {\r\n            this.blending = external_three_.NoBlending;\r\n            this.transparent = false;\r\n            this.depthTest = true;\r\n            this.depthWrite = true;\r\n            this.depthFunc = external_three_.LessEqualDepth;\r\n        }\r\n        else if (this.opacity < 1.0 && !this.useEDL) {\r\n            this.blending = external_three_.AdditiveBlending;\r\n            this.transparent = true;\r\n            this.depthTest = false;\r\n            this.depthWrite = true;\r\n        }\r\n        if (this.weighted) {\r\n            this.blending = external_three_.AdditiveBlending;\r\n            this.transparent = true;\r\n            this.depthTest = true;\r\n            this.depthWrite = false;\r\n            this.depthFunc = external_three_.LessEqualDepth;\r\n        }\r\n        this.needsUpdate = true;\r\n    }\r\n    applyDefines(shaderSrc) {\r\n        const parts = [];\r\n        function define(value) {\r\n            if (value) {\r\n                parts.push(`#define ${value}`);\r\n            }\r\n        }\r\n        define(TREE_TYPE_DEFS[this.treeType]);\r\n        define(SIZE_TYPE_DEFS[this.pointSizeType]);\r\n        define(SHAPE_DEFS[this.shape]);\r\n        define(COLOR_DEFS[this.pointColorType]);\r\n        define(CLIP_MODE_DEFS[this.clipMode]);\r\n        define(OPACITY_DEFS[this.pointOpacityType]);\r\n        // We only perform gamma and brightness/contrast calculations per point if values are specified.\r\n        if (this.rgbGamma !== DEFAULT_RGB_GAMMA ||\r\n            this.rgbBrightness !== DEFAULT_RGB_BRIGHTNESS ||\r\n            this.rgbContrast !== DEFAULT_RGB_CONTRAST) {\r\n            define('use_rgb_gamma_contrast_brightness');\r\n        }\r\n        if (this.useFilterByNormal) {\r\n            define('use_filter_by_normal');\r\n        }\r\n        if (this.useEDL) {\r\n            define('use_edl');\r\n        }\r\n        if (this.weighted) {\r\n            define('weighted_splats');\r\n        }\r\n        if (this.numClipBoxes > 0) {\r\n            define('use_clip_box');\r\n        }\r\n        if (this.highlightPoint) {\r\n            define('highlight_point');\r\n        }\r\n        if (this.useTextureBlending) {\r\n            define('use_texture_blending');\r\n        }\r\n        if (this.usePointCloudMixing) {\r\n            define('use_point_cloud_mixing');\r\n        }\r\n        if (this.colorRgba) {\r\n            define('color_rgba');\r\n        }\r\n        define('MAX_POINT_LIGHTS 0');\r\n        define('MAX_DIR_LIGHTS 0');\r\n        parts.push(shaderSrc);\r\n        return parts.join('\\n');\r\n    }\r\n    setPointCloudMixingMode(mode) {\r\n        this.pointCloudMixingMode = mode;\r\n    }\r\n    getPointCloudMixingMode() {\r\n        if (this.pointCloudMixingMode === PointCloudMixingMode.STRIPES) {\r\n            return PointCloudMixingMode.STRIPES;\r\n        }\r\n        return PointCloudMixingMode.CHECKBOARD;\r\n    }\r\n    setClipBoxes(clipBoxes) {\r\n        if (!clipBoxes) {\r\n            return;\r\n        }\r\n        this.clipBoxes = clipBoxes;\r\n        const doUpdate = this.numClipBoxes !== clipBoxes.length && (clipBoxes.length === 0 || this.numClipBoxes === 0);\r\n        this.numClipBoxes = clipBoxes.length;\r\n        this.setUniform('clipBoxCount', this.numClipBoxes);\r\n        if (doUpdate) {\r\n            this.updateShaderSource();\r\n        }\r\n        const clipBoxesLength = this.numClipBoxes * 16;\r\n        const clipBoxesArray = new Float32Array(clipBoxesLength);\r\n        const clipColorsLength = this.numClipBoxes * 3;\r\n        const clipColorsArray = new Float32Array(clipColorsLength);\r\n        for (let i = 0; i < this.numClipBoxes; i++) {\r\n            clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);\r\n            clipColorsArray.set((clipBoxes[i].color || this.color).toArray(), 3 * i);\r\n        }\r\n        for (let i = 0; i < clipBoxesLength; i++) {\r\n            if (isNaN(clipBoxesArray[i])) {\r\n                clipBoxesArray[i] = Infinity;\r\n            }\r\n        }\r\n        this.setUniform('clipBoxes', clipBoxesArray);\r\n        this.setUniform('clipHighlightColors', clipColorsArray);\r\n    }\r\n    get gradient() {\r\n        return this._gradient;\r\n    }\r\n    set gradient(value) {\r\n        if (this._gradient !== value) {\r\n            this._gradient = value;\r\n            this.gradientTexture = generateGradientTexture(this._gradient);\r\n            this.setUniform('gradient', this.gradientTexture);\r\n        }\r\n    }\r\n    get classification() {\r\n        return this._classification;\r\n    }\r\n    set classification(value) {\r\n        const copy = {};\r\n        for (const key of Object.keys(value)) {\r\n            copy[key] = value[key].clone();\r\n        }\r\n        let isEqual = false;\r\n        if (this._classification === undefined) {\r\n            isEqual = false;\r\n        }\r\n        else {\r\n            isEqual = Object.keys(copy).length === Object.keys(this._classification).length;\r\n            for (const key of Object.keys(copy)) {\r\n                isEqual = isEqual && this._classification[key] !== undefined;\r\n                isEqual = isEqual && copy[key].equals(this._classification[key]);\r\n            }\r\n        }\r\n        if (!isEqual) {\r\n            this._classification = copy;\r\n            this.recomputeClassification();\r\n        }\r\n    }\r\n    recomputeClassification() {\r\n        this.classificationTexture = generateClassificationTexture(this._classification);\r\n        this.setUniform('classificationLUT', this.classificationTexture);\r\n    }\r\n    get elevationRange() {\r\n        return [this.heightMin, this.heightMax];\r\n    }\r\n    set elevationRange(value) {\r\n        this.heightMin = value[0];\r\n        this.heightMax = value[1];\r\n    }\r\n    getUniform(name) {\r\n        return this.uniforms === undefined ? undefined : this.uniforms[name].value;\r\n    }\r\n    setUniform(name, value) {\r\n        if (this.uniforms === undefined) {\r\n            return;\r\n        }\r\n        const uObj = this.uniforms[name];\r\n        if (uObj.type === 'c') {\r\n            uObj.value.copy(value);\r\n        }\r\n        else if (value !== uObj.value) {\r\n            uObj.value = value;\r\n        }\r\n    }\r\n    updateMaterial(octree, visibleNodes, camera, renderer) {\r\n        const pixelRatio = renderer.getPixelRatio();\r\n        if (camera.type === PERSPECTIVE_CAMERA) {\r\n            this.fov = camera.fov * (Math.PI / 180);\r\n        }\r\n        else {\r\n            this.fov = Math.PI / 2; // will result in slope = 1 in the shader\r\n        }\r\n        const renderTarget = renderer.getRenderTarget();\r\n        if (renderTarget !== null) {\r\n            this.screenWidth = renderTarget.width;\r\n            this.screenHeight = renderTarget.height;\r\n        }\r\n        else {\r\n            this.screenWidth = renderer.domElement.clientWidth * pixelRatio;\r\n            this.screenHeight = renderer.domElement.clientHeight * pixelRatio;\r\n        }\r\n        if (this.useDrawingBufferSize) {\r\n            renderer.getDrawingBufferSize(PointCloudMaterial.helperVec2);\r\n            this.screenWidth = PointCloudMaterial.helperVec2.width;\r\n            this.screenHeight = PointCloudMaterial.helperVec2.height;\r\n        }\r\n        const maxScale = Math.max(octree.scale.x, octree.scale.y, octree.scale.z);\r\n        this.spacing = octree.pcoGeometry.spacing * maxScale;\r\n        this.octreeSize = octree.pcoGeometry.boundingBox.getSize(PointCloudMaterial.helperVec3).x;\r\n        if (this.pointSizeType === PointSizeType.ADAPTIVE ||\r\n            this.pointColorType === PointColorType.LOD) {\r\n            this.updateVisibilityTextureData(visibleNodes);\r\n        }\r\n    }\r\n    updateVisibilityTextureData(nodes) {\r\n        nodes.sort(byLevelAndIndex);\r\n        const data = new Uint8Array(nodes.length * 4);\r\n        const offsetsToChild = new Array(nodes.length).fill(Infinity);\r\n        this.visibleNodeTextureOffsets.clear();\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            this.visibleNodeTextureOffsets.set(node.name, i);\r\n            if (i > 0) {\r\n                const parentName = node.name.slice(0, -1);\r\n                const parentOffset = this.visibleNodeTextureOffsets.get(parentName);\r\n                const parentOffsetToChild = i - parentOffset;\r\n                offsetsToChild[parentOffset] = Math.min(offsetsToChild[parentOffset], parentOffsetToChild);\r\n                // tslint:disable:no-bitwise\r\n                const offset = parentOffset * 4;\r\n                data[offset] = data[offset] | (1 << node.index);\r\n                data[offset + 1] = offsetsToChild[parentOffset] >> 8;\r\n                data[offset + 2] = offsetsToChild[parentOffset] % 256;\r\n                // tslint:enable:no-bitwise\r\n            }\r\n            data[i * 4 + 3] = node.name.length;\r\n        }\r\n        const texture = this.visibleNodesTexture;\r\n        if (texture) {\r\n            texture.image.data.set(data);\r\n            texture.needsUpdate = true;\r\n        }\r\n    }\r\n    static makeOnBeforeRender(octree, node, pcIndex) {\r\n        return (_renderer, _scene, _camera, _geometry, material) => {\r\n            const pointCloudMaterial = material;\r\n            const materialUniforms = pointCloudMaterial.uniforms;\r\n            materialUniforms.level.value = node.level;\r\n            materialUniforms.isLeafNode.value = node.isLeafNode;\r\n            const vnStart = pointCloudMaterial.visibleNodeTextureOffsets.get(node.name);\r\n            if (vnStart !== undefined) {\r\n                materialUniforms.vnStart.value = vnStart;\r\n            }\r\n            materialUniforms.pcIndex.value =\r\n                pcIndex !== undefined ? pcIndex : octree.visibleNodes.indexOf(node);\r\n            // Note: when changing uniforms in onBeforeRender, the flag uniformsNeedUpdate has to be\r\n            // set to true to instruct ThreeJS to upload them. See also\r\n            // https://github.com/mrdoob/three.js/issues/9870#issuecomment-368750182.\r\n            // Remove the cast to any after updating to Three.JS >= r113\r\n            material /*ShaderMaterial*/.uniformsNeedUpdate = true;\r\n        };\r\n    }\r\n}\r\nPointCloudMaterial.helperVec3 = new external_three_.Vector3();\r\nPointCloudMaterial.helperVec2 = new external_three_.Vector2();\r\n__decorate([\r\n    uniform('bbSize')\r\n], PointCloudMaterial.prototype, \"bbSize\", void 0);\r\n__decorate([\r\n    uniform('clipExtent')\r\n], PointCloudMaterial.prototype, \"clipExtent\", void 0);\r\n__decorate([\r\n    uniform('depthMap')\r\n], PointCloudMaterial.prototype, \"depthMap\", void 0);\r\n__decorate([\r\n    uniform('fov')\r\n], PointCloudMaterial.prototype, \"fov\", void 0);\r\n__decorate([\r\n    uniform('heightMax')\r\n], PointCloudMaterial.prototype, \"heightMax\", void 0);\r\n__decorate([\r\n    uniform('heightMin')\r\n], PointCloudMaterial.prototype, \"heightMin\", void 0);\r\n__decorate([\r\n    uniform('intensityBrightness')\r\n], PointCloudMaterial.prototype, \"intensityBrightness\", void 0);\r\n__decorate([\r\n    uniform('intensityContrast')\r\n], PointCloudMaterial.prototype, \"intensityContrast\", void 0);\r\n__decorate([\r\n    uniform('intensityGamma')\r\n], PointCloudMaterial.prototype, \"intensityGamma\", void 0);\r\n__decorate([\r\n    uniform('intensityRange')\r\n], PointCloudMaterial.prototype, \"intensityRange\", void 0);\r\n__decorate([\r\n    uniform('maxSize')\r\n], PointCloudMaterial.prototype, \"maxSize\", void 0);\r\n__decorate([\r\n    uniform('minSize')\r\n], PointCloudMaterial.prototype, \"minSize\", void 0);\r\n__decorate([\r\n    uniform('octreeSize')\r\n], PointCloudMaterial.prototype, \"octreeSize\", void 0);\r\n__decorate([\r\n    uniform('opacity', true)\r\n], PointCloudMaterial.prototype, \"opacity\", void 0);\r\n__decorate([\r\n    uniform('rgbBrightness', true)\r\n], PointCloudMaterial.prototype, \"rgbBrightness\", void 0);\r\n__decorate([\r\n    uniform('rgbContrast', true)\r\n], PointCloudMaterial.prototype, \"rgbContrast\", void 0);\r\n__decorate([\r\n    uniform('rgbGamma', true)\r\n], PointCloudMaterial.prototype, \"rgbGamma\", void 0);\r\n__decorate([\r\n    uniform('screenHeight')\r\n], PointCloudMaterial.prototype, \"screenHeight\", void 0);\r\n__decorate([\r\n    uniform('screenWidth')\r\n], PointCloudMaterial.prototype, \"screenWidth\", void 0);\r\n__decorate([\r\n    uniform('size')\r\n], PointCloudMaterial.prototype, \"size\", void 0);\r\n__decorate([\r\n    uniform('spacing')\r\n], PointCloudMaterial.prototype, \"spacing\", void 0);\r\n__decorate([\r\n    uniform('transition')\r\n], PointCloudMaterial.prototype, \"transition\", void 0);\r\n__decorate([\r\n    uniform('uColor')\r\n], PointCloudMaterial.prototype, \"color\", void 0);\r\n__decorate([\r\n    uniform('wClassification')\r\n], PointCloudMaterial.prototype, \"weightClassification\", void 0);\r\n__decorate([\r\n    uniform('wElevation')\r\n], PointCloudMaterial.prototype, \"weightElevation\", void 0);\r\n__decorate([\r\n    uniform('wIntensity')\r\n], PointCloudMaterial.prototype, \"weightIntensity\", void 0);\r\n__decorate([\r\n    uniform('wReturnNumber')\r\n], PointCloudMaterial.prototype, \"weightReturnNumber\", void 0);\r\n__decorate([\r\n    uniform('wRGB')\r\n], PointCloudMaterial.prototype, \"weightRGB\", void 0);\r\n__decorate([\r\n    uniform('wSourceID')\r\n], PointCloudMaterial.prototype, \"weightSourceID\", void 0);\r\n__decorate([\r\n    uniform('opacityAttenuation')\r\n], PointCloudMaterial.prototype, \"opacityAttenuation\", void 0);\r\n__decorate([\r\n    uniform('filterByNormalThreshold')\r\n], PointCloudMaterial.prototype, \"filterByNormalThreshold\", void 0);\r\n__decorate([\r\n    uniform('highlightedPointCoordinate')\r\n], PointCloudMaterial.prototype, \"highlightedPointCoordinate\", void 0);\r\n__decorate([\r\n    uniform('highlightedPointColor')\r\n], PointCloudMaterial.prototype, \"highlightedPointColor\", void 0);\r\n__decorate([\r\n    uniform('enablePointHighlighting')\r\n], PointCloudMaterial.prototype, \"enablePointHighlighting\", void 0);\r\n__decorate([\r\n    uniform('highlightedPointScale')\r\n], PointCloudMaterial.prototype, \"highlightedPointScale\", void 0);\r\n__decorate([\r\n    uniform('normalFilteringMode')\r\n], PointCloudMaterial.prototype, \"normalFilteringMode\", void 0);\r\n__decorate([\r\n    uniform('backgroundMap')\r\n], PointCloudMaterial.prototype, \"backgroundMap\", void 0);\r\n__decorate([\r\n    uniform('pointCloudID')\r\n], PointCloudMaterial.prototype, \"pointCloudID\", void 0);\r\n__decorate([\r\n    uniform('pointCloudMixingMode')\r\n], PointCloudMaterial.prototype, \"pointCloudMixingMode\", void 0);\r\n__decorate([\r\n    uniform('stripeDistanceX')\r\n], PointCloudMaterial.prototype, \"stripeDistanceX\", void 0);\r\n__decorate([\r\n    uniform('stripeDistanceY')\r\n], PointCloudMaterial.prototype, \"stripeDistanceY\", void 0);\r\n__decorate([\r\n    uniform('stripeDivisorX')\r\n], PointCloudMaterial.prototype, \"stripeDivisorX\", void 0);\r\n__decorate([\r\n    uniform('stripeDivisorY')\r\n], PointCloudMaterial.prototype, \"stripeDivisorY\", void 0);\r\n__decorate([\r\n    uniform('pointCloudMixAngle')\r\n], PointCloudMaterial.prototype, \"pointCloudMixAngle\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"useClipBox\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"weighted\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"pointColorType\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"pointSizeType\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"clipMode\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"useEDL\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"shape\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"treeType\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"pointOpacityType\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"useFilterByNormal\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"useTextureBlending\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"usePointCloudMixing\", void 0);\r\n__decorate([\r\n    requiresShaderUpdate()\r\n], PointCloudMaterial.prototype, \"highlightPoint\", void 0);\r\nfunction makeUniform(type, value) {\r\n    return { type, value };\r\n}\r\nfunction getValid(a, b) {\r\n    return a === undefined ? b : a;\r\n}\r\n// tslint:disable:no-invalid-this\r\nfunction uniform(uniformName, requireSrcUpdate = false) {\r\n    return (target, propertyKey) => {\r\n        Object.defineProperty(target, propertyKey, {\r\n            get() {\r\n                return this.getUniform(uniformName);\r\n            },\r\n            set(value) {\r\n                if (value !== this.getUniform(uniformName)) {\r\n                    this.setUniform(uniformName, value);\r\n                    if (requireSrcUpdate) {\r\n                        this.updateShaderSource();\r\n                    }\r\n                }\r\n            },\r\n        });\r\n    };\r\n}\r\nfunction requiresShaderUpdate() {\r\n    return (target, propertyKey) => {\r\n        const fieldName = `_${propertyKey.toString()}`;\r\n        Object.defineProperty(target, propertyKey, {\r\n            get() {\r\n                return this[fieldName];\r\n            },\r\n            set(value) {\r\n                if (value !== this[fieldName]) {\r\n                    this[fieldName] = value;\r\n                    this.updateShaderSource();\r\n                }\r\n            },\r\n        });\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./src/materials/index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./src/point-attributes.ts\n// -------------------------------------------------------------------------------------------------\r\n// Converted to Typescript and adapted from https://github.com/potree/potree\r\n// -------------------------------------------------------------------------------------------------\r\nvar PointAttributeName;\r\n(function (PointAttributeName) {\r\n    PointAttributeName[PointAttributeName[\"POSITION_CARTESIAN\"] = 0] = \"POSITION_CARTESIAN\";\r\n    PointAttributeName[PointAttributeName[\"COLOR_PACKED\"] = 1] = \"COLOR_PACKED\";\r\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_1\"] = 2] = \"COLOR_FLOATS_1\";\r\n    PointAttributeName[PointAttributeName[\"COLOR_FLOATS_255\"] = 3] = \"COLOR_FLOATS_255\";\r\n    PointAttributeName[PointAttributeName[\"NORMAL_FLOATS\"] = 4] = \"NORMAL_FLOATS\";\r\n    PointAttributeName[PointAttributeName[\"FILLER\"] = 5] = \"FILLER\";\r\n    PointAttributeName[PointAttributeName[\"INTENSITY\"] = 6] = \"INTENSITY\";\r\n    PointAttributeName[PointAttributeName[\"CLASSIFICATION\"] = 7] = \"CLASSIFICATION\";\r\n    PointAttributeName[PointAttributeName[\"NORMAL_SPHEREMAPPED\"] = 8] = \"NORMAL_SPHEREMAPPED\";\r\n    PointAttributeName[PointAttributeName[\"NORMAL_OCT16\"] = 9] = \"NORMAL_OCT16\";\r\n    PointAttributeName[PointAttributeName[\"NORMAL\"] = 10] = \"NORMAL\";\r\n})(PointAttributeName || (PointAttributeName = {}));\r\nconst POINT_ATTRIBUTE_TYPES = {\r\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\r\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\r\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\r\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\r\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\r\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\r\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\r\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\r\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\r\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\r\n};\r\nfunction makePointAttribute(name, type, numElements) {\r\n    return {\r\n        name,\r\n        type,\r\n        numElements,\r\n        byteSize: numElements * type.size,\r\n    };\r\n}\r\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\r\nconst POINT_ATTRIBUTES = {\r\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\r\n    RGBA_PACKED,\r\n    COLOR_PACKED: RGBA_PACKED,\r\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\r\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\r\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\r\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\r\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\r\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\r\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\r\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\r\n};\r\nclass PointAttributes {\r\n    constructor(pointAttributeNames = []) {\r\n        this.attributes = [];\r\n        this.byteSize = 0;\r\n        this.size = 0;\r\n        for (let i = 0; i < pointAttributeNames.length; i++) {\r\n            const pointAttributeName = pointAttributeNames[i];\r\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\r\n            this.attributes.push(pointAttribute);\r\n            this.byteSize += pointAttribute.byteSize;\r\n            this.size++;\r\n        }\r\n    }\r\n    add(pointAttribute) {\r\n        this.attributes.push(pointAttribute);\r\n        this.byteSize += pointAttribute.byteSize;\r\n        this.size++;\r\n    }\r\n    hasColors() {\r\n        return this.attributes.find(isColorAttribute) !== undefined;\r\n    }\r\n    hasNormals() {\r\n        return this.attributes.find(isNormalAttribute) !== undefined;\r\n    }\r\n}\r\nfunction isColorAttribute({ name }) {\r\n    return name === PointAttributeName.COLOR_PACKED;\r\n}\r\nfunction isNormalAttribute({ name }) {\r\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\r\n        name === PointAttributeName.NORMAL_FLOATS ||\r\n        name === PointAttributeName.NORMAL ||\r\n        name === PointAttributeName.NORMAL_OCT16);\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/bounds.ts\n\r\n/**\r\n * adapted from mhluska at https://github.com/mrdoob/three.js/issues/1561\r\n */\r\nfunction computeTransformedBoundingBox(box, transform) {\r\n    return new external_three_.Box3().setFromPoints([\r\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.min.x, box.min.y, box.min.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.max.x, box.min.y, box.min.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.min.x, box.max.y, box.min.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.min.x, box.min.y, box.max.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.min.x, box.max.y, box.max.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.max.x, box.max.y, box.min.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.max.x, box.min.y, box.max.z).applyMatrix4(transform),\r\n        new external_three_.Vector3(box.max.x, box.max.y, box.max.z).applyMatrix4(transform),\r\n    ]);\r\n}\r\nfunction createChildAABB(aabb, index) {\r\n    const min = aabb.min.clone();\r\n    const max = aabb.max.clone();\r\n    const size = new external_three_.Vector3().subVectors(max, min);\r\n    // tslint:disable-next-line:no-bitwise\r\n    if ((index & 0b0001) > 0) {\r\n        min.z += size.z / 2;\r\n    }\r\n    else {\r\n        max.z -= size.z / 2;\r\n    }\r\n    // tslint:disable-next-line:no-bitwise\r\n    if ((index & 0b0010) > 0) {\r\n        min.y += size.y / 2;\r\n    }\r\n    else {\r\n        max.y -= size.y / 2;\r\n    }\r\n    // tslint:disable-next-line:no-bitwise\r\n    if ((index & 0b0100) > 0) {\r\n        min.x += size.x / 2;\r\n    }\r\n    else {\r\n        max.x -= size.x / 2;\r\n    }\r\n    return new external_three_.Box3(min, max);\r\n}\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry-node.ts\n/**\r\n * Adapted from Potree.js http://potree.org\r\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\r\n */\r\n\r\n\r\n\r\nconst NODE_STRIDE = 5;\r\nclass PointCloudOctreeGeometryNode extends external_three_.EventDispatcher {\r\n    constructor(name, pcoGeometry, boundingBox) {\r\n        super();\r\n        this.id = PointCloudOctreeGeometryNode.idCount++;\r\n        this.level = 0;\r\n        this.spacing = 0;\r\n        this.hasChildren = false;\r\n        this.children = [\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n        ];\r\n        this.mean = new external_three_.Vector3();\r\n        this.numPoints = 0;\r\n        this.loaded = false;\r\n        this.loading = false;\r\n        this.failed = false;\r\n        this.parent = null;\r\n        this.oneTimeDisposeHandlers = [];\r\n        this.isLeafNode = true;\r\n        this.isTreeNode = false;\r\n        this.isGeometryNode = true;\r\n        this.name = name;\r\n        this.index = getIndexFromName(name);\r\n        this.pcoGeometry = pcoGeometry;\r\n        this.boundingBox = boundingBox;\r\n        this.tightBoundingBox = boundingBox.clone();\r\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n    }\r\n    dispose() {\r\n        if (!this.geometry || !this.parent) {\r\n            return;\r\n        }\r\n        this.geometry.dispose();\r\n        this.geometry = undefined;\r\n        this.loaded = false;\r\n        this.oneTimeDisposeHandlers.forEach(handler => handler());\r\n        this.oneTimeDisposeHandlers = [];\r\n    }\r\n    /**\r\n     * Gets the url of the binary file for this node.\r\n     */\r\n    getUrl() {\r\n        const geometry = this.pcoGeometry;\r\n        const version = geometry.loader.version;\r\n        const pathParts = [geometry.octreeDir];\r\n        if (geometry.loader && version.equalOrHigher('1.5')) {\r\n            pathParts.push(this.getHierarchyBaseUrl());\r\n            pathParts.push(this.name);\r\n        }\r\n        else if (version.equalOrHigher('1.4')) {\r\n            pathParts.push(this.name);\r\n        }\r\n        else if (version.upTo('1.3')) {\r\n            pathParts.push(this.name);\r\n        }\r\n        return pathParts.join('/');\r\n    }\r\n    /**\r\n     * Gets the url of the hierarchy file for this node.\r\n     */\r\n    getHierarchyUrl() {\r\n        return `${this.pcoGeometry.octreeDir}/${this.getHierarchyBaseUrl()}/${this.name}.hrc`;\r\n    }\r\n    /**\r\n     * Adds the specified node as a child of the current node.\r\n     *\r\n     * @param child\r\n     *    The node which is to be added as a child.\r\n     */\r\n    addChild(child) {\r\n        this.children[child.index] = child;\r\n        this.isLeafNode = false;\r\n        child.parent = this;\r\n    }\r\n    /**\r\n     * Calls the specified callback for the current node (if includeSelf is set to true) and all its\r\n     * children.\r\n     *\r\n     * @param cb\r\n     *    The function which is to be called for each node.\r\n     */\r\n    traverse(cb, includeSelf = true) {\r\n        const stack = includeSelf ? [this] : [];\r\n        let current;\r\n        while ((current = stack.pop()) !== undefined) {\r\n            cb(current);\r\n            for (const child of current.children) {\r\n                if (child !== null) {\r\n                    stack.push(child);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    load() {\r\n        if (!this.canLoad()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.loading = true;\r\n        this.pcoGeometry.numNodesLoading++;\r\n        this.pcoGeometry.needsUpdate = true;\r\n        let promise;\r\n        if (this.pcoGeometry.loader.version.equalOrHigher('1.5') &&\r\n            this.level % this.pcoGeometry.hierarchyStepSize === 0 &&\r\n            this.hasChildren) {\r\n            promise = this.loadHierachyThenPoints();\r\n        }\r\n        else {\r\n            promise = this.loadPoints();\r\n        }\r\n        return promise.catch(reason => {\r\n            this.loading = false;\r\n            this.failed = true;\r\n            this.pcoGeometry.numNodesLoading--;\r\n            throw reason;\r\n        });\r\n    }\r\n    canLoad() {\r\n        return (!this.loading &&\r\n            !this.loaded &&\r\n            !this.pcoGeometry.disposed &&\r\n            !this.pcoGeometry.loader.disposed &&\r\n            this.pcoGeometry.numNodesLoading < this.pcoGeometry.maxNumNodesLoading);\r\n    }\r\n    loadPoints() {\r\n        this.pcoGeometry.needsUpdate = true;\r\n        return this.pcoGeometry.loader.load(this);\r\n    }\r\n    loadHierachyThenPoints() {\r\n        if (this.level % this.pcoGeometry.hierarchyStepSize !== 0) {\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.resolve(this.pcoGeometry.loader.getUrl(this.getHierarchyUrl()))\r\n            .then(url => this.pcoGeometry.xhrRequest(url, { mode: 'cors' }))\r\n            .then(res => handleFailedRequest(res))\r\n            .then(okRes => okRes.arrayBuffer())\r\n            .then(buffer => handleEmptyBuffer(buffer))\r\n            .then(okBuffer => this.loadHierarchy(this, okBuffer));\r\n    }\r\n    /**\r\n     * Gets the url of the folder where the hierarchy is, relative to the octreeDir.\r\n     */\r\n    getHierarchyBaseUrl() {\r\n        const hierarchyStepSize = this.pcoGeometry.hierarchyStepSize;\r\n        const indices = this.name.substr(1);\r\n        const numParts = Math.floor(indices.length / hierarchyStepSize);\r\n        let path = 'r/';\r\n        for (let i = 0; i < numParts; i++) {\r\n            path += `${indices.substr(i * hierarchyStepSize, hierarchyStepSize)}/`;\r\n        }\r\n        return path.slice(0, -1);\r\n    }\r\n    // tslint:disable:no-bitwise\r\n    loadHierarchy(node, buffer) {\r\n        const view = new DataView(buffer);\r\n        const firstNodeData = this.getNodeData(node.name, 0, view);\r\n        node.numPoints = firstNodeData.numPoints;\r\n        // Nodes which need be visited.\r\n        const stack = [firstNodeData];\r\n        // Nodes which have already been decoded. We will take nodes from the stack and place them here.\r\n        const decoded = [];\r\n        let offset = NODE_STRIDE;\r\n        while (stack.length > 0) {\r\n            const stackNodeData = stack.shift();\r\n            // From the last bit, all the way to the 8th one from the right.\r\n            let mask = 1;\r\n            for (let i = 0; i < 8 && offset + 1 < buffer.byteLength; i++) {\r\n                if ((stackNodeData.children & mask) !== 0) {\r\n                    const nodeData = this.getNodeData(stackNodeData.name + i, offset, view);\r\n                    decoded.push(nodeData); // Node is decoded.\r\n                    stack.push(nodeData); // Need to check its children.\r\n                    offset += NODE_STRIDE; // Move over to the next node in the buffer.\r\n                }\r\n                mask = mask * 2;\r\n            }\r\n        }\r\n        node.pcoGeometry.needsUpdate = true;\r\n        // Map containing all the nodes.\r\n        const nodes = new Map();\r\n        nodes.set(node.name, node);\r\n        decoded.forEach(nodeData => this.addNode(nodeData, node.pcoGeometry, nodes));\r\n        node.loadPoints();\r\n    }\r\n    // tslint:enable:no-bitwise\r\n    getNodeData(name, offset, view) {\r\n        const children = view.getUint8(offset);\r\n        const numPoints = view.getUint32(offset + 1, true);\r\n        return { children: children, numPoints: numPoints, name };\r\n    }\r\n    addNode({ name, numPoints, children }, pco, nodes) {\r\n        const index = getIndexFromName(name);\r\n        const parentName = name.substring(0, name.length - 1);\r\n        const parentNode = nodes.get(parentName);\r\n        const level = name.length - 1;\r\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\r\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\r\n        node.level = level;\r\n        node.numPoints = numPoints;\r\n        node.hasChildren = children > 0;\r\n        node.spacing = pco.spacing / Math.pow(2, level);\r\n        parentNode.addChild(node);\r\n        nodes.set(name, node);\r\n    }\r\n}\r\nPointCloudOctreeGeometryNode.idCount = 0;\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-geometry.ts\n\r\nclass PointCloudOctreeGeometry {\r\n    constructor(loader, boundingBox, tightBoundingBox, offset, xhrRequest) {\r\n        this.loader = loader;\r\n        this.boundingBox = boundingBox;\r\n        this.tightBoundingBox = tightBoundingBox;\r\n        this.offset = offset;\r\n        this.xhrRequest = xhrRequest;\r\n        this.disposed = false;\r\n        this.needsUpdate = true;\r\n        this.octreeDir = '';\r\n        this.hierarchyStepSize = -1;\r\n        this.nodes = {};\r\n        this.numNodesLoading = 0;\r\n        this.maxNumNodesLoading = 3;\r\n        this.spacing = 0;\r\n        this.pointAttributes = new PointAttributes([]);\r\n        this.projection = null;\r\n        this.url = null;\r\n    }\r\n    dispose() {\r\n        this.loader.dispose();\r\n        this.root.traverse(node => node.dispose());\r\n        this.disposed = true;\r\n    }\r\n    addNodeLoadedCallback(callback) {\r\n        this.loader.callbacks.push(callback);\r\n    }\r\n    clearNodeLoadedCallbacks() {\r\n        this.loader.callbacks = [];\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-node.ts\n\r\nclass PointCloudOctreeNode extends external_three_.EventDispatcher {\r\n    constructor(geometryNode, sceneNode) {\r\n        super();\r\n        this.pcIndex = undefined;\r\n        this.boundingBoxNode = null;\r\n        this.loaded = true;\r\n        this.isTreeNode = true;\r\n        this.isGeometryNode = false;\r\n        this.geometryNode = geometryNode;\r\n        this.sceneNode = sceneNode;\r\n        this.children = geometryNode.children.slice();\r\n    }\r\n    dispose() {\r\n        this.geometryNode.dispose();\r\n    }\r\n    disposeSceneNode() {\r\n        const node = this.sceneNode;\r\n        if (node.geometry instanceof external_three_.BufferGeometry) {\r\n            const attributes = node.geometry.attributes;\r\n            // tslint:disable-next-line:forin\r\n            for (const key in attributes) {\r\n                if (key === 'position') {\r\n                    delete attributes[key].array;\r\n                }\r\n                delete attributes[key];\r\n            }\r\n            node.geometry.dispose();\r\n            node.geometry = undefined;\r\n        }\r\n    }\r\n    traverse(cb, includeSelf) {\r\n        this.geometryNode.traverse(cb, includeSelf);\r\n    }\r\n    get id() {\r\n        return this.geometryNode.id;\r\n    }\r\n    get name() {\r\n        return this.geometryNode.name;\r\n    }\r\n    get level() {\r\n        return this.geometryNode.level;\r\n    }\r\n    get isLeafNode() {\r\n        return this.geometryNode.isLeafNode;\r\n    }\r\n    get numPoints() {\r\n        return this.geometryNode.numPoints;\r\n    }\r\n    get index() {\r\n        return this.geometryNode.index;\r\n    }\r\n    get boundingSphere() {\r\n        return this.geometryNode.boundingSphere;\r\n    }\r\n    get boundingBox() {\r\n        return this.geometryNode.boundingBox;\r\n    }\r\n    get spacing() {\r\n        return this.geometryNode.spacing;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/math.ts\nfunction clamp(value, min, max) {\r\n    return Math.min(Math.max(min, value), max);\r\n}\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree-picker.ts\n\r\n\r\n\r\n\r\nclass PointCloudOctreePicker {\r\n    dispose() {\r\n        if (this.pickState) {\r\n            this.pickState.material.dispose();\r\n            this.pickState.renderTarget.dispose();\r\n        }\r\n    }\r\n    pick(renderer, camera, ray, octrees, params = {}) {\r\n        if (octrees.length === 0) {\r\n            return null;\r\n        }\r\n        const pickState = this.pickState\r\n            ? this.pickState\r\n            : (this.pickState = PointCloudOctreePicker.getPickState());\r\n        const pickMaterial = pickState.material;\r\n        const pixelRatio = renderer.getPixelRatio();\r\n        const width = Math.ceil(renderer.domElement.clientWidth * pixelRatio);\r\n        const height = Math.ceil(renderer.domElement.clientHeight * pixelRatio);\r\n        PointCloudOctreePicker.updatePickRenderTarget(this.pickState, width, height);\r\n        const pixelPosition = PointCloudOctreePicker.helperVec3; // Use helper vector to prevent extra allocations.\r\n        if (params.pixelPosition) {\r\n            pixelPosition.copy(params.pixelPosition);\r\n        }\r\n        else {\r\n            pixelPosition.addVectors(camera.position, ray.direction).project(camera);\r\n            pixelPosition.x = (pixelPosition.x + 1) * width * 0.5;\r\n            pixelPosition.y = (pixelPosition.y + 1) * height * 0.5;\r\n        }\r\n        const pickWndSize = Math.floor((params.pickWindowSize || DEFAULT_PICK_WINDOW_SIZE) * pixelRatio);\r\n        const halfPickWndSize = (pickWndSize - 1) / 2;\r\n        const x = Math.floor(clamp(pixelPosition.x - halfPickWndSize, 0, width));\r\n        const y = Math.floor(clamp(pixelPosition.y - halfPickWndSize, 0, height));\r\n        PointCloudOctreePicker.prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState);\r\n        const renderedNodes = PointCloudOctreePicker.render(renderer, camera, pickMaterial, octrees, ray, pickState, params);\r\n        // Cleanup\r\n        pickMaterial.clearVisibleNodeTextureOffsets();\r\n        // Read back image and decode hit point\r\n        const pixels = PointCloudOctreePicker.readPixels(renderer, x, y, pickWndSize);\r\n        const hit = PointCloudOctreePicker.findHit(pixels, pickWndSize);\r\n        return PointCloudOctreePicker.getPickPoint(hit, renderedNodes);\r\n    }\r\n    static prepareRender(renderer, x, y, pickWndSize, pickMaterial, pickState) {\r\n        // Render the intersected nodes onto the pick render target, clipping to a small pick window.\r\n        renderer.setScissor(x, y, pickWndSize, pickWndSize);\r\n        renderer.setScissorTest(true);\r\n        renderer.state.buffers.depth.setTest(pickMaterial.depthTest);\r\n        renderer.state.buffers.depth.setMask(pickMaterial.depthWrite);\r\n        renderer.state.setBlending(external_three_.NoBlending);\r\n        renderer.setRenderTarget(pickState.renderTarget);\r\n        // Save the current clear color and clear the renderer with black color and alpha 0.\r\n        renderer.getClearColor(this.clearColor);\r\n        const oldClearAlpha = renderer.getClearAlpha();\r\n        renderer.setClearColor(COLOR_BLACK, 0);\r\n        renderer.clear(true, true, true);\r\n        renderer.setClearColor(this.clearColor, oldClearAlpha);\r\n    }\r\n    static render(renderer, camera, pickMaterial, octrees, ray, pickState, params) {\r\n        const renderedNodes = [];\r\n        for (const octree of octrees) {\r\n            // Get all the octree nodes which intersect the picking ray. We only need to render those.\r\n            const nodes = PointCloudOctreePicker.nodesOnRay(octree, ray);\r\n            if (!nodes.length) {\r\n                continue;\r\n            }\r\n            PointCloudOctreePicker.updatePickMaterial(pickMaterial, octree.material, params);\r\n            pickMaterial.updateMaterial(octree, nodes, camera, renderer);\r\n            if (params.onBeforePickRender) {\r\n                params.onBeforePickRender(pickMaterial, pickState.renderTarget);\r\n            }\r\n            // Create copies of the nodes so we can render them differently than in the normal point cloud.\r\n            pickState.scene.children = PointCloudOctreePicker.createTempNodes(octree, nodes, pickMaterial, renderedNodes.length);\r\n            renderer.render(pickState.scene, camera);\r\n            nodes.forEach(node => renderedNodes.push({ node, octree }));\r\n        }\r\n        return renderedNodes;\r\n    }\r\n    static nodesOnRay(octree, ray) {\r\n        const nodesOnRay = [];\r\n        const rayClone = ray.clone();\r\n        for (const node of octree.visibleNodes) {\r\n            const sphere = PointCloudOctreePicker.helperSphere\r\n                .copy(node.boundingSphere)\r\n                .applyMatrix4(octree.matrixWorld);\r\n            if (rayClone.intersectsSphere(sphere)) {\r\n                nodesOnRay.push(node);\r\n            }\r\n        }\r\n        return nodesOnRay;\r\n    }\r\n    static readPixels(renderer, x, y, pickWndSize) {\r\n        // Read the pixel from the pick render target.\r\n        const pixels = new Uint8Array(4 * pickWndSize * pickWndSize);\r\n        renderer.readRenderTargetPixels(renderer.getRenderTarget(), x, y, pickWndSize, pickWndSize, pixels);\r\n        renderer.setScissorTest(false);\r\n        renderer.setRenderTarget(null);\r\n        return pixels;\r\n    }\r\n    static createTempNodes(octree, nodes, pickMaterial, nodeIndexOffset) {\r\n        const tempNodes = [];\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            const node = nodes[i];\r\n            const sceneNode = node.sceneNode;\r\n            const tempNode = new external_three_.Points(sceneNode.geometry, pickMaterial);\r\n            tempNode.matrix = sceneNode.matrix;\r\n            tempNode.matrixWorld = sceneNode.matrixWorld;\r\n            tempNode.matrixAutoUpdate = false;\r\n            tempNode.frustumCulled = false;\r\n            const nodeIndex = nodeIndexOffset + i + 1;\r\n            if (nodeIndex > 255) {\r\n                console.error('More than 255 nodes for pick are not supported.');\r\n            }\r\n            tempNode.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(octree, node, nodeIndex);\r\n            tempNodes.push(tempNode);\r\n        }\r\n        return tempNodes;\r\n    }\r\n    static updatePickMaterial(pickMaterial, nodeMaterial, params) {\r\n        pickMaterial.pointSizeType = nodeMaterial.pointSizeType;\r\n        pickMaterial.shape = nodeMaterial.shape;\r\n        pickMaterial.size = nodeMaterial.size;\r\n        pickMaterial.minSize = nodeMaterial.minSize;\r\n        pickMaterial.maxSize = nodeMaterial.maxSize;\r\n        pickMaterial.classification = nodeMaterial.classification;\r\n        pickMaterial.useFilterByNormal = nodeMaterial.useFilterByNormal;\r\n        pickMaterial.filterByNormalThreshold = nodeMaterial.filterByNormalThreshold;\r\n        if (params.pickOutsideClipRegion) {\r\n            pickMaterial.clipMode = ClipMode.DISABLED;\r\n        }\r\n        else {\r\n            pickMaterial.clipMode = nodeMaterial.clipMode;\r\n            pickMaterial.setClipBoxes(nodeMaterial.clipMode === ClipMode.CLIP_OUTSIDE ? nodeMaterial.clipBoxes : []);\r\n        }\r\n    }\r\n    static updatePickRenderTarget(pickState, width, height) {\r\n        if (pickState.renderTarget.width === width && pickState.renderTarget.height === height) {\r\n            return;\r\n        }\r\n        pickState.renderTarget.dispose();\r\n        pickState.renderTarget = PointCloudOctreePicker.makePickRenderTarget();\r\n        pickState.renderTarget.setSize(width, height);\r\n    }\r\n    static makePickRenderTarget() {\r\n        return new external_three_.WebGLRenderTarget(1, 1, {\r\n            minFilter: external_three_.LinearFilter,\r\n            magFilter: external_three_.NearestFilter,\r\n            format: external_three_.RGBAFormat,\r\n        });\r\n    }\r\n    static findHit(pixels, pickWndSize) {\r\n        const ibuffer = new Uint32Array(pixels.buffer);\r\n        // Find closest hit inside pixelWindow boundaries\r\n        let min = Number.MAX_VALUE;\r\n        let hit = null;\r\n        for (let u = 0; u < pickWndSize; u++) {\r\n            for (let v = 0; v < pickWndSize; v++) {\r\n                const offset = u + v * pickWndSize;\r\n                const distance = Math.pow(u - (pickWndSize - 1) / 2, 2) + Math.pow(v - (pickWndSize - 1) / 2, 2);\r\n                const pcIndex = pixels[4 * offset + 3];\r\n                pixels[4 * offset + 3] = 0;\r\n                const pIndex = ibuffer[offset];\r\n                if (pcIndex > 0 && distance < min) {\r\n                    hit = {\r\n                        pIndex: pIndex,\r\n                        pcIndex: pcIndex - 1,\r\n                    };\r\n                    min = distance;\r\n                }\r\n            }\r\n        }\r\n        return hit;\r\n    }\r\n    static getPickPoint(hit, nodes) {\r\n        if (!hit) {\r\n            return null;\r\n        }\r\n        const point = {};\r\n        const points = nodes[hit.pcIndex] && nodes[hit.pcIndex].node.sceneNode;\r\n        if (!points) {\r\n            return null;\r\n        }\r\n        point.pointCloud = nodes[hit.pcIndex].octree;\r\n        const attributes = points.geometry.attributes;\r\n        for (const property in attributes) {\r\n            if (!attributes.hasOwnProperty(property)) {\r\n                continue;\r\n            }\r\n            const values = attributes[property];\r\n            // tslint:disable-next-line:prefer-switch\r\n            if (property === 'position') {\r\n                PointCloudOctreePicker.addPositionToPickPoint(point, hit, values, points);\r\n            }\r\n            else if (property === 'normal') {\r\n                PointCloudOctreePicker.addNormalToPickPoint(point, hit, values, points);\r\n            }\r\n            else if (property === 'indices') {\r\n                // TODO\r\n            }\r\n            else {\r\n                if (values.itemSize === 1) {\r\n                    point[property] = values.array[hit.pIndex];\r\n                }\r\n                else {\r\n                    const value = [];\r\n                    for (let j = 0; j < values.itemSize; j++) {\r\n                        value.push(values.array[values.itemSize * hit.pIndex + j]);\r\n                    }\r\n                    point[property] = value;\r\n                }\r\n            }\r\n        }\r\n        return point;\r\n    }\r\n    static addPositionToPickPoint(point, hit, values, points) {\r\n        point.position = new external_three_.Vector3()\r\n            .fromBufferAttribute(values, hit.pIndex)\r\n            .applyMatrix4(points.matrixWorld);\r\n    }\r\n    static addNormalToPickPoint(point, hit, values, points) {\r\n        const normal = new external_three_.Vector3().fromBufferAttribute(values, hit.pIndex);\r\n        const normal4 = new external_three_.Vector4(normal.x, normal.y, normal.z, 0).applyMatrix4(points.matrixWorld);\r\n        normal.set(normal4.x, normal4.y, normal4.z);\r\n        point.normal = normal;\r\n    }\r\n    static getPickState() {\r\n        const scene = new external_three_.Scene();\r\n        scene.matrixAutoUpdate = false;\r\n        const material = new PointCloudMaterial();\r\n        material.pointColorType = PointColorType.POINT_INDEX;\r\n        return {\r\n            renderTarget: PointCloudOctreePicker.makePickRenderTarget(),\r\n            material: material,\r\n            scene: scene,\r\n        };\r\n    }\r\n}\r\nPointCloudOctreePicker.helperVec3 = new external_three_.Vector3();\r\nPointCloudOctreePicker.helperSphere = new external_three_.Sphere();\r\nPointCloudOctreePicker.clearColor = new external_three_.Color();\r\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry.ts\n\r\nclass OctreeGeometry {\r\n    constructor(loader, boundingBox) {\r\n        this.loader = loader;\r\n        this.boundingBox = boundingBox;\r\n        this.maxNumNodesLoading = 3;\r\n        this.numNodesLoading = 0;\r\n        this.needsUpdate = true;\r\n        this.disposed = false;\r\n        this.pointAttributes = null;\r\n        this.spacing = 0;\r\n        this.url = null;\r\n        this.tightBoundingBox = this.boundingBox.clone();\r\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n        this.tightBoundingSphere = this.boundingSphere.clone();\r\n    }\r\n    dispose() {\r\n        this.root.traverse((node) => node.dispose());\r\n        this.disposed = true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-tree.ts\n\r\nclass PointCloudTree extends external_three_.Object3D {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.root = null;\r\n    }\r\n    initialized() {\r\n        return this.root !== null;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/point-cloud-octree.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass PointCloudOctree extends PointCloudTree {\r\n    constructor(potree, pcoGeometry, material) {\r\n        super();\r\n        this.disposed = false;\r\n        this.level = 0;\r\n        this.maxLevel = Infinity;\r\n        /**\r\n         * The minimum radius of a node's bounding sphere on the screen in order to be displayed.\r\n         */\r\n        this.minNodePixelSize = DEFAULT_MIN_NODE_PIXEL_SIZE;\r\n        this.root = null;\r\n        this.boundingBoxNodes = [];\r\n        this.visibleNodes = [];\r\n        this.visibleGeometry = [];\r\n        this.numVisiblePoints = 0;\r\n        this.showBoundingBox = false;\r\n        this.visibleBounds = new external_three_.Box3();\r\n        this.name = '';\r\n        this.potree = potree;\r\n        this.root = pcoGeometry.root;\r\n        this.pcoGeometry = pcoGeometry;\r\n        this.boundingBox = pcoGeometry.boundingBox;\r\n        this.boundingSphere = this.boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n        this.position.copy(pcoGeometry.offset);\r\n        this.updateMatrix();\r\n        this.material =\r\n            material || pcoGeometry instanceof OctreeGeometry\r\n                ? new PointCloudMaterial({ colorRgba: true })\r\n                : new PointCloudMaterial();\r\n        this.initMaterial(this.material);\r\n    }\r\n    initMaterial(material) {\r\n        this.updateMatrixWorld(true);\r\n        const { min, max } = computeTransformedBoundingBox(this.pcoGeometry.tightBoundingBox || this.getBoundingBoxWorld(), this.matrixWorld);\r\n        const bWidth = max.z - min.z;\r\n        material.heightMin = min.z - 0.2 * bWidth;\r\n        material.heightMax = max.z + 0.2 * bWidth;\r\n    }\r\n    dispose() {\r\n        if (this.root) {\r\n            this.root.dispose();\r\n        }\r\n        this.pcoGeometry.root.traverse(n => this.potree.lru.remove(n));\r\n        this.pcoGeometry.dispose();\r\n        this.material.dispose();\r\n        this.visibleNodes = [];\r\n        this.visibleGeometry = [];\r\n        if (this.picker) {\r\n            this.picker.dispose();\r\n            this.picker = undefined;\r\n        }\r\n        this.disposed = true;\r\n    }\r\n    get pointSizeType() {\r\n        return this.material.pointSizeType;\r\n    }\r\n    set pointSizeType(value) {\r\n        this.material.pointSizeType = value;\r\n    }\r\n    toTreeNode(geometryNode, parent) {\r\n        const points = new external_three_.Points(geometryNode.geometry, this.material);\r\n        const node = new PointCloudOctreeNode(geometryNode, points);\r\n        points.name = geometryNode.name;\r\n        points.position.copy(geometryNode.boundingBox.min);\r\n        points.frustumCulled = false;\r\n        points.onBeforeRender = PointCloudMaterial.makeOnBeforeRender(this, node);\r\n        if (parent) {\r\n            parent.sceneNode.add(points);\r\n            parent.children[geometryNode.index] = node;\r\n            geometryNode.oneTimeDisposeHandlers.push(() => {\r\n                node.disposeSceneNode();\r\n                parent.sceneNode.remove(node.sceneNode);\r\n                // Replace the tree node (rendered and in the GPU) with the geometry node.\r\n                parent.children[geometryNode.index] = geometryNode;\r\n            });\r\n        }\r\n        else {\r\n            this.root = node;\r\n            this.add(points);\r\n        }\r\n        return node;\r\n    }\r\n    updateVisibleBounds() {\r\n        const bounds = this.visibleBounds;\r\n        bounds.min.set(Infinity, Infinity, Infinity);\r\n        bounds.max.set(-Infinity, -Infinity, -Infinity);\r\n        for (const node of this.visibleNodes) {\r\n            if (node.isLeafNode) {\r\n                bounds.expandByPoint(node.boundingBox.min);\r\n                bounds.expandByPoint(node.boundingBox.max);\r\n            }\r\n        }\r\n    }\r\n    updateBoundingBoxes() {\r\n        if (!this.showBoundingBox || !this.parent) {\r\n            return;\r\n        }\r\n        let bbRoot = this.parent.getObjectByName('bbroot');\r\n        if (!bbRoot) {\r\n            bbRoot = new external_three_.Object3D();\r\n            bbRoot.name = 'bbroot';\r\n            this.parent.add(bbRoot);\r\n        }\r\n        const visibleBoxes = [];\r\n        for (const node of this.visibleNodes) {\r\n            if (node.boundingBoxNode !== undefined && node.isLeafNode) {\r\n                visibleBoxes.push(node.boundingBoxNode);\r\n            }\r\n        }\r\n        bbRoot.children = visibleBoxes;\r\n    }\r\n    updateMatrixWorld(force) {\r\n        if (this.matrixAutoUpdate === true) {\r\n            this.updateMatrix();\r\n        }\r\n        if (this.matrixWorldNeedsUpdate === true || force === true) {\r\n            if (!this.parent) {\r\n                this.matrixWorld.copy(this.matrix);\r\n            }\r\n            else {\r\n                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\r\n            }\r\n            this.matrixWorldNeedsUpdate = false;\r\n            force = true;\r\n        }\r\n    }\r\n    hideDescendants(object) {\r\n        const toHide = [];\r\n        addVisibleChildren(object);\r\n        while (toHide.length > 0) {\r\n            const objToHide = toHide.shift();\r\n            objToHide.visible = false;\r\n            addVisibleChildren(objToHide);\r\n        }\r\n        function addVisibleChildren(obj) {\r\n            for (const child of obj.children) {\r\n                if (child.visible) {\r\n                    toHide.push(child);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    moveToOrigin() {\r\n        this.position.set(0, 0, 0); // Reset, then the matrix will be updated in getBoundingBoxWorld()\r\n        this.position.set(0, 0, 0).sub(this.getBoundingBoxWorld().getCenter(new external_three_.Vector3()));\r\n    }\r\n    moveToGroundPlane() {\r\n        this.position.y += -this.getBoundingBoxWorld().min.y;\r\n    }\r\n    getBoundingBoxWorld() {\r\n        this.updateMatrixWorld(true);\r\n        return computeTransformedBoundingBox(this.boundingBox, this.matrixWorld);\r\n    }\r\n    getVisibleExtent() {\r\n        return this.visibleBounds.applyMatrix4(this.matrixWorld);\r\n    }\r\n    pick(renderer, camera, ray, params = {}) {\r\n        this.picker = this.picker || new PointCloudOctreePicker();\r\n        return this.picker.pick(renderer, camera, ray, [this], params);\r\n    }\r\n    get progress() {\r\n        return this.visibleGeometry.length === 0\r\n            ? 0\r\n            : this.visibleNodes.length / this.visibleGeometry.length;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/features.ts\nconst canvas = document.createElement('canvas');\r\nconst gl = canvas.getContext('webgl');\r\nconst FEATURES = {\r\n    SHADER_INTERPOLATION: hasExtension('EXT_frag_depth') && hasMinVaryingVectors(8),\r\n    SHADER_SPLATS: hasExtension('EXT_frag_depth') && hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\r\n    SHADER_EDL: hasExtension('OES_texture_float') && hasMinVaryingVectors(8),\r\n    precision: getPrecision(),\r\n};\r\nfunction hasExtension(ext) {\r\n    return gl !== null && Boolean(gl.getExtension(ext));\r\n}\r\nfunction hasMinVaryingVectors(value) {\r\n    return gl !== null && gl.getParameter(gl.MAX_VARYING_VECTORS) >= value;\r\n}\r\nfunction getPrecision() {\r\n    if (gl === null) {\r\n        return '';\r\n    }\r\n    const vsHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\r\n    const vsMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\r\n    const fsHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\r\n    const fsMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\r\n    const highpAvailable = vsHighpFloat && fsHighpFloat && vsHighpFloat.precision > 0 && fsHighpFloat.precision > 0;\r\n    const mediumpAvailable = vsMediumpFloat &&\r\n        fsMediumpFloat &&\r\n        vsMediumpFloat.precision > 0 &&\r\n        fsMediumpFloat.precision > 0;\r\n    return highpAvailable ? 'highp' : mediumpAvailable ? 'mediump' : 'lowp';\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/async-blocking-queue.ts\nclass AsyncBlockingQueue {\r\n    constructor() {\r\n        this.resolvers = [];\r\n        this.promises = [];\r\n    }\r\n    enqueue(t) {\r\n        if (!this.resolvers.length) {\r\n            this.add();\r\n        }\r\n        const resolve = this.resolvers.shift();\r\n        resolve(t);\r\n    }\r\n    dequeue() {\r\n        if (!this.promises.length) {\r\n            this.add();\r\n        }\r\n        return this.promises.shift();\r\n    }\r\n    add() {\r\n        this.promises.push(new Promise(resolve => {\r\n            this.resolvers.push(resolve);\r\n        }));\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/worker-pool.ts\n\r\nclass AutoTerminatingWorker {\r\n    constructor(wrappedWorker, maxIdle) {\r\n        this.wrappedWorker = wrappedWorker;\r\n        this.maxIdle = maxIdle;\r\n        this.timeoutId = undefined;\r\n        this.terminated = false;\r\n    }\r\n    get worker() {\r\n        return this.wrappedWorker;\r\n    }\r\n    get isTerminated() {\r\n        return this.terminated;\r\n    }\r\n    markIdle() {\r\n        this.timeoutId = window.setTimeout(() => {\r\n            this.terminated = true;\r\n            this.wrappedWorker.terminate();\r\n        }, this.maxIdle);\r\n    }\r\n    markInUse() {\r\n        if (this.timeoutId) {\r\n            window.clearTimeout(this.timeoutId);\r\n        }\r\n    }\r\n}\r\nclass WorkerPool {\r\n    constructor(maxWorkers, workerType) {\r\n        this.maxWorkers = maxWorkers;\r\n        this.workerType = workerType;\r\n        this.pool = new AsyncBlockingQueue();\r\n        this.poolSize = 0;\r\n    }\r\n    /**\r\n     * Returns a worker promise which is resolved when one is available.\r\n     */\r\n    getWorker() {\r\n        // If the number of active workers is smaller than the maximum, return a new one.\r\n        // Otherwise, return a promise for worker from the pool.\r\n        if (this.poolSize < this.maxWorkers) {\r\n            this.poolSize++;\r\n            return Promise.resolve(new AutoTerminatingWorker(new this.workerType(), WorkerPool.POOL_MAX_IDLE));\r\n        }\r\n        else {\r\n            return this.pool.dequeue().then(worker => {\r\n                worker.markInUse();\r\n                // If the dequeued worker has been terminated, decrease the pool size and make a recursive call to get a new worker\r\n                if (worker.isTerminated) {\r\n                    this.poolSize--;\r\n                    return this.getWorker();\r\n                }\r\n                return worker;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Releases a Worker back into the pool\r\n     * @param worker\r\n     */\r\n    releaseWorker(worker) {\r\n        worker.markIdle();\r\n        this.pool.enqueue(worker);\r\n    }\r\n}\r\n/**\r\n * The maximum amount of idle time that can elapse before a worker from this pool is automatically terminated\r\n */\r\nWorkerPool.POOL_MAX_IDLE = 7000;\r\n\n;// CONCATENATED MODULE: ./src/version.ts\nclass Version {\r\n    constructor(version) {\r\n        this.versionMinor = 0;\r\n        this.version = version;\r\n        const vmLength = version.indexOf('.') === -1 ? version.length : version.indexOf('.');\r\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\r\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\r\n        if (isNaN(this.versionMinor)) {\r\n            this.versionMinor = 0;\r\n        }\r\n    }\r\n    newerThan(version) {\r\n        const v = new Version(version);\r\n        if (this.versionMajor > v.versionMajor) {\r\n            return true;\r\n        }\r\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    equalOrHigher(version) {\r\n        const v = new Version(version);\r\n        if (this.versionMajor > v.versionMajor) {\r\n            return true;\r\n        }\r\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    upTo(version) {\r\n        return !this.newerThan(version);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading/binary-loader.ts\n// -------------------------------------------------------------------------------------------------\r\n// Converted to Typescript and adapted from https://github.com/potree/potree\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\nclass BinaryLoader {\r\n    constructor({ getUrl = s => Promise.resolve(s), version, boundingBox, scale, xhrRequest, }) {\r\n        this.disposed = false;\r\n        if (typeof version === 'string') {\r\n            this.version = new Version(version);\r\n        }\r\n        else {\r\n            this.version = version;\r\n        }\r\n        this.xhrRequest = xhrRequest;\r\n        this.getUrl = getUrl;\r\n        this.boundingBox = boundingBox;\r\n        this.scale = scale;\r\n        this.callbacks = [];\r\n    }\r\n    dispose() {\r\n        this.disposed = true;\r\n    }\r\n    load(node) {\r\n        if (node.loaded || this.disposed) {\r\n            return Promise.resolve();\r\n        }\r\n        return Promise.resolve(this.getUrl(this.getNodeUrl(node)))\r\n            .then(url => this.xhrRequest(url, { mode: 'cors' }))\r\n            .then(res => handleFailedRequest(res))\r\n            .then(okRes => okRes.arrayBuffer())\r\n            .then(buffer => handleEmptyBuffer(buffer))\r\n            .then(okBuffer => {\r\n            return new Promise(resolve => this.parse(node, okBuffer, resolve));\r\n        });\r\n    }\r\n    getNodeUrl(node) {\r\n        let url = node.getUrl();\r\n        if (this.version.equalOrHigher('1.4')) {\r\n            url += '.bin';\r\n        }\r\n        return url;\r\n    }\r\n    parse(node, buffer, resolve) {\r\n        if (this.disposed) {\r\n            resolve();\r\n            return;\r\n        }\r\n        BinaryLoader.WORKER_POOL.getWorker().then(autoTerminatingWorker => {\r\n            const pointAttributes = node.pcoGeometry.pointAttributes;\r\n            const numPoints = buffer.byteLength / pointAttributes.byteSize;\r\n            if (this.version.upTo('1.5')) {\r\n                node.numPoints = numPoints;\r\n            }\r\n            autoTerminatingWorker.worker.onmessage = (e) => {\r\n                if (this.disposed) {\r\n                    resolve();\r\n                    BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\r\n                    return;\r\n                }\r\n                const data = e.data;\r\n                const geometry = (node.geometry = node.geometry || new external_three_.BufferGeometry());\r\n                geometry.boundingBox = node.boundingBox;\r\n                this.addBufferAttributes(geometry, data.attributeBuffers);\r\n                this.addIndices(geometry, data.indices);\r\n                this.addNormalAttribute(geometry, numPoints);\r\n                node.mean = new external_three_.Vector3().fromArray(data.mean);\r\n                node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\r\n                node.loaded = true;\r\n                node.loading = false;\r\n                node.failed = false;\r\n                node.pcoGeometry.numNodesLoading--;\r\n                node.pcoGeometry.needsUpdate = true;\r\n                this.callbacks.forEach(callback => callback(node));\r\n                resolve();\r\n                BinaryLoader.WORKER_POOL.releaseWorker(autoTerminatingWorker);\r\n            };\r\n            const message = {\r\n                buffer,\r\n                pointAttributes,\r\n                version: this.version.version,\r\n                min: node.boundingBox.min.toArray(),\r\n                offset: node.pcoGeometry.offset.toArray(),\r\n                scale: this.scale,\r\n                spacing: node.spacing,\r\n                hasChildren: node.hasChildren,\r\n            };\r\n            autoTerminatingWorker.worker.postMessage(message, [message.buffer]);\r\n        });\r\n    }\r\n    getTightBoundingBox({ min, max }) {\r\n        const box = new external_three_.Box3(new external_three_.Vector3().fromArray(min), new external_three_.Vector3().fromArray(max));\r\n        box.max.sub(box.min);\r\n        box.min.set(0, 0, 0);\r\n        return box;\r\n    }\r\n    addBufferAttributes(geometry, buffers) {\r\n        Object.keys(buffers).forEach(property => {\r\n            const buffer = buffers[property].buffer;\r\n            if (this.isAttribute(property, PointAttributeName.POSITION_CARTESIAN)) {\r\n                geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.COLOR_PACKED)) {\r\n                geometry.setAttribute('color', new external_three_.BufferAttribute(new Uint8Array(buffer), 3, true));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.INTENSITY)) {\r\n                geometry.setAttribute('intensity', new external_three_.BufferAttribute(new Float32Array(buffer), 1));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.CLASSIFICATION)) {\r\n                geometry.setAttribute('classification', new external_three_.BufferAttribute(new Uint8Array(buffer), 1));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_SPHEREMAPPED)) {\r\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.NORMAL_OCT16)) {\r\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n            }\r\n            else if (this.isAttribute(property, PointAttributeName.NORMAL)) {\r\n                geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n            }\r\n        });\r\n    }\r\n    addIndices(geometry, indices) {\r\n        const indicesAttribute = new external_three_.Uint8BufferAttribute(indices, 4);\r\n        indicesAttribute.normalized = true;\r\n        geometry.setAttribute('indices', indicesAttribute);\r\n    }\r\n    addNormalAttribute(geometry, numPoints) {\r\n        if (!geometry.getAttribute('normal')) {\r\n            const buffer = new Float32Array(numPoints * 3);\r\n            geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n        }\r\n    }\r\n    isAttribute(property, name) {\r\n        return parseInt(property, 10) === name;\r\n    }\r\n}\r\nBinaryLoader.WORKER_POOL = new WorkerPool(32, (__webpack_require__(91)/* [\"default\"] */ .A));\r\n\n;// CONCATENATED MODULE: ./src/loading/load-poc.ts\n// -------------------------------------------------------------------------------------------------\r\n// Converted to Typescript and adapted from https://github.com/potree/potree\r\n// -------------------------------------------------------------------------------------------------\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *\r\n * @param url\r\n *    The url of the point cloud file (usually cloud.js).\r\n * @param getUrl\r\n *    Function which receives the relative URL of a point cloud chunk file which is to be loaded\r\n *    and shoud return a new url (e.g. signed) in the form of a string or a promise.\r\n * @param xhrRequest An arrow function for a fetch request\r\n * @returns\r\n *    An observable which emits once when the first LOD of the point cloud is loaded.\r\n */\r\nfunction loadPOC(url, getUrl, xhrRequest) {\r\n    return Promise.resolve(getUrl(url)).then(transformedUrl => {\r\n        return xhrRequest(transformedUrl, { mode: 'cors' })\r\n            .then(res => handleFailedRequest(res))\r\n            .then(okRes => okRes.json())\r\n            .then(parse(transformedUrl, getUrl, xhrRequest));\r\n    });\r\n}\r\nfunction parse(url, getUrl, xhrRequest) {\r\n    return (data) => {\r\n        const { offset, boundingBox, tightBoundingBox } = getBoundingBoxes(data);\r\n        const loader = new BinaryLoader({\r\n            getUrl,\r\n            version: data.version,\r\n            boundingBox,\r\n            scale: data.scale,\r\n            xhrRequest,\r\n        });\r\n        const pco = new PointCloudOctreeGeometry(loader, boundingBox, tightBoundingBox, offset, xhrRequest);\r\n        pco.url = url;\r\n        pco.octreeDir = data.octreeDir;\r\n        pco.needsUpdate = true;\r\n        pco.spacing = data.spacing;\r\n        pco.hierarchyStepSize = data.hierarchyStepSize;\r\n        pco.projection = data.projection;\r\n        pco.offset = offset;\r\n        pco.pointAttributes = new PointAttributes(data.pointAttributes);\r\n        const nodes = {};\r\n        const version = new Version(data.version);\r\n        return loadRoot(pco, data, nodes, version).then(() => {\r\n            if (version.upTo('1.4')) {\r\n                loadRemainingHierarchy(pco, data, nodes);\r\n            }\r\n            pco.nodes = nodes;\r\n            return pco;\r\n        });\r\n    };\r\n}\r\nfunction getBoundingBoxes(data) {\r\n    const min = new external_three_.Vector3(data.boundingBox.lx, data.boundingBox.ly, data.boundingBox.lz);\r\n    const max = new external_three_.Vector3(data.boundingBox.ux, data.boundingBox.uy, data.boundingBox.uz);\r\n    const boundingBox = new external_three_.Box3(min, max);\r\n    const tightBoundingBox = boundingBox.clone();\r\n    const offset = min.clone();\r\n    if (data.tightBoundingBox) {\r\n        const { lx, ly, lz, ux, uy, uz } = data.tightBoundingBox;\r\n        tightBoundingBox.min.set(lx, ly, lz);\r\n        tightBoundingBox.max.set(ux, uy, uz);\r\n    }\r\n    boundingBox.min.sub(offset);\r\n    boundingBox.max.sub(offset);\r\n    tightBoundingBox.min.sub(offset);\r\n    tightBoundingBox.max.sub(offset);\r\n    return { offset, boundingBox, tightBoundingBox };\r\n}\r\nfunction loadRoot(pco, data, nodes, version) {\r\n    const name = 'r';\r\n    const root = new PointCloudOctreeGeometryNode(name, pco, pco.boundingBox);\r\n    root.hasChildren = true;\r\n    root.spacing = pco.spacing;\r\n    if (version.upTo('1.5')) {\r\n        root.numPoints = data.hierarchy[0][1];\r\n    }\r\n    else {\r\n        root.numPoints = 0;\r\n    }\r\n    pco.root = root;\r\n    nodes[name] = root;\r\n    return pco.root.load();\r\n}\r\nfunction loadRemainingHierarchy(pco, data, nodes) {\r\n    for (let i = 1; i < data.hierarchy.length; i++) {\r\n        const [name, numPoints] = data.hierarchy[i];\r\n        const { index, parentName, level } = parseName(name);\r\n        const parentNode = nodes[parentName];\r\n        const boundingBox = createChildAABB(parentNode.boundingBox, index);\r\n        const node = new PointCloudOctreeGeometryNode(name, pco, boundingBox);\r\n        node.level = level;\r\n        node.numPoints = numPoints;\r\n        node.spacing = pco.spacing / Math.pow(2, node.level);\r\n        nodes[name] = node;\r\n        parentNode.addChild(node);\r\n    }\r\n}\r\nfunction parseName(name) {\r\n    return {\r\n        index: getIndexFromName(name),\r\n        parentName: name.substring(0, name.length - 1),\r\n        level: name.length - 1,\r\n    };\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading/index.ts\n\r\n\r\n\r\n\n;// CONCATENATED MODULE: ./src/loading2/octree-geometry-node.ts\n\r\nclass OctreeGeometryNode {\r\n    constructor(name, octreeGeometry, boundingBox) {\r\n        this.name = name;\r\n        this.octreeGeometry = octreeGeometry;\r\n        this.boundingBox = boundingBox;\r\n        this.loaded = false;\r\n        this.loading = false;\r\n        this.failed = false;\r\n        this.parent = null;\r\n        this.hasChildren = false;\r\n        this.isLeafNode = true;\r\n        this.isTreeNode = false;\r\n        this.isGeometryNode = true;\r\n        this.children = [\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null,\r\n            null\r\n        ];\r\n        this.id = OctreeGeometryNode.IDCount++;\r\n        this.index = parseInt(name.charAt(name.length - 1));\r\n        this.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n        this.tightBoundingBox = boundingBox.clone();\r\n        this.numPoints = 0;\r\n        this.oneTimeDisposeHandlers = [];\r\n    }\r\n    getLevel() {\r\n        return this.level;\r\n    }\r\n    isLoaded() {\r\n        return this.loaded;\r\n    }\r\n    getBoundingSphere() {\r\n        return this.boundingSphere;\r\n    }\r\n    getBoundingBox() {\r\n        return this.boundingBox;\r\n    }\r\n    load() {\r\n        if (this.octreeGeometry.numNodesLoading >= this.octreeGeometry.maxNumNodesLoading) {\r\n            return Promise.resolve();\r\n        }\r\n        if (!this.octreeGeometry.loader) {\r\n            this.loading = false;\r\n            this.failed = true;\r\n            return Promise.reject(`Loader not initialized for ${this.name}`);\r\n        }\r\n        return this.octreeGeometry.loader.load(this);\r\n    }\r\n    getNumPoints() {\r\n        return this.numPoints;\r\n    }\r\n    dispose() {\r\n        if (this.geometry && this.parent != null) {\r\n            this.geometry.dispose();\r\n            this.geometry = undefined;\r\n            this.loaded = false;\r\n            for (let i = 0; i < this.oneTimeDisposeHandlers.length; i++) {\r\n                const handler = this.oneTimeDisposeHandlers[i];\r\n                handler();\r\n            }\r\n            this.oneTimeDisposeHandlers = [];\r\n        }\r\n    }\r\n    traverse(cb, includeSelf = true) {\r\n        const stack = includeSelf ? [this] : [];\r\n        let current;\r\n        while ((current = stack.pop()) !== undefined) {\r\n            cb(current);\r\n            for (const child of current.children) {\r\n                if (child !== null) {\r\n                    stack.push(child);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nOctreeGeometryNode.IDCount = 0;\r\nOctreeGeometryNode.IDCount = 0;\r\n\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\n/**\r\n * Some types of possible point attribute data formats\r\n *\r\n * @class\r\n */\r\nconst PointAttributeTypes = {\r\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\r\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\r\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\r\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\r\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\r\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\r\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\r\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\r\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\r\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\r\n};\r\nlet i = 0;\r\nfor (const obj in PointAttributeTypes) {\r\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\r\n    i++;\r\n}\r\n\r\nclass PointAttribute {\r\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.numElements = numElements;\r\n        this.range = range;\r\n        this.uri = uri;\r\n        this.byteSize = this.numElements * this.type.size;\r\n        this.description = '';\r\n    }\r\n}\r\n\r\nconst point_attributes_POINT_ATTRIBUTES = {\r\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\r\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\r\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\r\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\r\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\r\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\r\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\r\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\r\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\r\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\r\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\r\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\r\n};\r\nclass point_attributes_PointAttributes {\r\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\r\n        this.attributes = attributes;\r\n        this.byteSize = byteSize;\r\n        this.size = size;\r\n        this.vectors = vectors;\r\n        if (pointAttributes != null) {\r\n            for (let i = 0; i < pointAttributes.length; i++) {\r\n                const pointAttributeName = pointAttributes[i];\r\n                const pointAttribute = point_attributes_POINT_ATTRIBUTES[pointAttributeName];\r\n                this.attributes.push(pointAttribute);\r\n                this.byteSize += pointAttribute.byteSize;\r\n                this.size++;\r\n            }\r\n        }\r\n    }\r\n    add(pointAttribute) {\r\n        this.attributes.push(pointAttribute);\r\n        this.byteSize += pointAttribute.byteSize;\r\n        this.size++;\r\n    }\r\n    addVector(vector) {\r\n        this.vectors.push(vector);\r\n    }\r\n    hasNormals() {\r\n        for (const name in this.attributes) {\r\n            const pointAttribute = this.attributes[name];\r\n            if (pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\r\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_FLOATS ||\r\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL ||\r\n                pointAttribute === point_attributes_POINT_ATTRIBUTES.NORMAL_OCT16) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getAttribute(attributeName) {\r\n        return this.attributes.find(attr => attr.name === attributeName);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading2/worker-pool.ts\n// Create enums for different types of workers\r\nvar WorkerType;\r\n(function (WorkerType) {\r\n    WorkerType[\"DECODER_WORKER\"] = \"DECODER_WORKER\";\r\n    WorkerType[\"DECODER_WORKER_GLTF\"] = \"DECODER_WORKER_GLTF\";\r\n})(WorkerType || (WorkerType = {}));\r\n// Worker JS names: 'BinaryDecoderWorker.js', 'DEMWorker.js', 'EptBinaryDecoderWorker.js', 'EptLaszipDecoderWorker.js',\r\n// EptZstandardDecoder_preamble.js', 'EptZstandardDecoderWorker.js', 'LASDecoderWorker.js', 'LASLAZWorker.js', 'LazLoaderWorker.js'\r\nfunction createWorker(type) {\r\n    // console.log(type)\r\n    switch (type) {\r\n        case WorkerType.DECODER_WORKER: {\r\n            const DecoderWorker = (__webpack_require__(300)/* [\"default\"] */ .A);\r\n            return new DecoderWorker();\r\n        }\r\n        case WorkerType.DECODER_WORKER_GLTF: {\r\n            const DecoderWorker_GLTF = (__webpack_require__(218)/* [\"default\"] */ .A);\r\n            return new DecoderWorker_GLTF();\r\n        }\r\n        default:\r\n            throw new Error('Unknown worker type');\r\n    }\r\n}\r\nclass worker_pool_WorkerPool {\r\n    constructor() {\r\n        // Workers will be an object that has a key for each worker type and the value is an array of Workers that can be empty\r\n        this.workers = { DECODER_WORKER: [], DECODER_WORKER_GLTF: [] };\r\n    }\r\n    getWorker(workerType) {\r\n        // Throw error if workerType is not recognized\r\n        if (this.workers[workerType] === undefined) {\r\n            throw new Error('Unknown worker type');\r\n        }\r\n        // Given a worker URL, if URL does not exist in the worker object, create a new array with the URL as a key\r\n        if (this.workers[workerType].length === 0) {\r\n            const worker = createWorker(workerType);\r\n            this.workers[workerType].push(worker);\r\n        }\r\n        const worker = this.workers[workerType].pop();\r\n        if (worker === undefined) { // Typescript needs this\r\n            throw new Error('No workers available');\r\n        }\r\n        // Return the last worker in the array and remove it from the array\r\n        return worker;\r\n    }\r\n    returnWorker(workerType, worker) {\r\n        this.workers[workerType].push(worker);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading2/utils.ts\nfunction extractBasePath(url) {\r\n    return url.substring(0, url.lastIndexOf('/') + 1);\r\n}\r\nfunction buildUrl(basePath, fileName) {\r\n    return `${basePath}${fileName}`;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading2/octree-loader.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Buffer files for DEFAULT encoding\r\nconst HIERARCHY_FILE = 'hierarchy.bin';\r\nconst OCTREE_FILE = 'octree.bin';\r\n// Default buffer files for GLTF encoding\r\nconst GLTF_COLORS_FILE = 'colors.glbin';\r\nconst GLTF_POSITIONS_FILE = 'positions.glbin';\r\nclass NodeLoader {\r\n    constructor(getUrl, url, workerPool, metadata) {\r\n        this.getUrl = getUrl;\r\n        this.url = url;\r\n        this.workerPool = workerPool;\r\n        this.metadata = metadata;\r\n        this.hierarchyPath = '';\r\n        this.octreePath = '';\r\n        this.gltfColorsPath = '';\r\n        this.gltfPositionsPath = '';\r\n    }\r\n    async load(node) {\r\n        if (node.loaded || node.loading) {\r\n            return;\r\n        }\r\n        node.loading = true;\r\n        node.octreeGeometry.numNodesLoading++;\r\n        try {\r\n            if (node.nodeType === 2) {\r\n                await this.loadHierarchy(node);\r\n            }\r\n            const { byteOffset, byteSize } = node;\r\n            if (byteOffset === undefined || byteSize === undefined) {\r\n                throw new Error('byteOffset and byteSize are required');\r\n            }\r\n            let buffer;\r\n            if (this.metadata.encoding === \"GLTF\") {\r\n                const urlColors = await this.getUrl(this.gltfColorsPath);\r\n                const urlPositions = await this.getUrl(this.gltfPositionsPath);\r\n                if (byteSize === BigInt(0)) {\r\n                    buffer = new ArrayBuffer(0);\r\n                    console.warn(`loaded node with 0 bytes: ${node.name}`);\r\n                }\r\n                else {\r\n                    const firstPositions = byteOffset * 4n * 3n;\r\n                    const lastPositions = byteOffset * 4n * 3n + byteSize * 4n * 3n - 1n;\r\n                    const headersPositions = { Range: `bytes=${firstPositions}-${lastPositions}` };\r\n                    const responsePositions = await fetch(urlPositions, { headers: headersPositions });\r\n                    const bufferPositions = await responsePositions.arrayBuffer();\r\n                    const firstColors = byteOffset * 4n;\r\n                    const lastColors = byteOffset * 4n + byteSize * 4n - 1n;\r\n                    const headersColors = { Range: `bytes=${firstColors}-${lastColors}` };\r\n                    const responseColors = await fetch(urlColors, { headers: headersColors });\r\n                    const bufferColors = await responseColors.arrayBuffer();\r\n                    buffer = appendBuffer(bufferPositions, bufferColors);\r\n                }\r\n            }\r\n            else {\r\n                const urlOctree = await this.getUrl(this.octreePath);\r\n                const first = byteOffset;\r\n                const last = byteOffset + byteSize - BigInt(1);\r\n                if (byteSize === BigInt(0)) {\r\n                    buffer = new ArrayBuffer(0);\r\n                    console.warn(`loaded node with 0 bytes: ${node.name}`);\r\n                }\r\n                else {\r\n                    const headers = { Range: `bytes=${first}-${last}` };\r\n                    const response = await fetch(urlOctree, { headers });\r\n                    buffer = await response.arrayBuffer();\r\n                }\r\n            }\r\n            const workerType = this.metadata.encoding === 'GLTF' ? WorkerType.DECODER_WORKER_GLTF : WorkerType.DECODER_WORKER;\r\n            const worker = this.workerPool.getWorker(workerType);\r\n            worker.onmessage = (e) => {\r\n                const data = e.data;\r\n                const buffers = data.attributeBuffers;\r\n                this.workerPool.returnWorker(workerType, worker);\r\n                const geometry = new external_three_.BufferGeometry();\r\n                for (const property in buffers) {\r\n                    const buffer = buffers[property].buffer;\r\n                    if (property === 'position') {\r\n                        geometry.setAttribute('position', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n                    }\r\n                    else if (property === 'rgba') {\r\n                        geometry.setAttribute('rgba', new external_three_.BufferAttribute(new Uint8Array(buffer), 4, true));\r\n                    }\r\n                    else if (property === 'NORMAL') {\r\n                        geometry.setAttribute('normal', new external_three_.BufferAttribute(new Float32Array(buffer), 3));\r\n                    }\r\n                    else if (property === 'INDICES') {\r\n                        const bufferAttribute = new external_three_.BufferAttribute(new Uint8Array(buffer), 4);\r\n                        bufferAttribute.normalized = true;\r\n                        geometry.setAttribute('indices', bufferAttribute);\r\n                    }\r\n                    else {\r\n                        const bufferAttribute = new external_three_.BufferAttribute(new Float32Array(buffer), 1);\r\n                        const batchAttribute = buffers[property].attribute;\r\n                        bufferAttribute.potree = {\r\n                            offset: buffers[property].offset,\r\n                            scale: buffers[property].scale,\r\n                            preciseBuffer: buffers[property].preciseBuffer,\r\n                            range: batchAttribute.range\r\n                        };\r\n                        geometry.setAttribute(property, bufferAttribute);\r\n                    }\r\n                }\r\n                node.density = data.density;\r\n                node.geometry = geometry;\r\n                node.loaded = true;\r\n                node.loading = false;\r\n                node.octreeGeometry.numNodesLoading--;\r\n                node.octreeGeometry.needsUpdate = true;\r\n                node.tightBoundingBox = this.getTightBoundingBox(data.tightBoundingBox);\r\n            };\r\n            const pointAttributes = node.octreeGeometry.pointAttributes;\r\n            const scale = node.octreeGeometry.scale;\r\n            const box = node.boundingBox;\r\n            const min = node.octreeGeometry.offset.clone().add(box.min);\r\n            const size = box.max.clone().sub(box.min);\r\n            const max = min.clone().add(size);\r\n            const numPoints = node.numPoints;\r\n            const offset = node.octreeGeometry.loader.offset;\r\n            const message = {\r\n                name: node.name,\r\n                buffer: buffer,\r\n                pointAttributes: pointAttributes,\r\n                scale: scale,\r\n                min: min,\r\n                max: max,\r\n                size: size,\r\n                offset: offset,\r\n                numPoints: numPoints\r\n            };\r\n            worker.postMessage(message, [message.buffer]);\r\n        }\r\n        catch (e) {\r\n            node.loaded = false;\r\n            node.loading = false;\r\n            node.octreeGeometry.numNodesLoading--;\r\n        }\r\n    }\r\n    parseHierarchy(node, buffer) {\r\n        const view = new DataView(buffer);\r\n        const bytesPerNode = 22;\r\n        const numNodes = buffer.byteLength / bytesPerNode;\r\n        const octree = node.octreeGeometry;\r\n        const nodes = new Array(numNodes);\r\n        nodes[0] = node;\r\n        let nodePos = 1;\r\n        for (let i = 0; i < numNodes; i++) {\r\n            const current = nodes[i];\r\n            const type = view.getUint8(i * bytesPerNode + 0);\r\n            const childMask = view.getUint8(i * bytesPerNode + 1);\r\n            const numPoints = view.getUint32(i * bytesPerNode + 2, true);\r\n            const byteOffset = view.getBigInt64(i * bytesPerNode + 6, true);\r\n            const byteSize = view.getBigInt64(i * bytesPerNode + 14, true);\r\n            if (current.nodeType === 2) {\r\n                // replace proxy with real node\r\n                current.byteOffset = byteOffset;\r\n                current.byteSize = byteSize;\r\n                current.numPoints = numPoints;\r\n            }\r\n            else if (type === 2) {\r\n                // load proxy\r\n                current.hierarchyByteOffset = byteOffset;\r\n                current.hierarchyByteSize = byteSize;\r\n                current.numPoints = numPoints;\r\n            }\r\n            else {\r\n                // load real node\r\n                current.byteOffset = byteOffset;\r\n                current.byteSize = byteSize;\r\n                current.numPoints = numPoints;\r\n            }\r\n            current.nodeType = type;\r\n            if (current.nodeType === 2) {\r\n                continue;\r\n            }\r\n            for (let childIndex = 0; childIndex < 8; childIndex++) {\r\n                const childExists = (1 << childIndex & childMask) !== 0;\r\n                if (!childExists) {\r\n                    continue;\r\n                }\r\n                const childName = current.name + childIndex;\r\n                const childAABB = octree_loader_createChildAABB(current.boundingBox, childIndex);\r\n                const child = new OctreeGeometryNode(childName, octree, childAABB);\r\n                child.name = childName;\r\n                child.spacing = current.spacing / 2;\r\n                child.level = current.level + 1;\r\n                current.children[childIndex] = child;\r\n                child.parent = current;\r\n                nodes[nodePos] = child;\r\n                nodePos++;\r\n            }\r\n        }\r\n    }\r\n    async loadHierarchy(node) {\r\n        const { hierarchyByteOffset, hierarchyByteSize } = node;\r\n        if (hierarchyByteOffset === undefined || hierarchyByteSize === undefined) {\r\n            throw new Error(`hierarchyByteOffset and hierarchyByteSize are undefined for node ${node.name}`);\r\n        }\r\n        const hierarchyUrl = await this.getUrl(this.hierarchyPath);\r\n        const first = hierarchyByteOffset;\r\n        const last = first + hierarchyByteSize - BigInt(1);\r\n        const headers = { Range: `bytes=${first}-${last}` };\r\n        const response = await fetch(hierarchyUrl, { headers });\r\n        const buffer = await response.arrayBuffer();\r\n        this.parseHierarchy(node, buffer);\r\n    }\r\n    getTightBoundingBox({ min, max }) {\r\n        const box = new external_three_.Box3(new external_three_.Vector3().fromArray(min), new external_three_.Vector3().fromArray(max));\r\n        box.max.sub(box.min);\r\n        box.min.set(0, 0, 0);\r\n        return box;\r\n    }\r\n}\r\nconst tmpVec3 = new external_three_.Vector3();\r\nfunction octree_loader_createChildAABB(aabb, index) {\r\n    const min = aabb.min.clone();\r\n    const max = aabb.max.clone();\r\n    const size = tmpVec3.subVectors(max, min);\r\n    if ((index & 0b0001) > 0) {\r\n        min.z += size.z / 2;\r\n    }\r\n    else {\r\n        max.z -= size.z / 2;\r\n    }\r\n    if ((index & 0b0010) > 0) {\r\n        min.y += size.y / 2;\r\n    }\r\n    else {\r\n        max.y -= size.y / 2;\r\n    }\r\n    if ((index & 0b0100) > 0) {\r\n        min.x += size.x / 2;\r\n    }\r\n    else {\r\n        max.x -= size.x / 2;\r\n    }\r\n    return new external_three_.Box3(min, max);\r\n}\r\nfunction appendBuffer(buffer1, buffer2) {\r\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\r\n    tmp.set(new Uint8Array(buffer1), 0);\r\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\r\n    return tmp.buffer;\r\n}\r\nconst typenameTypeattributeMap = {\r\n    double: PointAttributeTypes.DATA_TYPE_DOUBLE,\r\n    float: PointAttributeTypes.DATA_TYPE_FLOAT,\r\n    int8: PointAttributeTypes.DATA_TYPE_INT8,\r\n    uint8: PointAttributeTypes.DATA_TYPE_UINT8,\r\n    int16: PointAttributeTypes.DATA_TYPE_INT16,\r\n    uint16: PointAttributeTypes.DATA_TYPE_UINT16,\r\n    int32: PointAttributeTypes.DATA_TYPE_INT32,\r\n    uint32: PointAttributeTypes.DATA_TYPE_UINT32,\r\n    int64: PointAttributeTypes.DATA_TYPE_INT64,\r\n    uint64: PointAttributeTypes.DATA_TYPE_UINT64\r\n};\r\nclass OctreeLoader {\r\n    constructor(getUrl, url) {\r\n        this.workerPool = new worker_pool_WorkerPool();\r\n        this.basePath = '';\r\n        this.hierarchyPath = '';\r\n        this.octreePath = '';\r\n        this.gltfColorsPath = '';\r\n        this.gltfPositionsPath = '';\r\n        this.getUrl = getUrl;\r\n        this.basePath = extractBasePath(url);\r\n        this.hierarchyPath = buildUrl(this.basePath, HIERARCHY_FILE);\r\n        this.octreePath = buildUrl(this.basePath, OCTREE_FILE);\r\n        // We default to the known naming convention for glTF datasets\r\n        this.gltfColorsPath = buildUrl(this.basePath, GLTF_COLORS_FILE);\r\n        this.gltfPositionsPath = buildUrl(this.basePath, GLTF_POSITIONS_FILE);\r\n    }\r\n    static parseAttributes(jsonAttributes) {\r\n        const attributes = new point_attributes_PointAttributes();\r\n        const replacements = { rgb: 'rgba' };\r\n        for (const jsonAttribute of jsonAttributes) {\r\n            const { name, numElements, min, max, bufferView } = jsonAttribute;\r\n            const type = typenameTypeattributeMap[jsonAttribute.type];\r\n            const potreeAttributeName = replacements[name] ? replacements[name] : name;\r\n            const attribute = new PointAttribute(potreeAttributeName, type, numElements);\r\n            if (bufferView) {\r\n                attribute.uri = bufferView.uri;\r\n            }\r\n            if (numElements === 1 && min && max) {\r\n                attribute.range = [min[0], max[0]];\r\n            }\r\n            else {\r\n                attribute.range = [min, max];\r\n            }\r\n            if (name === 'gps-time') { // HACK: Guard against bad gpsTime range in metadata, see potree/potree#909\r\n                if (typeof attribute.range[0] === 'number' && attribute.range[0] === attribute.range[1]) {\r\n                    attribute.range[1] += 1;\r\n                }\r\n            }\r\n            attribute.initialRange = attribute.range;\r\n            attributes.add(attribute);\r\n        }\r\n        {\r\n            const hasNormals = attributes.attributes.find((a) => a.name === 'NormalX') !== undefined &&\r\n                attributes.attributes.find((a) => a.name === 'NormalY') !== undefined &&\r\n                attributes.attributes.find((a) => a.name === 'NormalZ') !== undefined;\r\n            if (hasNormals) {\r\n                const vector = {\r\n                    name: 'NORMAL',\r\n                    attributes: ['NormalX', 'NormalY', 'NormalZ']\r\n                };\r\n                attributes.addVector(vector);\r\n            }\r\n        }\r\n        return attributes;\r\n    }\r\n    async load(url, xhrRequest) {\r\n        const metadata = await this.fetchMetadata(url, xhrRequest);\r\n        const attributes = OctreeLoader.parseAttributes(metadata.attributes);\r\n        this.applyCustomBufferURI(metadata.encoding, attributes);\r\n        const loader = this.createLoader(url, metadata, attributes);\r\n        const boundingBox = this.createBoundingBox(metadata);\r\n        const offset = this.getOffset(boundingBox);\r\n        const octree = this.initializeOctree(loader, url, metadata, boundingBox, offset, attributes);\r\n        const root = this.initializeRootNode(octree, boundingBox, metadata);\r\n        octree.root = root;\r\n        loader.load(root);\r\n        return { geometry: octree };\r\n    }\r\n    async fetchMetadata(url, xhrRequest) {\r\n        const response = await xhrRequest(url);\r\n        return response.json();\r\n    }\r\n    applyCustomBufferURI(encoding, attributes) {\r\n        // Only datasets with GLTF encoding support custom buffer URIs -\r\n        // as opposed to datasets with DEFAULT encoding coming from PotreeConverter\r\n        if (encoding === 'GLTF') {\r\n            this.gltfPositionsPath = attributes.getAttribute(\"position\")?.uri ?? this.gltfPositionsPath;\r\n            this.gltfColorsPath = attributes.getAttribute(\"rgba\")?.uri ?? this.gltfColorsPath;\r\n        }\r\n    }\r\n    createLoader(url, metadata, attributes) {\r\n        const loader = new NodeLoader(this.getUrl, url, this.workerPool, metadata);\r\n        loader.attributes = attributes;\r\n        loader.scale = metadata.scale;\r\n        loader.offset = metadata.offset;\r\n        loader.hierarchyPath = this.hierarchyPath;\r\n        loader.octreePath = this.octreePath;\r\n        loader.gltfColorsPath = this.gltfColorsPath;\r\n        loader.gltfPositionsPath = this.gltfPositionsPath;\r\n        return loader;\r\n    }\r\n    createBoundingBox(metadata) {\r\n        const min = new external_three_.Vector3(...metadata.boundingBox.min);\r\n        const max = new external_three_.Vector3(...metadata.boundingBox.max);\r\n        const boundingBox = new external_three_.Box3(min, max);\r\n        return boundingBox;\r\n    }\r\n    getOffset(boundingBox) {\r\n        const offset = boundingBox.min.clone();\r\n        boundingBox.min.sub(offset);\r\n        boundingBox.max.sub(offset);\r\n        return offset;\r\n    }\r\n    initializeOctree(loader, url, metadata, boundingBox, offset, attributes) {\r\n        const octree = new OctreeGeometry(loader, boundingBox);\r\n        octree.url = url;\r\n        octree.spacing = metadata.spacing;\r\n        octree.scale = metadata.scale;\r\n        octree.projection = metadata.projection;\r\n        octree.boundingBox = boundingBox;\r\n        octree.boundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n        octree.tightBoundingSphere = boundingBox.getBoundingSphere(new external_three_.Sphere());\r\n        octree.tightBoundingBox = this.getTightBoundingBox(metadata);\r\n        octree.offset = offset;\r\n        octree.pointAttributes = attributes;\r\n        return octree;\r\n    }\r\n    initializeRootNode(octree, boundingBox, metadata) {\r\n        const root = new OctreeGeometryNode('r', octree, boundingBox);\r\n        root.level = 0;\r\n        root.nodeType = 2;\r\n        root.hierarchyByteOffset = BigInt(0);\r\n        root.hierarchyByteSize = BigInt(metadata.hierarchy.firstChunkSize);\r\n        root.spacing = octree.spacing;\r\n        root.byteOffset = BigInt(0);\r\n        return root;\r\n    }\r\n    getTightBoundingBox(metadata) {\r\n        const positionAttribute = metadata.attributes.find((attr) => attr.name === 'position');\r\n        if (!positionAttribute || !positionAttribute.min || !positionAttribute.max) {\r\n            console.warn('Position attribute (min, max) not found. Falling back to boundingBox for tightBoundingBox');\r\n            return new external_three_.Box3(new external_three_.Vector3(...metadata.boundingBox.min), new external_three_.Vector3(...metadata.boundingBox.max));\r\n        }\r\n        const offset = metadata.boundingBox.min;\r\n        const tightBoundingBox = new external_three_.Box3(new external_three_.Vector3(positionAttribute.min[0] - offset[0], positionAttribute.min[1] - offset[1], positionAttribute.min[2] - offset[2]), new external_three_.Vector3(positionAttribute.max[0] - offset[0], positionAttribute.max[1] - offset[1], positionAttribute.max[2] - offset[2]));\r\n        return tightBoundingBox;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading2/load-octree.ts\n\r\nasync function loadOctree(url, getUrl, xhrRequest) {\r\n    const trueUrl = await getUrl(url);\r\n    const loader = new OctreeLoader(getUrl, url);\r\n    const { geometry } = await loader.load(trueUrl, xhrRequest);\r\n    return geometry;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/type-predicates.ts\nfunction isGeometryNode(node) {\r\n    return node !== undefined && node !== null && node.isGeometryNode;\r\n}\r\nfunction isTreeNode(node) {\r\n    return node !== undefined && node !== null && node.isTreeNode;\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/binary-heap.js\n/**\n * from: http://eloquentjavascript.net/1st_edition/appendix2.html\n *\n */\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\nBinaryHeap.prototype = {\n  push: function push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n    // Allow it to bubble up.\n    this.bubbleUp(this.content.length - 1);\n  },\n  pop: function pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n    return result;\n  },\n  remove: function remove(node) {\n    var length = this.content.length;\n    // To remove a value, we must search through the array to find\n    // it.\n    for (var i = 0; i < length; i++) {\n      if (this.content[i] != node) continue;\n      // When it is found, the process seen in 'pop' is repeated\n      // to fill up the hole.\n      var end = this.content.pop();\n      // If the element we popped was the one we needed to remove,\n      // we're done.\n      if (i == length - 1) break;\n      // Otherwise, we replace the removed element with the popped\n      // one, and allow it to float up or sink down as appropriate.\n      this.content[i] = end;\n      this.bubbleUp(i);\n      this.sinkDown(i);\n      break;\n    }\n  },\n  size: function size() {\n    return this.content.length;\n  },\n  bubbleUp: function bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n],\n      score = this.scoreFunction(element);\n    // When at 0, an element can not go up any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n        parent = this.content[parentN];\n      // If the parent has a lesser score, things are in order and we\n      // are done.\n      if (score >= this.scoreFunction(parent)) break;\n\n      // Otherwise, swap the parent with the current element and\n      // continue.\n      this.content[parentN] = element;\n      this.content[n] = parent;\n      n = parentN;\n    }\n  },\n  sinkDown: function sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      var swap = null;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n          child1Score = this.scoreFunction(child1);\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) swap = child1N;\n      }\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n      }\n\n      // No need to swap further, we are done.\n      if (swap == null) break;\n\n      // Otherwise, swap and continue.\n      this.content[n] = this.content[swap];\n      this.content[swap] = element;\n      n = swap;\n    }\n  }\n};\n;// CONCATENATED MODULE: ./src/utils/box3-helper.ts\n\r\n/**\r\n *\r\n * code adapted from three.js BoxHelper.js\r\n * https://github.com/mrdoob/three.js/blob/dev/src/helpers/BoxHelper.js\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Mugen87 / http://github.com/Mugen87\r\n * @author mschuetz / http://potree.org\r\n */\r\nclass Box3Helper extends external_three_.LineSegments {\r\n    constructor(box, color = new external_three_.Color(0xffff00)) {\r\n        // prettier-ignore\r\n        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\r\n        // prettier-ignore\r\n        const positions = new Float32Array([\r\n            box.min.x, box.min.y, box.min.z,\r\n            box.max.x, box.min.y, box.min.z,\r\n            box.max.x, box.min.y, box.max.z,\r\n            box.min.x, box.min.y, box.max.z,\r\n            box.min.x, box.max.y, box.min.z,\r\n            box.max.x, box.max.y, box.min.z,\r\n            box.max.x, box.max.y, box.max.z,\r\n            box.min.x, box.max.y, box.max.z\r\n        ]);\r\n        const geometry = new external_three_.BufferGeometry();\r\n        geometry.setIndex(new external_three_.BufferAttribute(indices, 1));\r\n        geometry.setAttribute('position', new external_three_.BufferAttribute(positions, 3));\r\n        const material = new external_three_.LineBasicMaterial({ color: color });\r\n        super(geometry, material);\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/utils/lru.ts\nclass LRUItem {\r\n    constructor(node) {\r\n        this.node = node;\r\n        this.next = null;\r\n        this.previous = null;\r\n    }\r\n}\r\n/**\r\n * A doubly-linked-list of the least recently used elements.\r\n */\r\nclass LRU {\r\n    constructor(pointBudget = 1000000) {\r\n        this.pointBudget = pointBudget;\r\n        // the least recently used item\r\n        this.first = null;\r\n        // the most recently used item\r\n        this.last = null;\r\n        this.numPoints = 0;\r\n        this.items = new Map();\r\n    }\r\n    get size() {\r\n        return this.items.size;\r\n    }\r\n    has(node) {\r\n        return this.items.has(node.id);\r\n    }\r\n    /**\r\n     * Makes the specified the most recently used item. if the list does not contain node, it will\r\n     * be added.\r\n     */\r\n    touch(node) {\r\n        if (!node.loaded) {\r\n            return;\r\n        }\r\n        const item = this.items.get(node.id);\r\n        if (item) {\r\n            this.touchExisting(item);\r\n        }\r\n        else {\r\n            this.addNew(node);\r\n        }\r\n    }\r\n    addNew(node) {\r\n        const item = new LRUItem(node);\r\n        item.previous = this.last;\r\n        this.last = item;\r\n        if (item.previous) {\r\n            item.previous.next = item;\r\n        }\r\n        if (!this.first) {\r\n            this.first = item;\r\n        }\r\n        this.items.set(node.id, item);\r\n        this.numPoints += node.numPoints;\r\n    }\r\n    touchExisting(item) {\r\n        if (!item.previous) {\r\n            // handle touch on first element\r\n            if (item.next) {\r\n                this.first = item.next;\r\n                this.first.previous = null;\r\n                item.previous = this.last;\r\n                item.next = null;\r\n                this.last = item;\r\n                if (item.previous) {\r\n                    item.previous.next = item;\r\n                }\r\n            }\r\n        }\r\n        else if (!item.next) {\r\n            // handle touch on last element\r\n        }\r\n        else {\r\n            // handle touch on any other element\r\n            item.previous.next = item.next;\r\n            item.next.previous = item.previous;\r\n            item.previous = this.last;\r\n            item.next = null;\r\n            this.last = item;\r\n            if (item.previous) {\r\n                item.previous.next = item;\r\n            }\r\n        }\r\n    }\r\n    remove(node) {\r\n        const item = this.items.get(node.id);\r\n        if (!item) {\r\n            return;\r\n        }\r\n        if (this.items.size === 1) {\r\n            this.first = null;\r\n            this.last = null;\r\n        }\r\n        else {\r\n            if (!item.previous) {\r\n                this.first = item.next;\r\n                this.first.previous = null;\r\n            }\r\n            if (!item.next) {\r\n                this.last = item.previous;\r\n                this.last.next = null;\r\n            }\r\n            if (item.previous && item.next) {\r\n                item.previous.next = item.next;\r\n                item.next.previous = item.previous;\r\n            }\r\n        }\r\n        this.items.delete(node.id);\r\n        this.numPoints -= node.numPoints;\r\n    }\r\n    getLRUItem() {\r\n        return this.first ? this.first.node : undefined;\r\n    }\r\n    freeMemory() {\r\n        if (this.items.size <= 1) {\r\n            return;\r\n        }\r\n        while (this.numPoints > this.pointBudget * 2) {\r\n            const node = this.getLRUItem();\r\n            if (node) {\r\n                this.disposeSubtree(node);\r\n            }\r\n        }\r\n    }\r\n    disposeSubtree(node) {\r\n        // Collect all the nodes which are to be disposed and removed.\r\n        const nodesToDispose = [node];\r\n        node.traverse(n => {\r\n            if (n.loaded) {\r\n                nodesToDispose.push(n);\r\n            }\r\n        });\r\n        // Dispose of all the nodes in one go.\r\n        for (const n of nodesToDispose) {\r\n            n.dispose();\r\n            this.remove(n);\r\n        }\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/potree.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass QueueItem {\r\n    constructor(pointCloudIndex, weight, node, parent) {\r\n        this.pointCloudIndex = pointCloudIndex;\r\n        this.weight = weight;\r\n        this.node = node;\r\n        this.parent = parent;\r\n    }\r\n}\r\nconst GEOMETRY_LOADERS = {\r\n    v1: loadPOC,\r\n    v2: loadOctree\r\n};\r\nclass Potree {\r\n    constructor(version = \"v1\") {\r\n        this._pointBudget = DEFAULT_POINT_BUDGET;\r\n        this._rendererSize = new external_three_.Vector2();\r\n        this.maxNumNodesLoading = MAX_NUM_NODES_LOADING;\r\n        this.features = FEATURES;\r\n        this.lru = new LRU(this._pointBudget);\r\n        this.updateVisibilityStructures = (() => {\r\n            const frustumMatrix = new external_three_.Matrix4();\r\n            const inverseWorldMatrix = new external_three_.Matrix4();\r\n            const cameraMatrix = new external_three_.Matrix4();\r\n            return (pointClouds, camera) => {\r\n                const frustums = [];\r\n                const cameraPositions = [];\r\n                const priorityQueue = new BinaryHeap(x => 1 / x.weight);\r\n                for (let i = 0; i < pointClouds.length; i++) {\r\n                    const pointCloud = pointClouds[i];\r\n                    if (!pointCloud.initialized()) {\r\n                        continue;\r\n                    }\r\n                    pointCloud.numVisiblePoints = 0;\r\n                    pointCloud.visibleNodes = [];\r\n                    pointCloud.visibleGeometry = [];\r\n                    camera.updateMatrixWorld(false);\r\n                    // Furstum in object space.\r\n                    const inverseViewMatrix = camera.matrixWorldInverse;\r\n                    const worldMatrix = pointCloud.matrixWorld;\r\n                    frustumMatrix\r\n                        .identity()\r\n                        .multiply(camera.projectionMatrix)\r\n                        .multiply(inverseViewMatrix)\r\n                        .multiply(worldMatrix);\r\n                    frustums.push(new external_three_.Frustum().setFromProjectionMatrix(frustumMatrix));\r\n                    // Camera position in object space\r\n                    inverseWorldMatrix.copy(worldMatrix).invert();\r\n                    cameraMatrix\r\n                        .identity()\r\n                        .multiply(inverseWorldMatrix)\r\n                        .multiply(camera.matrixWorld);\r\n                    cameraPositions.push(new external_three_.Vector3().setFromMatrixPosition(cameraMatrix));\r\n                    if (pointCloud.visible && pointCloud.root !== null) {\r\n                        const weight = Number.MAX_VALUE;\r\n                        priorityQueue.push(new QueueItem(i, weight, pointCloud.root));\r\n                    }\r\n                    // Hide any previously visible nodes. We will later show only the needed ones.\r\n                    if (isTreeNode(pointCloud.root)) {\r\n                        pointCloud.hideDescendants(pointCloud.root.sceneNode);\r\n                    }\r\n                    for (const boundingBoxNode of pointCloud.boundingBoxNodes) {\r\n                        boundingBoxNode.visible = false;\r\n                    }\r\n                }\r\n                return { frustums, cameraPositions, priorityQueue };\r\n            };\r\n        })();\r\n        this.loadGeometry = GEOMETRY_LOADERS[version];\r\n    }\r\n    loadPointCloud(url, getUrl, xhrRequest = (input, init) => fetch(input, init)) {\r\n        return this.loadGeometry(url, getUrl, xhrRequest).then(geometry => new PointCloudOctree(this, geometry));\r\n    }\r\n    updatePointClouds(pointClouds, camera, renderer) {\r\n        const result = this.updateVisibility(pointClouds, camera, renderer);\r\n        for (let i = 0; i < pointClouds.length; i++) {\r\n            const pointCloud = pointClouds[i];\r\n            if (pointCloud.disposed) {\r\n                continue;\r\n            }\r\n            pointCloud.material.updateMaterial(pointCloud, pointCloud.visibleNodes, camera, renderer);\r\n            pointCloud.updateVisibleBounds();\r\n            pointCloud.updateBoundingBoxes();\r\n        }\r\n        this.lru.freeMemory();\r\n        return result;\r\n    }\r\n    static pick(pointClouds, renderer, camera, ray, params = {}) {\r\n        Potree.picker = Potree.picker || new PointCloudOctreePicker();\r\n        return Potree.picker.pick(renderer, camera, ray, pointClouds, params);\r\n    }\r\n    get pointBudget() {\r\n        return this._pointBudget;\r\n    }\r\n    set pointBudget(value) {\r\n        if (value !== this._pointBudget) {\r\n            this._pointBudget = value;\r\n            this.lru.pointBudget = value;\r\n            this.lru.freeMemory();\r\n        }\r\n    }\r\n    static set maxLoaderWorkers(value) {\r\n        BinaryLoader.WORKER_POOL.maxWorkers = value;\r\n    }\r\n    static get maxLoaderWorkers() {\r\n        return BinaryLoader.WORKER_POOL.maxWorkers;\r\n    }\r\n    updateVisibility(pointClouds, camera, renderer) {\r\n        let numVisiblePoints = 0;\r\n        const visibleNodes = [];\r\n        const unloadedGeometry = [];\r\n        // calculate object space frustum and cam pos and setup priority queue\r\n        const { frustums, cameraPositions, priorityQueue } = this.updateVisibilityStructures(pointClouds, camera);\r\n        let loadedToGPUThisFrame = 0;\r\n        let exceededMaxLoadsToGPU = false;\r\n        let nodeLoadFailed = false;\r\n        let queueItem;\r\n        while ((queueItem = priorityQueue.pop()) !== undefined) {\r\n            let node = queueItem.node;\r\n            // If we will end up with too many points, we stop right away.\r\n            if (numVisiblePoints + node.numPoints > this.pointBudget) {\r\n                break;\r\n            }\r\n            const pointCloudIndex = queueItem.pointCloudIndex;\r\n            const pointCloud = pointClouds[pointCloudIndex];\r\n            const maxLevel = pointCloud.maxLevel !== undefined ? pointCloud.maxLevel : Infinity;\r\n            if (node.level > maxLevel ||\r\n                !frustums[pointCloudIndex].intersectsBox(node.boundingBox) ||\r\n                this.shouldClip(pointCloud, node.boundingBox)) {\r\n                continue;\r\n            }\r\n            numVisiblePoints += node.numPoints;\r\n            pointCloud.numVisiblePoints += node.numPoints;\r\n            const parentNode = queueItem.parent;\r\n            if (isGeometryNode(node) && (!parentNode || isTreeNode(parentNode))) {\r\n                if (node.loaded && loadedToGPUThisFrame < MAX_LOADS_TO_GPU) {\r\n                    node = pointCloud.toTreeNode(node, parentNode);\r\n                    loadedToGPUThisFrame++;\r\n                }\r\n                else if (!node.failed) {\r\n                    if (node.loaded && loadedToGPUThisFrame >= MAX_LOADS_TO_GPU) {\r\n                        exceededMaxLoadsToGPU = true;\r\n                    }\r\n                    unloadedGeometry.push(node);\r\n                    pointCloud.visibleGeometry.push(node);\r\n                }\r\n                else {\r\n                    nodeLoadFailed = true;\r\n                    continue;\r\n                }\r\n            }\r\n            if (isTreeNode(node)) {\r\n                this.updateTreeNodeVisibility(pointCloud, node, visibleNodes);\r\n                pointCloud.visibleGeometry.push(node.geometryNode);\r\n            }\r\n            const halfHeight = 0.5 * renderer.getSize(this._rendererSize).height * renderer.getPixelRatio();\r\n            this.updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPositions[pointCloudIndex], camera, halfHeight);\r\n        } // end priority queue loop\r\n        const numNodesToLoad = Math.min(this.maxNumNodesLoading, unloadedGeometry.length);\r\n        const nodeLoadPromises = [];\r\n        for (let i = 0; i < numNodesToLoad; i++) {\r\n            nodeLoadPromises.push(unloadedGeometry[i].load());\r\n        }\r\n        return {\r\n            visibleNodes: visibleNodes,\r\n            numVisiblePoints: numVisiblePoints,\r\n            exceededMaxLoadsToGPU: exceededMaxLoadsToGPU,\r\n            nodeLoadFailed: nodeLoadFailed,\r\n            nodeLoadPromises: nodeLoadPromises,\r\n        };\r\n    }\r\n    updateTreeNodeVisibility(pointCloud, node, visibleNodes) {\r\n        this.lru.touch(node.geometryNode);\r\n        const sceneNode = node.sceneNode;\r\n        sceneNode.visible = true;\r\n        sceneNode.material = pointCloud.material;\r\n        sceneNode.updateMatrix();\r\n        sceneNode.matrixWorld.multiplyMatrices(pointCloud.matrixWorld, sceneNode.matrix);\r\n        visibleNodes.push(node);\r\n        pointCloud.visibleNodes.push(node);\r\n        this.updateBoundingBoxVisibility(pointCloud, node);\r\n    }\r\n    updateChildVisibility(queueItem, priorityQueue, pointCloud, node, cameraPosition, camera, halfHeight) {\r\n        const children = node.children;\r\n        for (let i = 0; i < children.length; i++) {\r\n            const child = children[i];\r\n            if (child === null) {\r\n                continue;\r\n            }\r\n            const sphere = child.boundingSphere;\r\n            const distance = sphere.center.distanceTo(cameraPosition);\r\n            const radius = sphere.radius;\r\n            let projectionFactor = 0.0;\r\n            if (camera.type === PERSPECTIVE_CAMERA) {\r\n                const perspective = camera;\r\n                const fov = (perspective.fov * Math.PI) / 180.0;\r\n                const slope = Math.tan(fov / 2.0);\r\n                projectionFactor = halfHeight / (slope * distance);\r\n            }\r\n            else {\r\n                const orthographic = camera;\r\n                projectionFactor = (2 * halfHeight) / (orthographic.top - orthographic.bottom);\r\n            }\r\n            const screenPixelRadius = radius * projectionFactor;\r\n            // Don't add the node if it'll be too small on the screen.\r\n            if (screenPixelRadius < pointCloud.minNodePixelSize) {\r\n                continue;\r\n            }\r\n            // Nodes which are larger will have priority in loading/displaying.\r\n            const weight = distance < radius ? Number.MAX_VALUE : screenPixelRadius + 1 / distance;\r\n            priorityQueue.push(new QueueItem(queueItem.pointCloudIndex, weight, child, node));\r\n        }\r\n    }\r\n    updateBoundingBoxVisibility(pointCloud, node) {\r\n        if (pointCloud.showBoundingBox && !node.boundingBoxNode) {\r\n            const boxHelper = new Box3Helper(node.boundingBox);\r\n            boxHelper.matrixAutoUpdate = false;\r\n            pointCloud.boundingBoxNodes.push(boxHelper);\r\n            node.boundingBoxNode = boxHelper;\r\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\r\n        }\r\n        else if (pointCloud.showBoundingBox && node.boundingBoxNode) {\r\n            node.boundingBoxNode.visible = true;\r\n            node.boundingBoxNode.matrix.copy(pointCloud.matrixWorld);\r\n        }\r\n        else if (!pointCloud.showBoundingBox && node.boundingBoxNode) {\r\n            node.boundingBoxNode.visible = false;\r\n        }\r\n    }\r\n    shouldClip(pointCloud, boundingBox) {\r\n        const material = pointCloud.material;\r\n        if (material.numClipBoxes === 0 || material.clipMode !== ClipMode.CLIP_OUTSIDE) {\r\n            return false;\r\n        }\r\n        const box2 = boundingBox.clone();\r\n        pointCloud.updateMatrixWorld(true);\r\n        box2.applyMatrix4(pointCloud.matrixWorld);\r\n        const clipBoxes = material.clipBoxes;\r\n        for (let i = 0; i < clipBoxes.length; i++) {\r\n            const clipMatrixWorld = clipBoxes[i].matrix;\r\n            const clipBoxWorld = new external_three_.Box3(new external_three_.Vector3(-0.5, -0.5, -0.5), new external_three_.Vector3(0.5, 0.5, 0.5)).applyMatrix4(clipMatrixWorld);\r\n            if (box2.intersectsBox(clipBoxWorld)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\n;// CONCATENATED MODULE: ./src/loading2/index.ts\n\r\n\n;// CONCATENATED MODULE: ./src/index.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNycEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdEQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoSEE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xRQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2JsdXItbWF0ZXJpYWwudHM/NTczOSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2NsaXBwaW5nLnRzPzFmOTYiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9lbnVtcy50cz85NjQyIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9jb25zdGFudHMudHM/YzNiNCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdXRpbHMvdXRpbHMudHM/NTYyMiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2NsYXNzaWZpY2F0aW9uLnRzP2ZhM2MiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvZ3JheXNjYWxlLnRzPzkyZDgiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9ncmFkaWVudHMvaW5mZXJuby50cz85MDMzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3BsYXNtYS50cz9jZWJmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3JhaW5ib3cudHM/YjEyYSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL2dyYWRpZW50cy9zcGVjdHJhbC50cz9iMGEyIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3ZpZHJpcy50cz83Y2ZkIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL3llbGxvdy1ncmVlbi50cz9kMjA3Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9tYXRlcmlhbHMvZ3JhZGllbnRzL2luZGV4LnRzPzJjOGUiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy90ZXh0dXJlLWdlbmVyYXRpb24udHM/MWVlNyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbWF0ZXJpYWxzL3BvaW50LWNsb3VkLW1hdGVyaWFsLnRzPzk1NDAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL21hdGVyaWFscy9pbmRleC50cz85MDI5Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1hdHRyaWJ1dGVzLnRzP2UwMzIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3V0aWxzL2JvdW5kcy50cz9kNTBlIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnktbm9kZS50cz8xOGVhIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnkudHM/OWY4MCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvcG9pbnQtY2xvdWQtb2N0cmVlLW5vZGUudHM/ZGExNyIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvdXRpbHMvbWF0aC50cz82MWY4Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC1vY3RyZWUtcGlja2VyLnRzPzFlM2MiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL29jdHJlZS1nZW9tZXRyeS50cz8yYTU1Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9wb2ludC1jbG91ZC10cmVlLnRzPzE1NGMiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3BvaW50LWNsb3VkLW9jdHJlZS50cz8zOWNhIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9mZWF0dXJlcy50cz8yOGMwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9hc3luYy1ibG9ja2luZy1xdWV1ZS50cz8zYjMzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy93b3JrZXItcG9vbC50cz8zNmJmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy92ZXJzaW9uLnRzPzEwMjkiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcvYmluYXJ5LWxvYWRlci50cz9jZDM0Iiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nL2xvYWQtcG9jLnRzPzNkNjIiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcvaW5kZXgudHM/MWE0YiIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvb2N0cmVlLWdlb21ldHJ5LW5vZGUudHM/MzljMCIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvbG9hZGluZzIvcG9pbnQtYXR0cmlidXRlcy50cz9kY2UwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi93b3JrZXItcG9vbC50cz8wZmFmIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi91dGlscy50cz9iY2UxIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy9sb2FkaW5nMi9vY3RyZWUtbG9hZGVyLnRzP2Y2OTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2xvYWQtb2N0cmVlLnRzPzQzMTAiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL3R5cGUtcHJlZGljYXRlcy50cz8zMTQzIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9iaW5hcnktaGVhcC5qcz8yNDUwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9ib3gzLWhlbHBlci50cz83MWEwIiwid2VicGFjazovL3BvdHJlZS8uL3NyYy91dGlscy9scnUudHM/OGUwZSIsIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvcG90cmVlLnRzPzlkOTciLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2luZGV4LnRzPzBlZWEiLCJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2luZGV4LnRzP2U5NGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyTWF0ZXJpYWwgfSBmcm9tICd0aHJlZSc7XHJcbmV4cG9ydCBjbGFzcyBCbHVyTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJNYXRlcmlhbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gcmVxdWlyZSgnLi9zaGFkZXJzL2JsdXIudmVydCcpO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSByZXF1aXJlKCcuL3NoYWRlcnMvYmx1ci5mcmFnJyk7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgc2NyZWVuV2lkdGg6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgICBzY3JlZW5IZWlnaHQ6IHsgdHlwZTogJ2YnLCB2YWx1ZTogMCB9LFxyXG4gICAgICAgICAgICBtYXA6IHsgdHlwZTogJ3QnLCB2YWx1ZTogbnVsbCB9LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0IHZhciBDbGlwTW9kZTtcclxuKGZ1bmN0aW9uIChDbGlwTW9kZSkge1xyXG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJESVNBQkxFRFwiXSA9IDBdID0gXCJESVNBQkxFRFwiO1xyXG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX09VVFNJREVcIl0gPSAxXSA9IFwiQ0xJUF9PVVRTSURFXCI7XHJcbiAgICBDbGlwTW9kZVtDbGlwTW9kZVtcIkhJR0hMSUdIVF9JTlNJREVcIl0gPSAyXSA9IFwiSElHSExJR0hUX0lOU0lERVwiO1xyXG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX0hPUklaT05UQUxMWVwiXSA9IDNdID0gXCJDTElQX0hPUklaT05UQUxMWVwiO1xyXG4gICAgQ2xpcE1vZGVbQ2xpcE1vZGVbXCJDTElQX1ZFUlRJQ0FMTFlcIl0gPSA0XSA9IFwiQ0xJUF9WRVJUSUNBTExZXCI7XHJcbn0pKENsaXBNb2RlIHx8IChDbGlwTW9kZSA9IHt9KSk7XHJcbiIsImV4cG9ydCB2YXIgUG9pbnRTaXplVHlwZTtcclxuKGZ1bmN0aW9uIChQb2ludFNpemVUeXBlKSB7XHJcbiAgICBQb2ludFNpemVUeXBlW1BvaW50U2l6ZVR5cGVbXCJGSVhFRFwiXSA9IDBdID0gXCJGSVhFRFwiO1xyXG4gICAgUG9pbnRTaXplVHlwZVtQb2ludFNpemVUeXBlW1wiQVRURU5VQVRFRFwiXSA9IDFdID0gXCJBVFRFTlVBVEVEXCI7XHJcbiAgICBQb2ludFNpemVUeXBlW1BvaW50U2l6ZVR5cGVbXCJBREFQVElWRVwiXSA9IDJdID0gXCJBREFQVElWRVwiO1xyXG59KShQb2ludFNpemVUeXBlIHx8IChQb2ludFNpemVUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBQb2ludFNoYXBlO1xyXG4oZnVuY3Rpb24gKFBvaW50U2hhcGUpIHtcclxuICAgIFBvaW50U2hhcGVbUG9pbnRTaGFwZVtcIlNRVUFSRVwiXSA9IDBdID0gXCJTUVVBUkVcIjtcclxuICAgIFBvaW50U2hhcGVbUG9pbnRTaGFwZVtcIkNJUkNMRVwiXSA9IDFdID0gXCJDSVJDTEVcIjtcclxuICAgIFBvaW50U2hhcGVbUG9pbnRTaGFwZVtcIlBBUkFCT0xPSURcIl0gPSAyXSA9IFwiUEFSQUJPTE9JRFwiO1xyXG59KShQb2ludFNoYXBlIHx8IChQb2ludFNoYXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBUcmVlVHlwZTtcclxuKGZ1bmN0aW9uIChUcmVlVHlwZSkge1xyXG4gICAgVHJlZVR5cGVbVHJlZVR5cGVbXCJPQ1RSRUVcIl0gPSAwXSA9IFwiT0NUUkVFXCI7XHJcbiAgICBUcmVlVHlwZVtUcmVlVHlwZVtcIktEVFJFRVwiXSA9IDFdID0gXCJLRFRSRUVcIjtcclxufSkoVHJlZVR5cGUgfHwgKFRyZWVUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBQb2ludE9wYWNpdHlUeXBlO1xyXG4oZnVuY3Rpb24gKFBvaW50T3BhY2l0eVR5cGUpIHtcclxuICAgIFBvaW50T3BhY2l0eVR5cGVbUG9pbnRPcGFjaXR5VHlwZVtcIkZJWEVEXCJdID0gMF0gPSBcIkZJWEVEXCI7XHJcbiAgICBQb2ludE9wYWNpdHlUeXBlW1BvaW50T3BhY2l0eVR5cGVbXCJBVFRFTlVBVEVEXCJdID0gMV0gPSBcIkFUVEVOVUFURURcIjtcclxufSkoUG9pbnRPcGFjaXR5VHlwZSB8fCAoUG9pbnRPcGFjaXR5VHlwZSA9IHt9KSk7XHJcbmV4cG9ydCB2YXIgUG9pbnRDb2xvclR5cGU7XHJcbihmdW5jdGlvbiAoUG9pbnRDb2xvclR5cGUpIHtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiUkdCXCJdID0gMF0gPSBcIlJHQlwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJDT0xPUlwiXSA9IDFdID0gXCJDT0xPUlwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJERVBUSFwiXSA9IDJdID0gXCJERVBUSFwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJIRUlHSFRcIl0gPSAzXSA9IFwiSEVJR0hUXCI7XHJcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkVMRVZBVElPTlwiXSA9IDNdID0gXCJFTEVWQVRJT05cIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiSU5URU5TSVRZXCJdID0gNF0gPSBcIklOVEVOU0lUWVwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJJTlRFTlNJVFlfR1JBRElFTlRcIl0gPSA1XSA9IFwiSU5URU5TSVRZX0dSQURJRU5UXCI7XHJcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIkxPRFwiXSA9IDZdID0gXCJMT0RcIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiTEVWRUxfT0ZfREVUQUlMXCJdID0gNl0gPSBcIkxFVkVMX09GX0RFVEFJTFwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJQT0lOVF9JTkRFWFwiXSA9IDddID0gXCJQT0lOVF9JTkRFWFwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJDTEFTU0lGSUNBVElPTlwiXSA9IDhdID0gXCJDTEFTU0lGSUNBVElPTlwiO1xyXG4gICAgUG9pbnRDb2xvclR5cGVbUG9pbnRDb2xvclR5cGVbXCJSRVRVUk5fTlVNQkVSXCJdID0gOV0gPSBcIlJFVFVSTl9OVU1CRVJcIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiU09VUkNFXCJdID0gMTBdID0gXCJTT1VSQ0VcIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiTk9STUFMXCJdID0gMTFdID0gXCJOT1JNQUxcIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiUEhPTkdcIl0gPSAxMl0gPSBcIlBIT05HXCI7XHJcbiAgICBQb2ludENvbG9yVHlwZVtQb2ludENvbG9yVHlwZVtcIlJHQl9IRUlHSFRcIl0gPSAxM10gPSBcIlJHQl9IRUlHSFRcIjtcclxuICAgIFBvaW50Q29sb3JUeXBlW1BvaW50Q29sb3JUeXBlW1wiQ09NUE9TSVRFXCJdID0gNTBdID0gXCJDT01QT1NJVEVcIjtcclxufSkoUG9pbnRDb2xvclR5cGUgfHwgKFBvaW50Q29sb3JUeXBlID0ge30pKTtcclxuZXhwb3J0IHZhciBOb3JtYWxGaWx0ZXJpbmdNb2RlO1xyXG4oZnVuY3Rpb24gKE5vcm1hbEZpbHRlcmluZ01vZGUpIHtcclxuICAgIE5vcm1hbEZpbHRlcmluZ01vZGVbTm9ybWFsRmlsdGVyaW5nTW9kZVtcIkFCU09MVVRFX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiXSA9IDFdID0gXCJBQlNPTFVURV9OT1JNQUxfRklMVEVSSU5HX01PREVcIjtcclxuICAgIE5vcm1hbEZpbHRlcmluZ01vZGVbTm9ybWFsRmlsdGVyaW5nTW9kZVtcIkxFU1NfRVFVQUxfTk9STUFMX0ZJTFRFUklOR19NT0RFXCJdID0gMl0gPSBcIkxFU1NfRVFVQUxfTk9STUFMX0ZJTFRFUklOR19NT0RFXCI7XHJcbiAgICBOb3JtYWxGaWx0ZXJpbmdNb2RlW05vcm1hbEZpbHRlcmluZ01vZGVbXCJHUkVBVEVSX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiXSA9IDNdID0gXCJHUkVBVEVSX05PUk1BTF9GSUxURVJJTkdfTU9ERVwiO1xyXG59KShOb3JtYWxGaWx0ZXJpbmdNb2RlIHx8IChOb3JtYWxGaWx0ZXJpbmdNb2RlID0ge30pKTtcclxuZXhwb3J0IHZhciBQb2ludENsb3VkTWl4aW5nTW9kZTtcclxuKGZ1bmN0aW9uIChQb2ludENsb3VkTWl4aW5nTW9kZSkge1xyXG4gICAgUG9pbnRDbG91ZE1peGluZ01vZGVbUG9pbnRDbG91ZE1peGluZ01vZGVbXCJDSEVDS0JPQVJEXCJdID0gMV0gPSBcIkNIRUNLQk9BUkRcIjtcclxuICAgIFBvaW50Q2xvdWRNaXhpbmdNb2RlW1BvaW50Q2xvdWRNaXhpbmdNb2RlW1wiU1RSSVBFU1wiXSA9IDJdID0gXCJTVFJJUEVTXCI7XHJcbn0pKFBvaW50Q2xvdWRNaXhpbmdNb2RlIHx8IChQb2ludENsb3VkTWl4aW5nTW9kZSA9IHt9KSk7XHJcbiIsImltcG9ydCB7IENvbG9yLCBWZWN0b3I0IH0gZnJvbSAndGhyZWUnO1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9SR0JfQlJJR0hUTkVTUyA9IDA7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JHQl9DT05UUkFTVCA9IDA7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JHQl9HQU1NQSA9IDE7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX01BWF9QT0lOVF9TSVpFID0gNTA7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX01JTl9OT0RFX1BJWEVMX1NJWkUgPSA1MDtcclxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTUlOX1BPSU5UX1NJWkUgPSAyO1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9QSUNLX1dJTkRPV19TSVpFID0gMTU7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX1BPSU5UX0JVREdFVCA9IDEwMDAwMDA7XHJcbmV4cG9ydCBjb25zdCBNQVhfTE9BRFNfVE9fR1BVID0gMjtcclxuZXhwb3J0IGNvbnN0IE1BWF9OVU1fTk9ERVNfTE9BRElORyA9IDQ7XHJcbmV4cG9ydCBjb25zdCBQRVJTUEVDVElWRV9DQU1FUkEgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xyXG5leHBvcnQgY29uc3QgQ09MT1JfQkxBQ0sgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0hJR0hMSUdIVF9DT0xPUiA9IG5ldyBWZWN0b3I0KDEsIDAsIDAsIDEpO1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKSB7XHJcbiAgICByZXR1cm4gcGFyc2VJbnQobmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSwgMTApO1xyXG59XHJcbi8qKlxyXG4gKiBXaGVuIHBhc3NlZCB0byBgW10uc29ydGAsIHNvcnRzIHRoZSBhcnJheSBieSBsZXZlbCBhbmQgaW5kZXg6IHIsIHIwLCByMywgcjQsIHIwMSwgcjA3LCByMzAsIC4uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJ5TGV2ZWxBbmRJbmRleChhLCBiKSB7XHJcbiAgICBjb25zdCBuYSA9IGEubmFtZTtcclxuICAgIGNvbnN0IG5iID0gYi5uYW1lO1xyXG4gICAgaWYgKG5hLmxlbmd0aCAhPT0gbmIubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hLmxlbmd0aCAtIG5iLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5hIDwgbmIpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYSA+IG5iKSB7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlRmFpbGVkUmVxdWVzdChyZXNwb25zZSkge1xyXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzcG9uc2U7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUVtcHR5QnVmZmVyKGJ1ZmZlcikge1xyXG4gICAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBFcnJvcignRW1wdHkgYnVmZmVyJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYnVmZmVyO1xyXG59XHJcbiIsImltcG9ydCB7IFZlY3RvcjQgfSBmcm9tICd0aHJlZSc7XHJcbmV4cG9ydCBjb25zdCBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OID0ge1xyXG4gICAgMDogbmV3IFZlY3RvcjQoMC41LCAwLjUsIDAuNSwgMS4wKSxcclxuICAgIDE6IG5ldyBWZWN0b3I0KDAuNSwgMC41LCAwLjUsIDEuMCksXHJcbiAgICAyOiBuZXcgVmVjdG9yNCgwLjYzLCAwLjMyLCAwLjE4LCAxLjApLFxyXG4gICAgMzogbmV3IFZlY3RvcjQoMC4wLCAxLjAsIDAuMCwgMS4wKSxcclxuICAgIDQ6IG5ldyBWZWN0b3I0KDAuMCwgMC44LCAwLjAsIDEuMCksXHJcbiAgICA1OiBuZXcgVmVjdG9yNCgwLjAsIDAuNiwgMC4wLCAxLjApLFxyXG4gICAgNjogbmV3IFZlY3RvcjQoMS4wLCAwLjY2LCAwLjAsIDEuMCksXHJcbiAgICA3OiBuZXcgVmVjdG9yNCgxLjAsIDAsIDEuMCwgMS4wKSxcclxuICAgIDg6IG5ldyBWZWN0b3I0KDEuMCwgMCwgMC4wLCAxLjApLFxyXG4gICAgOTogbmV3IFZlY3RvcjQoMC4wLCAwLjAsIDEuMCwgMS4wKSxcclxuICAgIDEyOiBuZXcgVmVjdG9yNCgxLjAsIDEuMCwgMC4wLCAxLjApLFxyXG4gICAgREVGQVVMVDogbmV3IFZlY3RvcjQoMC4zLCAwLjYsIDAuNiwgMC41KSxcclxufTtcclxuIiwiaW1wb3J0IHsgQ29sb3IgfSBmcm9tICd0aHJlZSc7XHJcbmV4cG9ydCBjb25zdCBHUkFZU0NBTEUgPSBbXHJcbiAgICBbMCwgbmV3IENvbG9yKDAsIDAsIDApXSxcclxuICAgIFsxLCBuZXcgQ29sb3IoMSwgMSwgMSldLFxyXG5dO1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGNvbnN0IElORkVSTk8gPSBbXHJcbiAgICBbMC4wLCBuZXcgQ29sb3IoMC4wNzcsIDAuMDQyLCAwLjIwNildLFxyXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMjI1LCAwLjAzNiwgMC4zODgpXSxcclxuICAgIFswLjIsIG5ldyBDb2xvcigwLjM3MywgMC4wNzQsIDAuNDMyKV0sXHJcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC41MjIsIDAuMTI4LCAwLjQyKV0sXHJcbiAgICBbMC40LCBuZXcgQ29sb3IoMC42NjUsIDAuMTgyLCAwLjM3KV0sXHJcbiAgICBbMC41LCBuZXcgQ29sb3IoMC43OTcsIDAuMjU1LCAwLjI4NyldLFxyXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuOTAyLCAwLjM2NCwgMC4xODQpXSxcclxuICAgIFswLjcsIG5ldyBDb2xvcigwLjk2OSwgMC41MTYsIDAuMDYzKV0sXHJcbiAgICBbMC44LCBuZXcgQ29sb3IoMC45ODgsIDAuNjgzLCAwLjA3MildLFxyXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuOTYxLCAwLjg1OSwgMC4yOTgpXSxcclxuICAgIFsxLjAsIG5ldyBDb2xvcigwLjk4OCwgMC45OTgsIDAuNjQ1KV0sXHJcbl07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xyXG5leHBvcnQgY29uc3QgUExBU01BID0gW1xyXG4gICAgWzAuMCwgbmV3IENvbG9yKDAuMjQxLCAwLjAxNSwgMC42MSldLFxyXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMzg3LCAwLjAwMSwgMC42NTQpXSxcclxuICAgIFswLjIsIG5ldyBDb2xvcigwLjUyNCwgMC4wMjUsIDAuNjUzKV0sXHJcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC42NTEsIDAuMTI1LCAwLjU5NildLFxyXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuNzUyLCAwLjIyNywgMC41MTMpXSxcclxuICAgIFswLjUsIG5ldyBDb2xvcigwLjgzNywgMC4zMjksIDAuNDMxKV0sXHJcbiAgICBbMC42LCBuZXcgQ29sb3IoMC45MDcsIDAuNDM1LCAwLjM1MyldLFxyXG4gICAgWzAuNywgbmV3IENvbG9yKDAuOTYzLCAwLjU1NCwgMC4yNzIpXSxcclxuICAgIFswLjgsIG5ldyBDb2xvcigwLjk5MiwgMC42ODEsIDAuMTk1KV0sXHJcbiAgICBbMC45LCBuZXcgQ29sb3IoMC45ODcsIDAuODIyLCAwLjE0NCldLFxyXG4gICAgWzEuMCwgbmV3IENvbG9yKDAuOTQsIDAuOTc1LCAwLjEzMSldLFxyXG5dO1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGNvbnN0IFJBSU5CT1cgPSBbXHJcbiAgICBbMCwgbmV3IENvbG9yKDAuMjc4LCAwLCAwLjcxNCldLFxyXG4gICAgWzEgLyA2LCBuZXcgQ29sb3IoMCwgMCwgMSldLFxyXG4gICAgWzIgLyA2LCBuZXcgQ29sb3IoMCwgMSwgMSldLFxyXG4gICAgWzMgLyA2LCBuZXcgQ29sb3IoMCwgMSwgMCldLFxyXG4gICAgWzQgLyA2LCBuZXcgQ29sb3IoMSwgMSwgMCldLFxyXG4gICAgWzUgLyA2LCBuZXcgQ29sb3IoMSwgMC42NCwgMCldLFxyXG4gICAgWzEsIG5ldyBDb2xvcigxLCAwLCAwKV0sXHJcbl07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xyXG4vLyBGcm9tIGNocm9tYSBzcGVjdHJhbCBodHRwOi8vZ2thLmdpdGh1Yi5pby9jaHJvbWEuanMvXHJcbmV4cG9ydCBjb25zdCBTUEVDVFJBTCA9IFtcclxuICAgIFswLCBuZXcgQ29sb3IoMC4zNjg2LCAwLjMwOTgsIDAuNjM1MyldLFxyXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMTk2MSwgMC41MzMzLCAwLjc0MTIpXSxcclxuICAgIFswLjIsIG5ldyBDb2xvcigwLjQsIDAuNzYwOCwgMC42NDcxKV0sXHJcbiAgICBbMC4zLCBuZXcgQ29sb3IoMC42NzA2LCAwLjg2NjcsIDAuNjQzMSldLFxyXG4gICAgWzAuNCwgbmV3IENvbG9yKDAuOTAyLCAwLjk2MDgsIDAuNTk2MSldLFxyXG4gICAgWzAuNSwgbmV3IENvbG9yKDEuMCwgMS4wLCAwLjc0OSldLFxyXG4gICAgWzAuNiwgbmV3IENvbG9yKDAuOTk2MSwgMC44Nzg0LCAwLjU0NTEpXSxcclxuICAgIFswLjcsIG5ldyBDb2xvcigwLjk5MjIsIDAuNjgyNCwgMC4zODA0KV0sXHJcbiAgICBbMC44LCBuZXcgQ29sb3IoMC45NTY5LCAwLjQyNzUsIDAuMjYyNyldLFxyXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuODM1MywgMC4yNDMxLCAwLjMwOTgpXSxcclxuICAgIFsxLCBuZXcgQ29sb3IoMC42MTk2LCAwLjAwMzksIDAuMjU4OCldLFxyXG5dO1xyXG4iLCJpbXBvcnQgeyBDb2xvciB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGNvbnN0IFZJUklESVMgPSBbXHJcbiAgICBbMC4wLCBuZXcgQ29sb3IoMC4yNjcsIDAuMDA1LCAwLjMyOSldLFxyXG4gICAgWzAuMSwgbmV3IENvbG9yKDAuMjgzLCAwLjE0MSwgMC40NTgpXSxcclxuICAgIFswLjIsIG5ldyBDb2xvcigwLjI1NCwgMC4yNjUsIDAuNTMpXSxcclxuICAgIFswLjMsIG5ldyBDb2xvcigwLjIwNywgMC4zNzIsIDAuNTUzKV0sXHJcbiAgICBbMC40LCBuZXcgQ29sb3IoMC4xNjQsIDAuNDcxLCAwLjU1OCldLFxyXG4gICAgWzAuNSwgbmV3IENvbG9yKDAuMTI4LCAwLjU2NywgMC41NTEpXSxcclxuICAgIFswLjYsIG5ldyBDb2xvcigwLjEzNSwgMC42NTksIDAuNTE4KV0sXHJcbiAgICBbMC43LCBuZXcgQ29sb3IoMC4yNjcsIDAuNzQ5LCAwLjQ0MSldLFxyXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuNDc4LCAwLjgyMSwgMC4zMTgpXSxcclxuICAgIFswLjksIG5ldyBDb2xvcigwLjc0MSwgMC44NzMsIDAuMTUpXSxcclxuICAgIFsxLjAsIG5ldyBDb2xvcigwLjk5MywgMC45MDYsIDAuMTQ0KV0sXHJcbl07XHJcbiIsImltcG9ydCB7IENvbG9yIH0gZnJvbSAndGhyZWUnO1xyXG5leHBvcnQgY29uc3QgWUVMTE9XX0dSRUVOID0gW1xyXG4gICAgWzAsIG5ldyBDb2xvcigwLjE2NDcsIDAuMjgyNCwgMC4zNDUxKV0sXHJcbiAgICBbMC4xLCBuZXcgQ29sb3IoMC4xMzM4LCAwLjM1NTUsIDAuNDIyNyldLFxyXG4gICAgWzAuMiwgbmV3IENvbG9yKDAuMDYxLCAwLjQzMTksIDAuNDg2NCldLFxyXG4gICAgWzAuMywgbmV3IENvbG9yKDAuMCwgMC41MDk5LCAwLjUzMTkpXSxcclxuICAgIFswLjQsIG5ldyBDb2xvcigwLjAsIDAuNTg4MSwgMC41NTY5KV0sXHJcbiAgICBbMC41LCBuZXcgQ29sb3IoMC4xMzcsIDAuNjY1LCAwLjU2MTQpXSxcclxuICAgIFswLjYsIG5ldyBDb2xvcigwLjI5MDYsIDAuNzM5NSwgMC41NDc3KV0sXHJcbiAgICBbMC43LCBuZXcgQ29sb3IoMC40NDUzLCAwLjgwOTksIDAuNTIwMSldLFxyXG4gICAgWzAuOCwgbmV3IENvbG9yKDAuNjEwMiwgMC44NzQ4LCAwLjQ4NSldLFxyXG4gICAgWzAuOSwgbmV3IENvbG9yKDAuNzg4MywgMC45MzIzLCAwLjQ1MTQpXSxcclxuICAgIFsxLCBuZXcgQ29sb3IoMC45ODA0LCAwLjk4MDQsIDAuNDMxNCldLFxyXG5dO1xyXG4iLCJleHBvcnQgKiBmcm9tICcuL2dyYXlzY2FsZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vaW5mZXJubyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vcGxhc21hJztcclxuZXhwb3J0ICogZnJvbSAnLi9yYWluYm93JztcclxuZXhwb3J0ICogZnJvbSAnLi9zcGVjdHJhbCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdmlkcmlzJztcclxuZXhwb3J0ICogZnJvbSAnLi95ZWxsb3ctZ3JlZW4nO1xyXG4iLCJpbXBvcnQgeyBDYW52YXNUZXh0dXJlLCBEYXRhVGV4dHVyZSwgTGluZWFyRmlsdGVyLCBOZWFyZXN0RmlsdGVyLCBSR0JBRm9ybWF0LCB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRGF0YVRleHR1cmUod2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuICAgIGNvbnN0IHNpemUgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSg0ICogc2l6ZSk7XHJcbiAgICBjb25zdCByID0gTWF0aC5mbG9vcihjb2xvci5yICogMjU1KTtcclxuICAgIGNvbnN0IGcgPSBNYXRoLmZsb29yKGNvbG9yLmcgKiAyNTUpO1xyXG4gICAgY29uc3QgYiA9IE1hdGguZmxvb3IoY29sb3IuYiAqIDI1NSk7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgIGRhdGFbaSAqIDNdID0gcjtcclxuICAgICAgICBkYXRhW2kgKiAzICsgMV0gPSBnO1xyXG4gICAgICAgIGRhdGFbaSAqIDMgKyAyXSA9IGI7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIFJHQkFGb3JtYXQpO1xyXG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB0ZXh0dXJlLm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUoZ3JhZGllbnQpIHtcclxuICAgIGNvbnN0IHNpemUgPSA2NDtcclxuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgY2FudmFzLndpZHRoID0gc2l6ZTtcclxuICAgIGNhbnZhcy5oZWlnaHQgPSBzaXplO1xyXG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgY29udGV4dC5yZWN0KDAsIDAsIHNpemUsIHNpemUpO1xyXG4gICAgY29uc3QgY3R4R3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHNpemUsIHNpemUpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmFkaWVudC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBncmFkaWVudFtpXTtcclxuICAgICAgICBjdHhHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RlcFswXSwgYCMke3N0ZXBbMV0uZ2V0SGV4U3RyaW5nKCl9YCk7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eEdyYWRpZW50O1xyXG4gICAgY29udGV4dC5maWxsKCk7XHJcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IENhbnZhc1RleHR1cmUoY2FudmFzKTtcclxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XHJcbiAgICAvLyB0ZXh0dXJlSW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xyXG4gICAgcmV0dXJuIHRleHR1cmU7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NpZmljYXRpb25UZXh0dXJlKGNsYXNzaWZpY2F0aW9uKSB7XHJcbiAgICBjb25zdCB3aWR0aCA9IDI1NjtcclxuICAgIGNvbnN0IGhlaWdodCA9IDI1NjtcclxuICAgIGNvbnN0IHNpemUgPSB3aWR0aCAqIGhlaWdodDtcclxuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSg0ICogc2l6ZSk7XHJcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcclxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGkgPSB4ICsgd2lkdGggKiB5O1xyXG4gICAgICAgICAgICBsZXQgY29sb3I7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc2lmaWNhdGlvblt4XSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjbGFzc2lmaWNhdGlvblt4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbGFzc2lmaWNhdGlvblt4ICUgMzJdKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYXNzaWZpY2F0aW9uW3ggJSAzMl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNsYXNzaWZpY2F0aW9uLkRFRkFVTFQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YVs0ICogaSArIDBdID0gMjU1ICogY29sb3IueDtcclxuICAgICAgICAgICAgZGF0YVs0ICogaSArIDFdID0gMjU1ICogY29sb3IueTtcclxuICAgICAgICAgICAgZGF0YVs0ICogaSArIDJdID0gMjU1ICogY29sb3IuejtcclxuICAgICAgICAgICAgZGF0YVs0ICogaSArIDNdID0gMjU1ICogY29sb3IudztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIFJHQkFGb3JtYXQpO1xyXG4gICAgdGV4dHVyZS5tYWdGaWx0ZXIgPSBOZWFyZXN0RmlsdGVyO1xyXG4gICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufVxyXG4iLCJ2YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5pbXBvcnQgeyBBZGRpdGl2ZUJsZW5kaW5nLCBDb2xvciwgTGVzc0VxdWFsRGVwdGgsIE5lYXJlc3RGaWx0ZXIsIE5vQmxlbmRpbmcsIFJhd1NoYWRlck1hdGVyaWFsLCBUZXh0dXJlLCBWZWN0b3IyLCBWZWN0b3IzLCB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgREVGQVVMVF9ISUdITElHSFRfQ09MT1IsIERFRkFVTFRfTUFYX1BPSU5UX1NJWkUsIERFRkFVTFRfTUlOX1BPSU5UX1NJWkUsIERFRkFVTFRfUkdCX0JSSUdIVE5FU1MsIERFRkFVTFRfUkdCX0NPTlRSQVNULCBERUZBVUxUX1JHQl9HQU1NQSwgUEVSU1BFQ1RJVkVfQ0FNRVJBLCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IGJ5TGV2ZWxBbmRJbmRleCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgREVGQVVMVF9DTEFTU0lGSUNBVElPTiB9IGZyb20gJy4vY2xhc3NpZmljYXRpb24nO1xyXG5pbXBvcnQgeyBDbGlwTW9kZSB9IGZyb20gJy4vY2xpcHBpbmcnO1xyXG5pbXBvcnQgeyBOb3JtYWxGaWx0ZXJpbmdNb2RlLCBQb2ludENsb3VkTWl4aW5nTW9kZSwgUG9pbnRDb2xvclR5cGUsIFBvaW50T3BhY2l0eVR5cGUsIFBvaW50U2hhcGUsIFBvaW50U2l6ZVR5cGUsIFRyZWVUeXBlLCB9IGZyb20gJy4vZW51bXMnO1xyXG5pbXBvcnQgeyBTUEVDVFJBTCB9IGZyb20gJy4vZ3JhZGllbnRzJztcclxuaW1wb3J0IHsgZ2VuZXJhdGVDbGFzc2lmaWNhdGlvblRleHR1cmUsIGdlbmVyYXRlRGF0YVRleHR1cmUsIGdlbmVyYXRlR3JhZGllbnRUZXh0dXJlLCB9IGZyb20gJy4vdGV4dHVyZS1nZW5lcmF0aW9uJztcclxuY29uc3QgVFJFRV9UWVBFX0RFRlMgPSB7XHJcbiAgICBbVHJlZVR5cGUuT0NUUkVFXTogJ3RyZWVfdHlwZV9vY3RyZWUnLFxyXG4gICAgW1RyZWVUeXBlLktEVFJFRV06ICd0cmVlX3R5cGVfa2R0cmVlJyxcclxufTtcclxuY29uc3QgU0laRV9UWVBFX0RFRlMgPSB7XHJcbiAgICBbUG9pbnRTaXplVHlwZS5GSVhFRF06ICdmaXhlZF9wb2ludF9zaXplJyxcclxuICAgIFtQb2ludFNpemVUeXBlLkFUVEVOVUFURURdOiAnYXR0ZW51YXRlZF9wb2ludF9zaXplJyxcclxuICAgIFtQb2ludFNpemVUeXBlLkFEQVBUSVZFXTogJ2FkYXB0aXZlX3BvaW50X3NpemUnLFxyXG59O1xyXG5jb25zdCBPUEFDSVRZX0RFRlMgPSB7XHJcbiAgICBbUG9pbnRPcGFjaXR5VHlwZS5BVFRFTlVBVEVEXTogJ2F0dGVudWF0ZWRfb3BhY2l0eScsXHJcbiAgICBbUG9pbnRPcGFjaXR5VHlwZS5GSVhFRF06ICdmaXhlZF9vcGFjaXR5JyxcclxufTtcclxuY29uc3QgU0hBUEVfREVGUyA9IHtcclxuICAgIFtQb2ludFNoYXBlLlNRVUFSRV06ICdzcXVhcmVfcG9pbnRfc2hhcGUnLFxyXG4gICAgW1BvaW50U2hhcGUuQ0lSQ0xFXTogJ2NpcmNsZV9wb2ludF9zaGFwZScsXHJcbiAgICBbUG9pbnRTaGFwZS5QQVJBQk9MT0lEXTogJ3BhcmFib2xvaWRfcG9pbnRfc2hhcGUnLFxyXG59O1xyXG5jb25zdCBDT0xPUl9ERUZTID0ge1xyXG4gICAgW1BvaW50Q29sb3JUeXBlLlJHQl06ICdjb2xvcl90eXBlX3JnYicsXHJcbiAgICBbUG9pbnRDb2xvclR5cGUuQ09MT1JdOiAnY29sb3JfdHlwZV9jb2xvcicsXHJcbiAgICBbUG9pbnRDb2xvclR5cGUuREVQVEhdOiAnY29sb3JfdHlwZV9kZXB0aCcsXHJcbiAgICBbUG9pbnRDb2xvclR5cGUuSEVJR0hUXTogJ2NvbG9yX3R5cGVfaGVpZ2h0JyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5JTlRFTlNJVFldOiAnY29sb3JfdHlwZV9pbnRlbnNpdHknLFxyXG4gICAgW1BvaW50Q29sb3JUeXBlLklOVEVOU0lUWV9HUkFESUVOVF06ICdjb2xvcl90eXBlX2ludGVuc2l0eV9ncmFkaWVudCcsXHJcbiAgICBbUG9pbnRDb2xvclR5cGUuTE9EXTogJ2NvbG9yX3R5cGVfbG9kJyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5QT0lOVF9JTkRFWF06ICdjb2xvcl90eXBlX3BvaW50X2luZGV4JyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5DTEFTU0lGSUNBVElPTl06ICdjb2xvcl90eXBlX2NsYXNzaWZpY2F0aW9uJyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5SRVRVUk5fTlVNQkVSXTogJ2NvbG9yX3R5cGVfcmV0dXJuX251bWJlcicsXHJcbiAgICBbUG9pbnRDb2xvclR5cGUuU09VUkNFXTogJ2NvbG9yX3R5cGVfc291cmNlJyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5OT1JNQUxdOiAnY29sb3JfdHlwZV9ub3JtYWwnLFxyXG4gICAgW1BvaW50Q29sb3JUeXBlLlBIT05HXTogJ2NvbG9yX3R5cGVfcGhvbmcnLFxyXG4gICAgW1BvaW50Q29sb3JUeXBlLlJHQl9IRUlHSFRdOiAnY29sb3JfdHlwZV9yZ2JfaGVpZ2h0JyxcclxuICAgIFtQb2ludENvbG9yVHlwZS5DT01QT1NJVEVdOiAnY29sb3JfdHlwZV9jb21wb3NpdGUnLFxyXG59O1xyXG5jb25zdCBDTElQX01PREVfREVGUyA9IHtcclxuICAgIFtDbGlwTW9kZS5ESVNBQkxFRF06ICdjbGlwX2Rpc2FibGVkJyxcclxuICAgIFtDbGlwTW9kZS5DTElQX09VVFNJREVdOiAnY2xpcF9vdXRzaWRlJyxcclxuICAgIFtDbGlwTW9kZS5ISUdITElHSFRfSU5TSURFXTogJ2NsaXBfaGlnaGxpZ2h0X2luc2lkZScsXHJcbiAgICBbQ2xpcE1vZGUuQ0xJUF9IT1JJWk9OVEFMTFldOiAnY2xpcF9ob3Jpem9udGFsbHknLFxyXG4gICAgW0NsaXBNb2RlLkNMSVBfVkVSVElDQUxMWV06ICdjbGlwX3ZlcnRpY2FsbHknLFxyXG59O1xyXG5leHBvcnQgY2xhc3MgUG9pbnRDbG91ZE1hdGVyaWFsIGV4dGVuZHMgUmF3U2hhZGVyTWF0ZXJpYWwge1xyXG4gICAgY29uc3RydWN0b3IocGFyYW1ldGVycyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2UgdGhlIGRyYXdpbmcgYnVmZmVyIHNpemUgaW5zdGVhZCBvZiB0aGUgZG9tIGNsaWVudCB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gcGFzc2luZyB0aGUgc2NyZWVuIGhlaWdodCBhbmQgc2NyZWVuIHdpZHRoIHVuaWZvcm1zIHRvIHRoZVxyXG4gICAgICAgICAqIHNoYWRlci4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IGhhdmUgb2Zmc2NyZWVuIGNhbnZhc2VzICh3aGljaCBpbiBzb21lIGJyb3dzZXJzIHJldHVybiAwIGFzIGNsaWVudCB3aWR0aCBhbmQgY2xpZW50IGhlaWdodCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51c2VEcmF3aW5nQnVmZmVyU2l6ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGlnaHRzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb2cgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbG9yUmdiYSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubnVtQ2xpcEJveGVzID0gMDtcclxuICAgICAgICB0aGlzLmNsaXBCb3hlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9ncmFkaWVudCA9IFNQRUNUUkFMO1xyXG4gICAgICAgIHRoaXMuZ3JhZGllbnRUZXh0dXJlID0gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUodGhpcy5fZ3JhZGllbnQpO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzaWZpY2F0aW9uID0gREVGQVVMVF9DTEFTU0lGSUNBVElPTjtcclxuICAgICAgICB0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSA9IGdlbmVyYXRlQ2xhc3NpZmljYXRpb25UZXh0dXJlKHRoaXMuX2NsYXNzaWZpY2F0aW9uKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0ge1xyXG4gICAgICAgICAgICBiYlNpemU6IG1ha2VVbmlmb3JtKCdmdicsIFswLCAwLCAwXSksXHJcbiAgICAgICAgICAgIGJsZW5kRGVwdGhTdXBwbGVtZW50OiBtYWtlVW5pZm9ybSgnZicsIDAuMCksXHJcbiAgICAgICAgICAgIGJsZW5kSGFyZG5lc3M6IG1ha2VVbmlmb3JtKCdmJywgMi4wKSxcclxuICAgICAgICAgICAgY2xhc3NpZmljYXRpb25MVVQ6IG1ha2VVbmlmb3JtKCd0JywgdGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUgfHwgbmV3IFRleHR1cmUoKSksXHJcbiAgICAgICAgICAgIGNsaXBCb3hDb3VudDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcclxuICAgICAgICAgICAgY2xpcEJveGVzOiBtYWtlVW5pZm9ybSgnTWF0cml4NGZ2JywgW10pLFxyXG4gICAgICAgICAgICBjbGlwSGlnaGxpZ2h0Q29sb3JzOiBtYWtlVW5pZm9ybSgnZnYnLCBuZXcgRmxvYXQzMkFycmF5KCkpLFxyXG4gICAgICAgICAgICBjbGlwRXh0ZW50OiBtYWtlVW5pZm9ybSgnZnYnLCBbMC4wLCAwLjAsIDEuMCwgMS4wXSksXHJcbiAgICAgICAgICAgIGRlcHRoTWFwOiBtYWtlVW5pZm9ybSgndCcsIG51bGwpLFxyXG4gICAgICAgICAgICBkaWZmdXNlOiBtYWtlVW5pZm9ybSgnZnYnLCBbMSwgMSwgMV0pLFxyXG4gICAgICAgICAgICBmb3Y6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcclxuICAgICAgICAgICAgZ3JhZGllbnQ6IG1ha2VVbmlmb3JtKCd0JywgdGhpcy5ncmFkaWVudFRleHR1cmUgfHwgbmV3IFRleHR1cmUoKSksXHJcbiAgICAgICAgICAgIGhlaWdodE1heDogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxyXG4gICAgICAgICAgICBoZWlnaHRNaW46IG1ha2VVbmlmb3JtKCdmJywgMC4wKSxcclxuICAgICAgICAgICAgaW50ZW5zaXR5QnJpZ2h0bmVzczogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcclxuICAgICAgICAgICAgaW50ZW5zaXR5Q29udHJhc3Q6IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIGludGVuc2l0eUdhbW1hOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxyXG4gICAgICAgICAgICBpbnRlbnNpdHlSYW5nZTogbWFrZVVuaWZvcm0oJ2Z2JywgWzAsIDY1MDAwXSksXHJcbiAgICAgICAgICAgIGlzTGVhZk5vZGU6IG1ha2VVbmlmb3JtKCdiJywgMCksXHJcbiAgICAgICAgICAgIGxldmVsOiBtYWtlVW5pZm9ybSgnZicsIDAuMCksXHJcbiAgICAgICAgICAgIG1heFNpemU6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9NQVhfUE9JTlRfU0laRSksXHJcbiAgICAgICAgICAgIG1pblNpemU6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9NSU5fUE9JTlRfU0laRSksXHJcbiAgICAgICAgICAgIG9jdHJlZVNpemU6IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG1ha2VVbmlmb3JtKCdmJywgMS4wKSxcclxuICAgICAgICAgICAgcGNJbmRleDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcclxuICAgICAgICAgICAgcmdiQnJpZ2h0bmVzczogbWFrZVVuaWZvcm0oJ2YnLCBERUZBVUxUX1JHQl9CUklHSFRORVNTKSxcclxuICAgICAgICAgICAgcmdiQ29udHJhc3Q6IG1ha2VVbmlmb3JtKCdmJywgREVGQVVMVF9SR0JfQ09OVFJBU1QpLFxyXG4gICAgICAgICAgICByZ2JHYW1tYTogbWFrZVVuaWZvcm0oJ2YnLCBERUZBVUxUX1JHQl9HQU1NQSksXHJcbiAgICAgICAgICAgIHNjcmVlbkhlaWdodDogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxyXG4gICAgICAgICAgICBzY3JlZW5XaWR0aDogbWFrZVVuaWZvcm0oJ2YnLCAxLjApLFxyXG4gICAgICAgICAgICBzaXplOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxyXG4gICAgICAgICAgICBzcGFjaW5nOiBtYWtlVW5pZm9ybSgnZicsIDEuMCksXHJcbiAgICAgICAgICAgIHRvTW9kZWw6IG1ha2VVbmlmb3JtKCdNYXRyaXg0ZicsIFtdKSxcclxuICAgICAgICAgICAgdHJhbnNpdGlvbjogbWFrZVVuaWZvcm0oJ2YnLCAwLjUpLFxyXG4gICAgICAgICAgICB1Q29sb3I6IG1ha2VVbmlmb3JtKCdjJywgbmV3IENvbG9yKDB4ZmZmZmZmKSksXHJcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcclxuICAgICAgICAgICAgdmlzaWJsZU5vZGVzOiBtYWtlVW5pZm9ybSgndCcsIHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZSB8fCBuZXcgVGV4dHVyZSgpKSxcclxuICAgICAgICAgICAgdm5TdGFydDogbWFrZVVuaWZvcm0oJ2YnLCAwLjApLFxyXG4gICAgICAgICAgICB3Q2xhc3NpZmljYXRpb246IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIHdFbGV2YXRpb246IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIHdJbnRlbnNpdHk6IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIHdSZXR1cm5OdW1iZXI6IG1ha2VVbmlmb3JtKCdmJywgMCksXHJcbiAgICAgICAgICAgIHdSR0I6IG1ha2VVbmlmb3JtKCdmJywgMSksXHJcbiAgICAgICAgICAgIHdTb3VyY2VJRDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcclxuICAgICAgICAgICAgb3BhY2l0eUF0dGVudWF0aW9uOiBtYWtlVW5pZm9ybSgnZicsIDEpLFxyXG4gICAgICAgICAgICBmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZDogbWFrZVVuaWZvcm0oJ2YnLCAwKSxcclxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGU6IG1ha2VVbmlmb3JtKCdmdicsIG5ldyBWZWN0b3IzKCkpLFxyXG4gICAgICAgICAgICBoaWdobGlnaHRlZFBvaW50Q29sb3I6IG1ha2VVbmlmb3JtKCdmdicsIERFRkFVTFRfSElHSExJR0hUX0NPTE9SLmNsb25lKCkpLFxyXG4gICAgICAgICAgICBlbmFibGVQb2ludEhpZ2hsaWdodGluZzogbWFrZVVuaWZvcm0oJ2InLCB0cnVlKSxcclxuICAgICAgICAgICAgaGlnaGxpZ2h0ZWRQb2ludFNjYWxlOiBtYWtlVW5pZm9ybSgnZicsIDIuMCksXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRNYXA6IG1ha2VVbmlmb3JtKCd0JywgbnVsbCksXHJcbiAgICAgICAgICAgIG5vcm1hbEZpbHRlcmluZ01vZGU6IG1ha2VVbmlmb3JtKCdpJywgTm9ybWFsRmlsdGVyaW5nTW9kZS5BQlNPTFVURV9OT1JNQUxfRklMVEVSSU5HX01PREUpLFxyXG4gICAgICAgICAgICBwb2ludENsb3VkSUQ6IG1ha2VVbmlmb3JtKCdmJywgMiksXHJcbiAgICAgICAgICAgIHBvaW50Q2xvdWRNaXhpbmdNb2RlOiBtYWtlVW5pZm9ybSgnaScsIFBvaW50Q2xvdWRNaXhpbmdNb2RlLkNIRUNLQk9BUkQpLFxyXG4gICAgICAgICAgICBzdHJpcGVEaXN0YW5jZVg6IG1ha2VVbmlmb3JtKCdmJywgNSksXHJcbiAgICAgICAgICAgIHN0cmlwZURpc3RhbmNlWTogbWFrZVVuaWZvcm0oJ2YnLCA1KSxcclxuICAgICAgICAgICAgc3RyaXBlRGl2aXNvclg6IG1ha2VVbmlmb3JtKCdmJywgMiksXHJcbiAgICAgICAgICAgIHN0cmlwZURpdmlzb3JZOiBtYWtlVW5pZm9ybSgnZicsIDIpLFxyXG4gICAgICAgICAgICBwb2ludENsb3VkTWl4QW5nbGU6IG1ha2VVbmlmb3JtKCdmJywgMzEpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51c2VDbGlwQm94ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy53ZWlnaHRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucG9pbnRDb2xvclR5cGUgPSBQb2ludENvbG9yVHlwZS5SR0I7XHJcbiAgICAgICAgdGhpcy5wb2ludFNpemVUeXBlID0gUG9pbnRTaXplVHlwZS5BREFQVElWRTtcclxuICAgICAgICB0aGlzLmNsaXBNb2RlID0gQ2xpcE1vZGUuRElTQUJMRUQ7XHJcbiAgICAgICAgdGhpcy51c2VFREwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNoYXBlID0gUG9pbnRTaGFwZS5TUVVBUkU7XHJcbiAgICAgICAgdGhpcy50cmVlVHlwZSA9IFRyZWVUeXBlLk9DVFJFRTtcclxuICAgICAgICB0aGlzLnBvaW50T3BhY2l0eVR5cGUgPSBQb2ludE9wYWNpdHlUeXBlLkZJWEVEO1xyXG4gICAgICAgIHRoaXMudXNlRmlsdGVyQnlOb3JtYWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVzZVRleHR1cmVCbGVuZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudXNlUG9pbnRDbG91ZE1peGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0UG9pbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiB7IHR5cGU6ICdmdicsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgICAgICBjb2xvcjogeyB0eXBlOiAnZnYnLCB2YWx1ZTogW10gfSxcclxuICAgICAgICAgICAgbm9ybWFsOiB7IHR5cGU6ICdmdicsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgICAgICBpbnRlbnNpdHk6IHsgdHlwZTogJ2YnLCB2YWx1ZTogW10gfSxcclxuICAgICAgICAgICAgY2xhc3NpZmljYXRpb246IHsgdHlwZTogJ2YnLCB2YWx1ZTogW10gfSxcclxuICAgICAgICAgICAgcmV0dXJuTnVtYmVyOiB7IHR5cGU6ICdmJywgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgICAgIG51bWJlck9mUmV0dXJuczogeyB0eXBlOiAnZicsIHZhbHVlOiBbXSB9LFxyXG4gICAgICAgICAgICBwb2ludFNvdXJjZUlEOiB7IHR5cGU6ICdmJywgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgICAgIGluZGljZXM6IHsgdHlwZTogJ2Z2JywgdmFsdWU6IFtdIH0sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCB0ZXggPSAodGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlID0gZ2VuZXJhdGVEYXRhVGV4dHVyZSgyMDQ4LCAxLCBuZXcgQ29sb3IoMHhmZmZmZmYpKSk7XHJcbiAgICAgICAgdGV4Lm1pbkZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcbiAgICAgICAgdGV4Lm1hZ0ZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCd2aXNpYmxlTm9kZXMnLCB0ZXgpO1xyXG4gICAgICAgIHRoaXMudHJlZVR5cGUgPSBnZXRWYWxpZChwYXJhbWV0ZXJzLnRyZWVUeXBlLCBUcmVlVHlwZS5PQ1RSRUUpO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IGdldFZhbGlkKHBhcmFtZXRlcnMuc2l6ZSwgMS4wKTtcclxuICAgICAgICB0aGlzLm1pblNpemUgPSBnZXRWYWxpZChwYXJhbWV0ZXJzLm1pblNpemUsIDIuMCk7XHJcbiAgICAgICAgdGhpcy5tYXhTaXplID0gZ2V0VmFsaWQocGFyYW1ldGVycy5tYXhTaXplLCA1MC4wKTtcclxuICAgICAgICB0aGlzLmNvbG9yUmdiYSA9IEJvb2xlYW4ocGFyYW1ldGVycy5jb2xvclJnYmEpO1xyXG4gICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb24gPSBERUZBVUxUX0NMQVNTSUZJQ0FUSU9OO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy5ub3JtYWwgPSBbMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzLmNsYXNzaWZpY2F0aW9uID0gWzAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcy5pbmRpY2VzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMudmVydGV4Q29sb3JzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlclNvdXJjZSgpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhZGllbnRUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRUZXh0dXJlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFRleHR1cmUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZpc2libGVOb2Rlc1RleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZXNUZXh0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNsZWFyVmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cygpO1xyXG4gICAgICAgIGlmICh0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzaWZpY2F0aW9uVGV4dHVyZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZXB0aE1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRoTWFwLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aE1hcCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZE1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXAuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRNYXAgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJWaXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzKCkge1xyXG4gICAgICAgIHRoaXMudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlU2hhZGVyU291cmNlKCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4U2hhZGVyID0gdGhpcy5hcHBseURlZmluZXMocmVxdWlyZSgnLi9zaGFkZXJzL3BvaW50Y2xvdWQudmVydCcpLmRlZmF1bHQpO1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmFwcGx5RGVmaW5lcyhyZXF1aXJlKCcuL3NoYWRlcnMvcG9pbnRjbG91ZC5mcmFnJykuZGVmYXVsdCk7XHJcbiAgICAgICAgaWYgKHRoaXMub3BhY2l0eSA9PT0gMS4wKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRpbmcgPSBOb0JsZW5kaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aFdyaXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcGFjaXR5IDwgMS4wICYmICF0aGlzLnVzZUVETCkge1xyXG4gICAgICAgICAgICB0aGlzLmJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcclxuICAgICAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLndlaWdodGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmxlbmRpbmcgPSBBZGRpdGl2ZUJsZW5kaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRoV3JpdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aEZ1bmMgPSBMZXNzRXF1YWxEZXB0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBhcHBseURlZmluZXMoc2hhZGVyU3JjKSB7XHJcbiAgICAgICAgY29uc3QgcGFydHMgPSBbXTtcclxuICAgICAgICBmdW5jdGlvbiBkZWZpbmUodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGAjZGVmaW5lICR7dmFsdWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmaW5lKFRSRUVfVFlQRV9ERUZTW3RoaXMudHJlZVR5cGVdKTtcclxuICAgICAgICBkZWZpbmUoU0laRV9UWVBFX0RFRlNbdGhpcy5wb2ludFNpemVUeXBlXSk7XHJcbiAgICAgICAgZGVmaW5lKFNIQVBFX0RFRlNbdGhpcy5zaGFwZV0pO1xyXG4gICAgICAgIGRlZmluZShDT0xPUl9ERUZTW3RoaXMucG9pbnRDb2xvclR5cGVdKTtcclxuICAgICAgICBkZWZpbmUoQ0xJUF9NT0RFX0RFRlNbdGhpcy5jbGlwTW9kZV0pO1xyXG4gICAgICAgIGRlZmluZShPUEFDSVRZX0RFRlNbdGhpcy5wb2ludE9wYWNpdHlUeXBlXSk7XHJcbiAgICAgICAgLy8gV2Ugb25seSBwZXJmb3JtIGdhbW1hIGFuZCBicmlnaHRuZXNzL2NvbnRyYXN0IGNhbGN1bGF0aW9ucyBwZXIgcG9pbnQgaWYgdmFsdWVzIGFyZSBzcGVjaWZpZWQuXHJcbiAgICAgICAgaWYgKHRoaXMucmdiR2FtbWEgIT09IERFRkFVTFRfUkdCX0dBTU1BIHx8XHJcbiAgICAgICAgICAgIHRoaXMucmdiQnJpZ2h0bmVzcyAhPT0gREVGQVVMVF9SR0JfQlJJR0hUTkVTUyB8fFxyXG4gICAgICAgICAgICB0aGlzLnJnYkNvbnRyYXN0ICE9PSBERUZBVUxUX1JHQl9DT05UUkFTVCkge1xyXG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV9yZ2JfZ2FtbWFfY29udHJhc3RfYnJpZ2h0bmVzcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy51c2VGaWx0ZXJCeU5vcm1hbCkge1xyXG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV9maWx0ZXJfYnlfbm9ybWFsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnVzZUVETCkge1xyXG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV9lZGwnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWQpIHtcclxuICAgICAgICAgICAgZGVmaW5lKCd3ZWlnaHRlZF9zcGxhdHMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubnVtQ2xpcEJveGVzID4gMCkge1xyXG4gICAgICAgICAgICBkZWZpbmUoJ3VzZV9jbGlwX2JveCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5oaWdobGlnaHRQb2ludCkge1xyXG4gICAgICAgICAgICBkZWZpbmUoJ2hpZ2hsaWdodF9wb2ludCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy51c2VUZXh0dXJlQmxlbmRpbmcpIHtcclxuICAgICAgICAgICAgZGVmaW5lKCd1c2VfdGV4dHVyZV9ibGVuZGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy51c2VQb2ludENsb3VkTWl4aW5nKSB7XHJcbiAgICAgICAgICAgIGRlZmluZSgndXNlX3BvaW50X2Nsb3VkX21peGluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jb2xvclJnYmEpIHtcclxuICAgICAgICAgICAgZGVmaW5lKCdjb2xvcl9yZ2JhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmluZSgnTUFYX1BPSU5UX0xJR0hUUyAwJyk7XHJcbiAgICAgICAgZGVmaW5lKCdNQVhfRElSX0xJR0hUUyAwJyk7XHJcbiAgICAgICAgcGFydHMucHVzaChzaGFkZXJTcmMpO1xyXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCdcXG4nKTtcclxuICAgIH1cclxuICAgIHNldFBvaW50Q2xvdWRNaXhpbmdNb2RlKG1vZGUpIHtcclxuICAgICAgICB0aGlzLnBvaW50Q2xvdWRNaXhpbmdNb2RlID0gbW9kZTtcclxuICAgIH1cclxuICAgIGdldFBvaW50Q2xvdWRNaXhpbmdNb2RlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBvaW50Q2xvdWRNaXhpbmdNb2RlID09PSBQb2ludENsb3VkTWl4aW5nTW9kZS5TVFJJUEVTKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQb2ludENsb3VkTWl4aW5nTW9kZS5TVFJJUEVTO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUG9pbnRDbG91ZE1peGluZ01vZGUuQ0hFQ0tCT0FSRDtcclxuICAgIH1cclxuICAgIHNldENsaXBCb3hlcyhjbGlwQm94ZXMpIHtcclxuICAgICAgICBpZiAoIWNsaXBCb3hlcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2xpcEJveGVzID0gY2xpcEJveGVzO1xyXG4gICAgICAgIGNvbnN0IGRvVXBkYXRlID0gdGhpcy5udW1DbGlwQm94ZXMgIT09IGNsaXBCb3hlcy5sZW5ndGggJiYgKGNsaXBCb3hlcy5sZW5ndGggPT09IDAgfHwgdGhpcy5udW1DbGlwQm94ZXMgPT09IDApO1xyXG4gICAgICAgIHRoaXMubnVtQ2xpcEJveGVzID0gY2xpcEJveGVzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2NsaXBCb3hDb3VudCcsIHRoaXMubnVtQ2xpcEJveGVzKTtcclxuICAgICAgICBpZiAoZG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTaGFkZXJTb3VyY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2xpcEJveGVzTGVuZ3RoID0gdGhpcy5udW1DbGlwQm94ZXMgKiAxNjtcclxuICAgICAgICBjb25zdCBjbGlwQm94ZXNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY2xpcEJveGVzTGVuZ3RoKTtcclxuICAgICAgICBjb25zdCBjbGlwQ29sb3JzTGVuZ3RoID0gdGhpcy5udW1DbGlwQm94ZXMgKiAzO1xyXG4gICAgICAgIGNvbnN0IGNsaXBDb2xvcnNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoY2xpcENvbG9yc0xlbmd0aCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm51bUNsaXBCb3hlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsaXBCb3hlc0FycmF5LnNldChjbGlwQm94ZXNbaV0uaW52ZXJzZS5lbGVtZW50cywgMTYgKiBpKTtcclxuICAgICAgICAgICAgY2xpcENvbG9yc0FycmF5LnNldCgoY2xpcEJveGVzW2ldLmNvbG9yIHx8IHRoaXMuY29sb3IpLnRvQXJyYXkoKSwgMyAqIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaXBCb3hlc0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihjbGlwQm94ZXNBcnJheVtpXSkpIHtcclxuICAgICAgICAgICAgICAgIGNsaXBCb3hlc0FycmF5W2ldID0gSW5maW5pdHk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGlwQm94ZXMnLCBjbGlwQm94ZXNBcnJheSk7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGlwSGlnaGxpZ2h0Q29sb3JzJywgY2xpcENvbG9yc0FycmF5KTtcclxuICAgIH1cclxuICAgIGdldCBncmFkaWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhZGllbnQ7XHJcbiAgICB9XHJcbiAgICBzZXQgZ3JhZGllbnQodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JhZGllbnQgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYWRpZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRUZXh0dXJlID0gZ2VuZXJhdGVHcmFkaWVudFRleHR1cmUodGhpcy5fZ3JhZGllbnQpO1xyXG4gICAgICAgICAgICB0aGlzLnNldFVuaWZvcm0oJ2dyYWRpZW50JywgdGhpcy5ncmFkaWVudFRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjbGFzc2lmaWNhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NpZmljYXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgY2xhc3NpZmljYXRpb24odmFsdWUpIHtcclxuICAgICAgICBjb25zdCBjb3B5ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IHZhbHVlW2tleV0uY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGlzRXF1YWwgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5fY2xhc3NpZmljYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpc0VxdWFsID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpc0VxdWFsID0gT2JqZWN0LmtleXMoY29weSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyh0aGlzLl9jbGFzc2lmaWNhdGlvbikubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb3B5KSkge1xyXG4gICAgICAgICAgICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgdGhpcy5fY2xhc3NpZmljYXRpb25ba2V5XSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgaXNFcXVhbCA9IGlzRXF1YWwgJiYgY29weVtrZXldLmVxdWFscyh0aGlzLl9jbGFzc2lmaWNhdGlvbltrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWlzRXF1YWwpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2xhc3NpZmljYXRpb24gPSBjb3B5O1xyXG4gICAgICAgICAgICB0aGlzLnJlY29tcHV0ZUNsYXNzaWZpY2F0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVjb21wdXRlQ2xhc3NpZmljYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jbGFzc2lmaWNhdGlvblRleHR1cmUgPSBnZW5lcmF0ZUNsYXNzaWZpY2F0aW9uVGV4dHVyZSh0aGlzLl9jbGFzc2lmaWNhdGlvbik7XHJcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKCdjbGFzc2lmaWNhdGlvbkxVVCcsIHRoaXMuY2xhc3NpZmljYXRpb25UZXh0dXJlKTtcclxuICAgIH1cclxuICAgIGdldCBlbGV2YXRpb25SYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuaGVpZ2h0TWluLCB0aGlzLmhlaWdodE1heF07XHJcbiAgICB9XHJcbiAgICBzZXQgZWxldmF0aW9uUmFuZ2UodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmhlaWdodE1pbiA9IHZhbHVlWzBdO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0TWF4ID0gdmFsdWVbMV07XHJcbiAgICB9XHJcbiAgICBnZXRVbmlmb3JtKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3JtcyA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZTtcclxuICAgIH1cclxuICAgIHNldFVuaWZvcm0obmFtZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy51bmlmb3JtcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdU9iaiA9IHRoaXMudW5pZm9ybXNbbmFtZV07XHJcbiAgICAgICAgaWYgKHVPYmoudHlwZSA9PT0gJ2MnKSB7XHJcbiAgICAgICAgICAgIHVPYmoudmFsdWUuY29weSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1T2JqLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHVPYmoudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVNYXRlcmlhbChvY3RyZWUsIHZpc2libGVOb2RlcywgY2FtZXJhLCByZW5kZXJlcikge1xyXG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSByZW5kZXJlci5nZXRQaXhlbFJhdGlvKCk7XHJcbiAgICAgICAgaWYgKGNhbWVyYS50eXBlID09PSBQRVJTUEVDVElWRV9DQU1FUkEpIHtcclxuICAgICAgICAgICAgdGhpcy5mb3YgPSBjYW1lcmEuZm92ICogKE1hdGguUEkgLyAxODApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5mb3YgPSBNYXRoLlBJIC8gMjsgLy8gd2lsbCByZXN1bHQgaW4gc2xvcGUgPSAxIGluIHRoZSBzaGFkZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyVGFyZ2V0KCk7XHJcbiAgICAgICAgaWYgKHJlbmRlclRhcmdldCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbldpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbkhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbldpZHRoID0gcmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRXaWR0aCAqIHBpeGVsUmF0aW87XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuSGVpZ2h0ID0gcmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKiBwaXhlbFJhdGlvO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy51c2VEcmF3aW5nQnVmZmVyU2l6ZSkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5nZXREcmF3aW5nQnVmZmVyU2l6ZShQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMik7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuV2lkdGggPSBQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMi53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW5IZWlnaHQgPSBQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMi5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG1heFNjYWxlID0gTWF0aC5tYXgob2N0cmVlLnNjYWxlLngsIG9jdHJlZS5zY2FsZS55LCBvY3RyZWUuc2NhbGUueik7XHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gb2N0cmVlLnBjb0dlb21ldHJ5LnNwYWNpbmcgKiBtYXhTY2FsZTtcclxuICAgICAgICB0aGlzLm9jdHJlZVNpemUgPSBvY3RyZWUucGNvR2VvbWV0cnkuYm91bmRpbmdCb3guZ2V0U2l6ZShQb2ludENsb3VkTWF0ZXJpYWwuaGVscGVyVmVjMykueDtcclxuICAgICAgICBpZiAodGhpcy5wb2ludFNpemVUeXBlID09PSBQb2ludFNpemVUeXBlLkFEQVBUSVZFIHx8XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRDb2xvclR5cGUgPT09IFBvaW50Q29sb3JUeXBlLkxPRCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHlUZXh0dXJlRGF0YSh2aXNpYmxlTm9kZXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZVZpc2liaWxpdHlUZXh0dXJlRGF0YShub2Rlcykge1xyXG4gICAgICAgIG5vZGVzLnNvcnQoYnlMZXZlbEFuZEluZGV4KTtcclxuICAgICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobm9kZXMubGVuZ3RoICogNCk7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0c1RvQ2hpbGQgPSBuZXcgQXJyYXkobm9kZXMubGVuZ3RoKS5maWxsKEluZmluaXR5KTtcclxuICAgICAgICB0aGlzLnZpc2libGVOb2RlVGV4dHVyZU9mZnNldHMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLnNldChub2RlLm5hbWUsIGkpO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE5hbWUgPSBub2RlLm5hbWUuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50T2Zmc2V0ID0gdGhpcy52aXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzLmdldChwYXJlbnROYW1lKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudE9mZnNldFRvQ2hpbGQgPSBpIC0gcGFyZW50T2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1RvQ2hpbGRbcGFyZW50T2Zmc2V0XSA9IE1hdGgubWluKG9mZnNldHNUb0NoaWxkW3BhcmVudE9mZnNldF0sIHBhcmVudE9mZnNldFRvQ2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGU6bm8tYml0d2lzZVxyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcGFyZW50T2Zmc2V0ICogNDtcclxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGRhdGFbb2Zmc2V0XSB8ICgxIDw8IG5vZGUuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YVtvZmZzZXQgKyAxXSA9IG9mZnNldHNUb0NoaWxkW3BhcmVudE9mZnNldF0gPj4gODtcclxuICAgICAgICAgICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBvZmZzZXRzVG9DaGlsZFtwYXJlbnRPZmZzZXRdICUgMjU2O1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmVuYWJsZTpuby1iaXR3aXNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YVtpICogNCArIDNdID0gbm9kZS5uYW1lLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMudmlzaWJsZU5vZGVzVGV4dHVyZTtcclxuICAgICAgICBpZiAodGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlLmRhdGEuc2V0KGRhdGEpO1xyXG4gICAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWFrZU9uQmVmb3JlUmVuZGVyKG9jdHJlZSwgbm9kZSwgcGNJbmRleCkge1xyXG4gICAgICAgIHJldHVybiAoX3JlbmRlcmVyLCBfc2NlbmUsIF9jYW1lcmEsIF9nZW9tZXRyeSwgbWF0ZXJpYWwpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZE1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsVW5pZm9ybXMgPSBwb2ludENsb3VkTWF0ZXJpYWwudW5pZm9ybXM7XHJcbiAgICAgICAgICAgIG1hdGVyaWFsVW5pZm9ybXMubGV2ZWwudmFsdWUgPSBub2RlLmxldmVsO1xyXG4gICAgICAgICAgICBtYXRlcmlhbFVuaWZvcm1zLmlzTGVhZk5vZGUudmFsdWUgPSBub2RlLmlzTGVhZk5vZGU7XHJcbiAgICAgICAgICAgIGNvbnN0IHZuU3RhcnQgPSBwb2ludENsb3VkTWF0ZXJpYWwudmlzaWJsZU5vZGVUZXh0dXJlT2Zmc2V0cy5nZXQobm9kZS5uYW1lKTtcclxuICAgICAgICAgICAgaWYgKHZuU3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgbWF0ZXJpYWxVbmlmb3Jtcy52blN0YXJ0LnZhbHVlID0gdm5TdGFydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtYXRlcmlhbFVuaWZvcm1zLnBjSW5kZXgudmFsdWUgPVxyXG4gICAgICAgICAgICAgICAgcGNJbmRleCAhPT0gdW5kZWZpbmVkID8gcGNJbmRleCA6IG9jdHJlZS52aXNpYmxlTm9kZXMuaW5kZXhPZihub2RlKTtcclxuICAgICAgICAgICAgLy8gTm90ZTogd2hlbiBjaGFuZ2luZyB1bmlmb3JtcyBpbiBvbkJlZm9yZVJlbmRlciwgdGhlIGZsYWcgdW5pZm9ybXNOZWVkVXBkYXRlIGhhcyB0byBiZVxyXG4gICAgICAgICAgICAvLyBzZXQgdG8gdHJ1ZSB0byBpbnN0cnVjdCBUaHJlZUpTIHRvIHVwbG9hZCB0aGVtLiBTZWUgYWxzb1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy85ODcwI2lzc3VlY29tbWVudC0zNjg3NTAxODIuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgY2FzdCB0byBhbnkgYWZ0ZXIgdXBkYXRpbmcgdG8gVGhyZWUuSlMgPj0gcjExM1xyXG4gICAgICAgICAgICBtYXRlcmlhbCAvKlNoYWRlck1hdGVyaWFsKi8udW5pZm9ybXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcblBvaW50Q2xvdWRNYXRlcmlhbC5oZWxwZXJWZWMzID0gbmV3IFZlY3RvcjMoKTtcclxuUG9pbnRDbG91ZE1hdGVyaWFsLmhlbHBlclZlYzIgPSBuZXcgVmVjdG9yMigpO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2JiU2l6ZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiYmJTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnY2xpcEV4dGVudCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiY2xpcEV4dGVudFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2RlcHRoTWFwJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJkZXB0aE1hcFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2ZvdicpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZm92XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnaGVpZ2h0TWF4JylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJoZWlnaHRNYXhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdoZWlnaHRNaW4nKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhlaWdodE1pblwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2ludGVuc2l0eUJyaWdodG5lc3MnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImludGVuc2l0eUJyaWdodG5lc3NcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlDb250cmFzdCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5Q29udHJhc3RcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlHYW1tYScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5R2FtbWFcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdpbnRlbnNpdHlSYW5nZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaW50ZW5zaXR5UmFuZ2VcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdtYXhTaXplJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnbWluU2l6ZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwibWluU2l6ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ29jdHJlZVNpemUnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIm9jdHJlZVNpemVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdvcGFjaXR5JywgdHJ1ZSlcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgncmdiQnJpZ2h0bmVzcycsIHRydWUpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwicmdiQnJpZ2h0bmVzc1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3JnYkNvbnRyYXN0JywgdHJ1ZSlcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJyZ2JDb250cmFzdFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3JnYkdhbW1hJywgdHJ1ZSlcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJyZ2JHYW1tYVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3NjcmVlbkhlaWdodCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic2NyZWVuSGVpZ2h0XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnc2NyZWVuV2lkdGgnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNjcmVlbldpZHRoXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnc2l6ZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3NwYWNpbmcnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd0cmFuc2l0aW9uJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ0cmFuc2l0aW9uXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgndUNvbG9yJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3dDbGFzc2lmaWNhdGlvbicpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwid2VpZ2h0Q2xhc3NpZmljYXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd3RWxldmF0aW9uJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRFbGV2YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd3SW50ZW5zaXR5JylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRJbnRlbnNpdHlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd3UmV0dXJuTnVtYmVyJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRSZXR1cm5OdW1iZXJcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd3UkdCJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ3ZWlnaHRSR0JcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCd3U291cmNlSUQnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIndlaWdodFNvdXJjZUlEXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnb3BhY2l0eUF0dGVudWF0aW9uJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJvcGFjaXR5QXR0ZW51YXRpb25cIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdmaWx0ZXJCeU5vcm1hbFRocmVzaG9sZCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiZmlsdGVyQnlOb3JtYWxUaHJlc2hvbGRcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdoaWdobGlnaHRlZFBvaW50Q29vcmRpbmF0ZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0ZWRQb2ludENvb3JkaW5hdGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdoaWdobGlnaHRlZFBvaW50Q29sb3InKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImhpZ2hsaWdodGVkUG9pbnRDb2xvclwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2VuYWJsZVBvaW50SGlnaGxpZ2h0aW5nJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJlbmFibGVQb2ludEhpZ2hsaWdodGluZ1wiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2hpZ2hsaWdodGVkUG9pbnRTY2FsZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0ZWRQb2ludFNjYWxlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnbm9ybWFsRmlsdGVyaW5nTW9kZScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwibm9ybWFsRmlsdGVyaW5nTW9kZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ2JhY2tncm91bmRNYXAnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcImJhY2tncm91bmRNYXBcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdwb2ludENsb3VkSUQnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q2xvdWRJRFwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3BvaW50Q2xvdWRNaXhpbmdNb2RlJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJwb2ludENsb3VkTWl4aW5nTW9kZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHVuaWZvcm0oJ3N0cmlwZURpc3RhbmNlWCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGlzdGFuY2VYXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgdW5pZm9ybSgnc3RyaXBlRGlzdGFuY2VZJylcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJzdHJpcGVEaXN0YW5jZVlcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdzdHJpcGVEaXZpc29yWCcpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGl2aXNvclhcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdzdHJpcGVEaXZpc29yWScpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwic3RyaXBlRGl2aXNvcllcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICB1bmlmb3JtKCdwb2ludENsb3VkTWl4QW5nbGUnKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q2xvdWRNaXhBbmdsZVwiLCB2b2lkIDApO1xyXG5fX2RlY29yYXRlKFtcclxuICAgIHJlcXVpcmVzU2hhZGVyVXBkYXRlKClcclxuXSwgUG9pbnRDbG91ZE1hdGVyaWFsLnByb3RvdHlwZSwgXCJ1c2VDbGlwQm94XCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcIndlaWdodGVkXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50Q29sb3JUeXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50U2l6ZVR5cGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiY2xpcE1vZGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlRURMXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInNoYXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInRyZWVUeXBlXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInBvaW50T3BhY2l0eVR5cGVcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlRmlsdGVyQnlOb3JtYWxcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwidXNlVGV4dHVyZUJsZW5kaW5nXCIsIHZvaWQgMCk7XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgcmVxdWlyZXNTaGFkZXJVcGRhdGUoKVxyXG5dLCBQb2ludENsb3VkTWF0ZXJpYWwucHJvdG90eXBlLCBcInVzZVBvaW50Q2xvdWRNaXhpbmdcIiwgdm9pZCAwKTtcclxuX19kZWNvcmF0ZShbXHJcbiAgICByZXF1aXJlc1NoYWRlclVwZGF0ZSgpXHJcbl0sIFBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0UG9pbnRcIiwgdm9pZCAwKTtcclxuZnVuY3Rpb24gbWFrZVVuaWZvcm0odHlwZSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7IHR5cGUsIHZhbHVlIH07XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmFsaWQoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPT09IHVuZGVmaW5lZCA/IGIgOiBhO1xyXG59XHJcbi8vIHRzbGludDpkaXNhYmxlOm5vLWludmFsaWQtdGhpc1xyXG5mdW5jdGlvbiB1bmlmb3JtKHVuaWZvcm1OYW1lLCByZXF1aXJlU3JjVXBkYXRlID0gZmFsc2UpIHtcclxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5LCB7XHJcbiAgICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFVuaWZvcm0odW5pZm9ybU5hbWUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXQodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5nZXRVbmlmb3JtKHVuaWZvcm1OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybSh1bmlmb3JtTmFtZSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlU3JjVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyU291cmNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiByZXF1aXJlc1NoYWRlclVwZGF0ZSgpIHtcclxuICAgIHJldHVybiAodGFyZ2V0LCBwcm9wZXJ0eUtleSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IGBfJHtwcm9wZXJ0eUtleS50b1N0cmluZygpfWA7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIHtcclxuICAgICAgICAgICAgZ2V0KCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGROYW1lXTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXNbZmllbGROYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNbZmllbGROYW1lXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyU291cmNlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbiIsImV4cG9ydCAqIGZyb20gJy4vYmx1ci1tYXRlcmlhbCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vY2xpcHBpbmcnO1xyXG5leHBvcnQgKiBmcm9tICcuL2VudW1zJztcclxuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1tYXRlcmlhbCc7XHJcbmV4cG9ydCAqIGZyb20gJy4vdGV4dHVyZS1nZW5lcmF0aW9uJztcclxuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XHJcbmV4cG9ydCAqIGZyb20gJy4vZ3JhZGllbnRzJztcclxuIiwiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuZXhwb3J0IHZhciBQb2ludEF0dHJpYnV0ZU5hbWU7XHJcbihmdW5jdGlvbiAoUG9pbnRBdHRyaWJ1dGVOYW1lKSB7XHJcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiUE9TSVRJT05fQ0FSVEVTSUFOXCJdID0gMF0gPSBcIlBPU0lUSU9OX0NBUlRFU0lBTlwiO1xyXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNPTE9SX1BBQ0tFRFwiXSA9IDFdID0gXCJDT0xPUl9QQUNLRURcIjtcclxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJDT0xPUl9GTE9BVFNfMVwiXSA9IDJdID0gXCJDT0xPUl9GTE9BVFNfMVwiO1xyXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkNPTE9SX0ZMT0FUU18yNTVcIl0gPSAzXSA9IFwiQ09MT1JfRkxPQVRTXzI1NVwiO1xyXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIk5PUk1BTF9GTE9BVFNcIl0gPSA0XSA9IFwiTk9STUFMX0ZMT0FUU1wiO1xyXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcIkZJTExFUlwiXSA9IDVdID0gXCJGSUxMRVJcIjtcclxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJJTlRFTlNJVFlcIl0gPSA2XSA9IFwiSU5URU5TSVRZXCI7XHJcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiQ0xBU1NJRklDQVRJT05cIl0gPSA3XSA9IFwiQ0xBU1NJRklDQVRJT05cIjtcclxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJOT1JNQUxfU1BIRVJFTUFQUEVEXCJdID0gOF0gPSBcIk5PUk1BTF9TUEhFUkVNQVBQRURcIjtcclxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXCJOT1JNQUxfT0NUMTZcIl0gPSA5XSA9IFwiTk9STUFMX09DVDE2XCI7XHJcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1wiTk9STUFMXCJdID0gMTBdID0gXCJOT1JNQUxcIjtcclxufSkoUG9pbnRBdHRyaWJ1dGVOYW1lIHx8IChQb2ludEF0dHJpYnV0ZU5hbWUgPSB7fSkpO1xyXG5leHBvcnQgY29uc3QgUE9JTlRfQVRUUklCVVRFX1RZUEVTID0ge1xyXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBzaXplOiA4IH0sXHJcbiAgICBEQVRBX1RZUEVfRkxPQVQ6IHsgb3JkaW5hbDogMSwgc2l6ZTogNCB9LFxyXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgc2l6ZTogMSB9LFxyXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIHNpemU6IDEgfSxcclxuICAgIERBVEFfVFlQRV9JTlQxNjogeyBvcmRpbmFsOiA0LCBzaXplOiAyIH0sXHJcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIHNpemU6IDIgfSxcclxuICAgIERBVEFfVFlQRV9JTlQzMjogeyBvcmRpbmFsOiA2LCBzaXplOiA0IH0sXHJcbiAgICBEQVRBX1RZUEVfVUlOVDMyOiB7IG9yZGluYWw6IDcsIHNpemU6IDQgfSxcclxuICAgIERBVEFfVFlQRV9JTlQ2NDogeyBvcmRpbmFsOiA4LCBzaXplOiA4IH0sXHJcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIHNpemU6IDggfSxcclxufTtcclxuZnVuY3Rpb24gbWFrZVBvaW50QXR0cmlidXRlKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBudW1FbGVtZW50cyxcclxuICAgICAgICBieXRlU2l6ZTogbnVtRWxlbWVudHMgKiB0eXBlLnNpemUsXHJcbiAgICB9O1xyXG59XHJcbmNvbnN0IFJHQkFfUEFDS0VEID0gbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfSU5UOCwgNCk7XHJcbmV4cG9ydCBjb25zdCBQT0lOVF9BVFRSSUJVVEVTID0ge1xyXG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLlBPU0lUSU9OX0NBUlRFU0lBTiwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXHJcbiAgICBSR0JBX1BBQ0tFRCxcclxuICAgIENPTE9SX1BBQ0tFRDogUkdCQV9QQUNLRUQsXHJcbiAgICBSR0JfUEFDS0VEOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9JTlQ4LCAzKSxcclxuICAgIE5PUk1BTF9GTE9BVFM6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX0ZMT0FUUywgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXHJcbiAgICBGSUxMRVJfMUI6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuRklMTEVSLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcclxuICAgIElOVEVOU0lUWTogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5JTlRFTlNJVFksIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcclxuICAgIENMQVNTSUZJQ0FUSU9OOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcclxuICAgIE5PUk1BTF9TUEhFUkVNQVBQRUQ6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX1NQSEVSRU1BUFBFRCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UOCwgMiksXHJcbiAgICBOT1JNQUxfT0NUMTY6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2LCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcclxuICAgIE5PUk1BTDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUwsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxyXG59O1xyXG5leHBvcnQgY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50QXR0cmlidXRlTmFtZXMgPSBbXSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludEF0dHJpYnV0ZU5hbWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlTmFtZSA9IHBvaW50QXR0cmlidXRlTmFtZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlID0gUE9JTlRfQVRUUklCVVRFU1twb2ludEF0dHJpYnV0ZU5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChwb2ludEF0dHJpYnV0ZSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcclxuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgaGFzQ29sb3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuZmluZChpc0NvbG9yQXR0cmlidXRlKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgaGFzTm9ybWFscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoaXNOb3JtYWxBdHRyaWJ1dGUpICE9PSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNDb2xvckF0dHJpYnV0ZSh7IG5hbWUgfSkge1xyXG4gICAgcmV0dXJuIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQ7XHJcbn1cclxuZnVuY3Rpb24gaXNOb3JtYWxBdHRyaWJ1dGUoeyBuYW1lIH0pIHtcclxuICAgIHJldHVybiAobmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9TUEhFUkVNQVBQRUQgfHxcclxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX0ZMT0FUUyB8fFxyXG4gICAgICAgIG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUwgfHxcclxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2KTtcclxufVxyXG4iLCJpbXBvcnQgeyBCb3gzLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xyXG4vKipcclxuICogYWRhcHRlZCBmcm9tIG1obHVza2EgYXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTU2MVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KGJveCwgdHJhbnNmb3JtKSB7XHJcbiAgICByZXR1cm4gbmV3IEJveDMoKS5zZXRGcm9tUG9pbnRzKFtcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5tYXgueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWluLngsIGJveC5tYXgueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1pbi56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgICAgICBuZXcgVmVjdG9yMyhib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1heC56KS5hcHBseU1hdHJpeDQodHJhbnNmb3JtKSxcclxuICAgIF0pO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaGlsZEFBQkIoYWFiYiwgaW5kZXgpIHtcclxuICAgIGNvbnN0IG1pbiA9IGFhYmIubWluLmNsb25lKCk7XHJcbiAgICBjb25zdCBtYXggPSBhYWJiLm1heC5jbG9uZSgpO1xyXG4gICAgY29uc3Qgc2l6ZSA9IG5ldyBWZWN0b3IzKCkuc3ViVmVjdG9ycyhtYXgsIG1pbik7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgaWYgKChpbmRleCAmIDBiMDAwMSkgPiAwKSB7XHJcbiAgICAgICAgbWluLnogKz0gc2l6ZS56IC8gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1heC56IC09IHNpemUueiAvIDI7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgaWYgKChpbmRleCAmIDBiMDAxMCkgPiAwKSB7XHJcbiAgICAgICAgbWluLnkgKz0gc2l6ZS55IC8gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1heC55IC09IHNpemUueSAvIDI7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYml0d2lzZVxyXG4gICAgaWYgKChpbmRleCAmIDBiMDEwMCkgPiAwKSB7XHJcbiAgICAgICAgbWluLnggKz0gc2l6ZS54IC8gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1heC54IC09IHNpemUueCAvIDI7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEJveDMobWluLCBtYXgpO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBBZGFwdGVkIGZyb20gUG90cmVlLmpzIGh0dHA6Ly9wb3RyZWUub3JnXHJcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXHJcbiAqL1xyXG5pbXBvcnQgeyBFdmVudERpc3BhdGNoZXIsIFNwaGVyZSwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgY3JlYXRlQ2hpbGRBQUJCIH0gZnJvbSAnLi91dGlscy9ib3VuZHMnO1xyXG5pbXBvcnQgeyBnZXRJbmRleEZyb21OYW1lLCBoYW5kbGVFbXB0eUJ1ZmZlciwgaGFuZGxlRmFpbGVkUmVxdWVzdCB9IGZyb20gJy4vdXRpbHMvdXRpbHMnO1xyXG5jb25zdCBOT0RFX1NUUklERSA9IDU7XHJcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBjb0dlb21ldHJ5LCBib3VuZGluZ0JveCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUuaWRDb3VudCsrO1xyXG4gICAgICAgIHRoaXMubGV2ZWwgPSAwO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XHJcbiAgICAgICAgdGhpcy5oYXNDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgICAgIG51bGwsXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLm1lYW4gPSBuZXcgVmVjdG9yMygpO1xyXG4gICAgICAgIHRoaXMubnVtUG9pbnRzID0gMDtcclxuICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNMZWFmTm9kZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc1RyZWVOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0dlb21ldHJ5Tm9kZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gZ2V0SW5kZXhGcm9tTmFtZShuYW1lKTtcclxuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5ID0gcGNvR2VvbWV0cnk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xyXG4gICAgICAgIHRoaXMudGlnaHRCb3VuZGluZ0JveCA9IGJvdW5kaW5nQm94LmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nQm94LmdldEJvdW5kaW5nU3BoZXJlKG5ldyBTcGhlcmUoKSk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5nZW9tZXRyeSB8fCAhdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzLmZvckVhY2goaGFuZGxlciA9PiBoYW5kbGVyKCkpO1xyXG4gICAgICAgIHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB1cmwgb2YgdGhlIGJpbmFyeSBmaWxlIGZvciB0aGlzIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIGdldFVybCgpIHtcclxuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IHRoaXMucGNvR2VvbWV0cnk7XHJcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9IGdlb21ldHJ5LmxvYWRlci52ZXJzaW9uO1xyXG4gICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IFtnZW9tZXRyeS5vY3RyZWVEaXJdO1xyXG4gICAgICAgIGlmIChnZW9tZXRyeS5sb2FkZXIgJiYgdmVyc2lvbi5lcXVhbE9ySGlnaGVyKCcxLjUnKSkge1xyXG4gICAgICAgICAgICBwYXRoUGFydHMucHVzaCh0aGlzLmdldEhpZXJhcmNoeUJhc2VVcmwoKSk7XHJcbiAgICAgICAgICAgIHBhdGhQYXJ0cy5wdXNoKHRoaXMubmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZlcnNpb24uZXF1YWxPckhpZ2hlcignMS40JykpIHtcclxuICAgICAgICAgICAgcGF0aFBhcnRzLnB1c2godGhpcy5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmVyc2lvbi51cFRvKCcxLjMnKSkge1xyXG4gICAgICAgICAgICBwYXRoUGFydHMucHVzaCh0aGlzLm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGF0aFBhcnRzLmpvaW4oJy8nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdXJsIG9mIHRoZSBoaWVyYXJjaHkgZmlsZSBmb3IgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBnZXRIaWVyYXJjaHlVcmwoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucGNvR2VvbWV0cnkub2N0cmVlRGlyfS8ke3RoaXMuZ2V0SGllcmFyY2h5QmFzZVVybCgpfS8ke3RoaXMubmFtZX0uaHJjYDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyB0aGUgc3BlY2lmaWVkIG5vZGUgYXMgYSBjaGlsZCBvZiB0aGUgY3VycmVudCBub2RlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjaGlsZFxyXG4gICAgICogICAgVGhlIG5vZGUgd2hpY2ggaXMgdG8gYmUgYWRkZWQgYXMgYSBjaGlsZC5cclxuICAgICAqL1xyXG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuW2NoaWxkLmluZGV4XSA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMuaXNMZWFmTm9kZSA9IGZhbHNlO1xyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxzIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgZm9yIHRoZSBjdXJyZW50IG5vZGUgKGlmIGluY2x1ZGVTZWxmIGlzIHNldCB0byB0cnVlKSBhbmQgYWxsIGl0c1xyXG4gICAgICogY2hpbGRyZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNiXHJcbiAgICAgKiAgICBUaGUgZnVuY3Rpb24gd2hpY2ggaXMgdG8gYmUgY2FsbGVkIGZvciBlYWNoIG5vZGUuXHJcbiAgICAgKi9cclxuICAgIHRyYXZlcnNlKGNiLCBpbmNsdWRlU2VsZiA9IHRydWUpIHtcclxuICAgICAgICBjb25zdCBzdGFjayA9IGluY2x1ZGVTZWxmID8gW3RoaXNdIDogW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKChjdXJyZW50ID0gc3RhY2sucG9wKCkpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY2IoY3VycmVudCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY3VycmVudC5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jYW5Mb2FkKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nKys7XHJcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgbGV0IHByb21pc2U7XHJcbiAgICAgICAgaWYgKHRoaXMucGNvR2VvbWV0cnkubG9hZGVyLnZlcnNpb24uZXF1YWxPckhpZ2hlcignMS41JykgJiZcclxuICAgICAgICAgICAgdGhpcy5sZXZlbCAlIHRoaXMucGNvR2VvbWV0cnkuaGllcmFyY2h5U3RlcFNpemUgPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5oYXNDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5sb2FkSGllcmFjaHlUaGVuUG9pbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwcm9taXNlID0gdGhpcy5sb2FkUG9pbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcm9taXNlLmNhdGNoKHJlYXNvbiA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMucGNvR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nLS07XHJcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGNhbkxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5sb2FkaW5nICYmXHJcbiAgICAgICAgICAgICF0aGlzLmxvYWRlZCAmJlxyXG4gICAgICAgICAgICAhdGhpcy5wY29HZW9tZXRyeS5kaXNwb3NlZCAmJlxyXG4gICAgICAgICAgICAhdGhpcy5wY29HZW9tZXRyeS5sb2FkZXIuZGlzcG9zZWQgJiZcclxuICAgICAgICAgICAgdGhpcy5wY29HZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcgPCB0aGlzLnBjb0dlb21ldHJ5Lm1heE51bU5vZGVzTG9hZGluZyk7XHJcbiAgICB9XHJcbiAgICBsb2FkUG9pbnRzKCkge1xyXG4gICAgICAgIHRoaXMucGNvR2VvbWV0cnkubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBjb0dlb21ldHJ5LmxvYWRlci5sb2FkKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgbG9hZEhpZXJhY2h5VGhlblBvaW50cygpIHtcclxuICAgICAgICBpZiAodGhpcy5sZXZlbCAlIHRoaXMucGNvR2VvbWV0cnkuaGllcmFyY2h5U3RlcFNpemUgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucGNvR2VvbWV0cnkubG9hZGVyLmdldFVybCh0aGlzLmdldEhpZXJhcmNoeVVybCgpKSlcclxuICAgICAgICAgICAgLnRoZW4odXJsID0+IHRoaXMucGNvR2VvbWV0cnkueGhyUmVxdWVzdCh1cmwsIHsgbW9kZTogJ2NvcnMnIH0pKVxyXG4gICAgICAgICAgICAudGhlbihyZXMgPT4gaGFuZGxlRmFpbGVkUmVxdWVzdChyZXMpKVxyXG4gICAgICAgICAgICAudGhlbihva1JlcyA9PiBva1Jlcy5hcnJheUJ1ZmZlcigpKVxyXG4gICAgICAgICAgICAudGhlbihidWZmZXIgPT4gaGFuZGxlRW1wdHlCdWZmZXIoYnVmZmVyKSlcclxuICAgICAgICAgICAgLnRoZW4ob2tCdWZmZXIgPT4gdGhpcy5sb2FkSGllcmFyY2h5KHRoaXMsIG9rQnVmZmVyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHVybCBvZiB0aGUgZm9sZGVyIHdoZXJlIHRoZSBoaWVyYXJjaHkgaXMsIHJlbGF0aXZlIHRvIHRoZSBvY3RyZWVEaXIuXHJcbiAgICAgKi9cclxuICAgIGdldEhpZXJhcmNoeUJhc2VVcmwoKSB7XHJcbiAgICAgICAgY29uc3QgaGllcmFyY2h5U3RlcFNpemUgPSB0aGlzLnBjb0dlb21ldHJ5LmhpZXJhcmNoeVN0ZXBTaXplO1xyXG4gICAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLm5hbWUuc3Vic3RyKDEpO1xyXG4gICAgICAgIGNvbnN0IG51bVBhcnRzID0gTWF0aC5mbG9vcihpbmRpY2VzLmxlbmd0aCAvIGhpZXJhcmNoeVN0ZXBTaXplKTtcclxuICAgICAgICBsZXQgcGF0aCA9ICdyLyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QYXJ0czsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBhdGggKz0gYCR7aW5kaWNlcy5zdWJzdHIoaSAqIGhpZXJhcmNoeVN0ZXBTaXplLCBoaWVyYXJjaHlTdGVwU2l6ZSl9L2A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcclxuICAgIH1cclxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcclxuICAgIGxvYWRIaWVyYXJjaHkobm9kZSwgYnVmZmVyKSB7XHJcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0Tm9kZURhdGEgPSB0aGlzLmdldE5vZGVEYXRhKG5vZGUubmFtZSwgMCwgdmlldyk7XHJcbiAgICAgICAgbm9kZS5udW1Qb2ludHMgPSBmaXJzdE5vZGVEYXRhLm51bVBvaW50cztcclxuICAgICAgICAvLyBOb2RlcyB3aGljaCBuZWVkIGJlIHZpc2l0ZWQuXHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbZmlyc3ROb2RlRGF0YV07XHJcbiAgICAgICAgLy8gTm9kZXMgd2hpY2ggaGF2ZSBhbHJlYWR5IGJlZW4gZGVjb2RlZC4gV2Ugd2lsbCB0YWtlIG5vZGVzIGZyb20gdGhlIHN0YWNrIGFuZCBwbGFjZSB0aGVtIGhlcmUuXHJcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IFtdO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSBOT0RFX1NUUklERTtcclxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFja05vZGVEYXRhID0gc3RhY2suc2hpZnQoKTtcclxuICAgICAgICAgICAgLy8gRnJvbSB0aGUgbGFzdCBiaXQsIGFsbCB0aGUgd2F5IHRvIHRoZSA4dGggb25lIGZyb20gdGhlIHJpZ2h0LlxyXG4gICAgICAgICAgICBsZXQgbWFzayA9IDE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOCAmJiBvZmZzZXQgKyAxIDwgYnVmZmVyLmJ5dGVMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKChzdGFja05vZGVEYXRhLmNoaWxkcmVuICYgbWFzaykgIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuZ2V0Tm9kZURhdGEoc3RhY2tOb2RlRGF0YS5uYW1lICsgaSwgb2Zmc2V0LCB2aWV3KTtcclxuICAgICAgICAgICAgICAgICAgICBkZWNvZGVkLnB1c2gobm9kZURhdGEpOyAvLyBOb2RlIGlzIGRlY29kZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaChub2RlRGF0YSk7IC8vIE5lZWQgdG8gY2hlY2sgaXRzIGNoaWxkcmVuLlxyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBOT0RFX1NUUklERTsgLy8gTW92ZSBvdmVyIHRvIHRoZSBuZXh0IG5vZGUgaW4gdGhlIGJ1ZmZlci5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrICogMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLnBjb0dlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAvLyBNYXAgY29udGFpbmluZyBhbGwgdGhlIG5vZGVzLlxyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIG5vZGVzLnNldChub2RlLm5hbWUsIG5vZGUpO1xyXG4gICAgICAgIGRlY29kZWQuZm9yRWFjaChub2RlRGF0YSA9PiB0aGlzLmFkZE5vZGUobm9kZURhdGEsIG5vZGUucGNvR2VvbWV0cnksIG5vZGVzKSk7XHJcbiAgICAgICAgbm9kZS5sb2FkUG9pbnRzKCk7XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZW5hYmxlOm5vLWJpdHdpc2VcclxuICAgIGdldE5vZGVEYXRhKG5hbWUsIG9mZnNldCwgdmlldykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gdmlldy5nZXRVaW50OChvZmZzZXQpO1xyXG4gICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDEsIHRydWUpO1xyXG4gICAgICAgIHJldHVybiB7IGNoaWxkcmVuOiBjaGlsZHJlbiwgbnVtUG9pbnRzOiBudW1Qb2ludHMsIG5hbWUgfTtcclxuICAgIH1cclxuICAgIGFkZE5vZGUoeyBuYW1lLCBudW1Qb2ludHMsIGNoaWxkcmVuIH0sIHBjbywgbm9kZXMpIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4RnJvbU5hbWUobmFtZSk7XHJcbiAgICAgICAgY29uc3QgcGFyZW50TmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVzLmdldChwYXJlbnROYW1lKTtcclxuICAgICAgICBjb25zdCBsZXZlbCA9IG5hbWUubGVuZ3RoIC0gMTtcclxuICAgICAgICBjb25zdCBib3VuZGluZ0JveCA9IGNyZWF0ZUNoaWxkQUFCQihwYXJlbnROb2RlLmJvdW5kaW5nQm94LCBpbmRleCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnlOb2RlKG5hbWUsIHBjbywgYm91bmRpbmdCb3gpO1xyXG4gICAgICAgIG5vZGUubGV2ZWwgPSBsZXZlbDtcclxuICAgICAgICBub2RlLm51bVBvaW50cyA9IG51bVBvaW50cztcclxuICAgICAgICBub2RlLmhhc0NoaWxkcmVuID0gY2hpbGRyZW4gPiAwO1xyXG4gICAgICAgIG5vZGUuc3BhY2luZyA9IHBjby5zcGFjaW5nIC8gTWF0aC5wb3coMiwgbGV2ZWwpO1xyXG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XHJcbiAgICAgICAgbm9kZXMuc2V0KG5hbWUsIG5vZGUpO1xyXG4gICAgfVxyXG59XHJcblBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUuaWRDb3VudCA9IDA7XHJcbiIsImltcG9ydCB7IFBvaW50QXR0cmlidXRlcyB9IGZyb20gJy4vcG9pbnQtYXR0cmlidXRlcyc7XHJcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IobG9hZGVyLCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCwgb2Zmc2V0LCB4aHJSZXF1ZXN0KSB7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xyXG4gICAgICAgIHRoaXMudGlnaHRCb3VuZGluZ0JveCA9IHRpZ2h0Qm91bmRpbmdCb3g7XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgdGhpcy54aHJSZXF1ZXN0ID0geGhyUmVxdWVzdDtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vY3RyZWVEaXIgPSAnJztcclxuICAgICAgICB0aGlzLmhpZXJhcmNoeVN0ZXBTaXplID0gLTE7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMubnVtTm9kZXNMb2FkaW5nID0gMDtcclxuICAgICAgICB0aGlzLm1heE51bU5vZGVzTG9hZGluZyA9IDM7XHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50QXR0cmlidXRlcyA9IG5ldyBQb2ludEF0dHJpYnV0ZXMoW10pO1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmxvYWRlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5yb290LnRyYXZlcnNlKG5vZGUgPT4gbm9kZS5kaXNwb3NlKCkpO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgYWRkTm9kZUxvYWRlZENhbGxiYWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG4gICAgY2xlYXJOb2RlTG9hZGVkQ2FsbGJhY2tzKCkge1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmNhbGxiYWNrcyA9IFtdO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEJ1ZmZlckdlb21ldHJ5LCBFdmVudERpc3BhdGNoZXIgfSBmcm9tICd0aHJlZSc7XHJcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkT2N0cmVlTm9kZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeU5vZGUsIHNjZW5lTm9kZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wY0luZGV4ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3hOb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc1RyZWVOb2RlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeU5vZGUgPSBnZW9tZXRyeU5vZGU7XHJcbiAgICAgICAgdGhpcy5zY2VuZU5vZGUgPSBzY2VuZU5vZGU7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGdlb21ldHJ5Tm9kZS5jaGlsZHJlbi5zbGljZSgpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5Tm9kZS5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlU2NlbmVOb2RlKCkge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnNjZW5lTm9kZTtcclxuICAgICAgICBpZiAobm9kZS5nZW9tZXRyeSBpbnN0YW5jZW9mIEJ1ZmZlckdlb21ldHJ5KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpmb3JpblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAncG9zaXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XS5hcnJheTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIG5vZGUuZ2VvbWV0cnkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJhdmVyc2UoY2IsIGluY2x1ZGVTZWxmKSB7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeU5vZGUudHJhdmVyc2UoY2IsIGluY2x1ZGVTZWxmKTtcclxuICAgIH1cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaWQ7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUubmFtZTtcclxuICAgIH1cclxuICAgIGdldCBsZXZlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUubGV2ZWw7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNMZWFmTm9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaXNMZWFmTm9kZTtcclxuICAgIH1cclxuICAgIGdldCBudW1Qb2ludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLm51bVBvaW50cztcclxuICAgIH1cclxuICAgIGdldCBpbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeU5vZGUuaW5kZXg7XHJcbiAgICB9XHJcbiAgICBnZXQgYm91bmRpbmdTcGhlcmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlOb2RlLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJvdW5kaW5nQm94KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5ib3VuZGluZ0JveDtcclxuICAgIH1cclxuICAgIGdldCBzcGFjaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5Tm9kZS5zcGFjaW5nO1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluLCBtYXgpIHtcclxuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChtaW4sIHZhbHVlKSwgbWF4KTtcclxufVxyXG4iLCJpbXBvcnQgeyBDb2xvciwgTGluZWFyRmlsdGVyLCBOZWFyZXN0RmlsdGVyLCBOb0JsZW5kaW5nLCBQb2ludHMsIFJHQkFGb3JtYXQsIFNjZW5lLCBTcGhlcmUsIFZlY3RvcjMsIFZlY3RvcjQsIFdlYkdMUmVuZGVyVGFyZ2V0LCB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgQ09MT1JfQkxBQ0ssIERFRkFVTFRfUElDS19XSU5ET1dfU0laRSB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgQ2xpcE1vZGUsIFBvaW50Q2xvdWRNYXRlcmlhbCwgUG9pbnRDb2xvclR5cGUgfSBmcm9tICcuL21hdGVyaWFscyc7XHJcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi91dGlscy9tYXRoJztcclxuZXhwb3J0IGNsYXNzIFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIge1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5waWNrU3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5waWNrU3RhdGUubWF0ZXJpYWwuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBpY2socmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBvY3RyZWVzLCBwYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIGlmIChvY3RyZWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGlja1N0YXRlID0gdGhpcy5waWNrU3RhdGVcclxuICAgICAgICAgICAgPyB0aGlzLnBpY2tTdGF0ZVxyXG4gICAgICAgICAgICA6ICh0aGlzLnBpY2tTdGF0ZSA9IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIuZ2V0UGlja1N0YXRlKCkpO1xyXG4gICAgICAgIGNvbnN0IHBpY2tNYXRlcmlhbCA9IHBpY2tTdGF0ZS5tYXRlcmlhbDtcclxuICAgICAgICBjb25zdCBwaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHJlbmRlcmVyLmRvbUVsZW1lbnQuY2xpZW50V2lkdGggKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocmVuZGVyZXIuZG9tRWxlbWVudC5jbGllbnRIZWlnaHQgKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBQb2ludENsb3VkT2N0cmVlUGlja2VyLnVwZGF0ZVBpY2tSZW5kZXJUYXJnZXQodGhpcy5waWNrU3RhdGUsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsUG9zaXRpb24gPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclZlYzM7IC8vIFVzZSBoZWxwZXIgdmVjdG9yIHRvIHByZXZlbnQgZXh0cmEgYWxsb2NhdGlvbnMuXHJcbiAgICAgICAgaWYgKHBhcmFtcy5waXhlbFBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb24uY29weShwYXJhbXMucGl4ZWxQb3NpdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uLmFkZFZlY3RvcnMoY2FtZXJhLnBvc2l0aW9uLCByYXkuZGlyZWN0aW9uKS5wcm9qZWN0KGNhbWVyYSk7XHJcbiAgICAgICAgICAgIHBpeGVsUG9zaXRpb24ueCA9IChwaXhlbFBvc2l0aW9uLnggKyAxKSAqIHdpZHRoICogMC41O1xyXG4gICAgICAgICAgICBwaXhlbFBvc2l0aW9uLnkgPSAocGl4ZWxQb3NpdGlvbi55ICsgMSkgKiBoZWlnaHQgKiAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBpY2tXbmRTaXplID0gTWF0aC5mbG9vcigocGFyYW1zLnBpY2tXaW5kb3dTaXplIHx8IERFRkFVTFRfUElDS19XSU5ET1dfU0laRSkgKiBwaXhlbFJhdGlvKTtcclxuICAgICAgICBjb25zdCBoYWxmUGlja1duZFNpemUgPSAocGlja1duZFNpemUgLSAxKSAvIDI7XHJcbiAgICAgICAgY29uc3QgeCA9IE1hdGguZmxvb3IoY2xhbXAocGl4ZWxQb3NpdGlvbi54IC0gaGFsZlBpY2tXbmRTaXplLCAwLCB3aWR0aCkpO1xyXG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLmZsb29yKGNsYW1wKHBpeGVsUG9zaXRpb24ueSAtIGhhbGZQaWNrV25kU2l6ZSwgMCwgaGVpZ2h0KSk7XHJcbiAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5wcmVwYXJlUmVuZGVyKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSwgcGlja01hdGVyaWFsLCBwaWNrU3RhdGUpO1xyXG4gICAgICAgIGNvbnN0IHJlbmRlcmVkTm9kZXMgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLnJlbmRlcihyZW5kZXJlciwgY2FtZXJhLCBwaWNrTWF0ZXJpYWwsIG9jdHJlZXMsIHJheSwgcGlja1N0YXRlLCBwYXJhbXMpO1xyXG4gICAgICAgIC8vIENsZWFudXBcclxuICAgICAgICBwaWNrTWF0ZXJpYWwuY2xlYXJWaXNpYmxlTm9kZVRleHR1cmVPZmZzZXRzKCk7XHJcbiAgICAgICAgLy8gUmVhZCBiYWNrIGltYWdlIGFuZCBkZWNvZGUgaGl0IHBvaW50XHJcbiAgICAgICAgY29uc3QgcGl4ZWxzID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5yZWFkUGl4ZWxzKHJlbmRlcmVyLCB4LCB5LCBwaWNrV25kU2l6ZSk7XHJcbiAgICAgICAgY29uc3QgaGl0ID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5maW5kSGl0KHBpeGVscywgcGlja1duZFNpemUpO1xyXG4gICAgICAgIHJldHVybiBQb2ludENsb3VkT2N0cmVlUGlja2VyLmdldFBpY2tQb2ludChoaXQsIHJlbmRlcmVkTm9kZXMpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHByZXBhcmVSZW5kZXIocmVuZGVyZXIsIHgsIHksIHBpY2tXbmRTaXplLCBwaWNrTWF0ZXJpYWwsIHBpY2tTdGF0ZSkge1xyXG4gICAgICAgIC8vIFJlbmRlciB0aGUgaW50ZXJzZWN0ZWQgbm9kZXMgb250byB0aGUgcGljayByZW5kZXIgdGFyZ2V0LCBjbGlwcGluZyB0byBhIHNtYWxsIHBpY2sgd2luZG93LlxyXG4gICAgICAgIHJlbmRlcmVyLnNldFNjaXNzb3IoeCwgeSwgcGlja1duZFNpemUsIHBpY2tXbmRTaXplKTtcclxuICAgICAgICByZW5kZXJlci5zZXRTY2lzc29yVGVzdCh0cnVlKTtcclxuICAgICAgICByZW5kZXJlci5zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QocGlja01hdGVyaWFsLmRlcHRoVGVzdCk7XHJcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKHBpY2tNYXRlcmlhbC5kZXB0aFdyaXRlKTtcclxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZGluZyhOb0JsZW5kaW5nKTtcclxuICAgICAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQocGlja1N0YXRlLnJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBjbGVhciBjb2xvciBhbmQgY2xlYXIgdGhlIHJlbmRlcmVyIHdpdGggYmxhY2sgY29sb3IgYW5kIGFscGhhIDAuXHJcbiAgICAgICAgcmVuZGVyZXIuZ2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IpO1xyXG4gICAgICAgIGNvbnN0IG9sZENsZWFyQWxwaGEgPSByZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XHJcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcihDT0xPUl9CTEFDSywgMCk7XHJcbiAgICAgICAgcmVuZGVyZXIuY2xlYXIodHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcih0aGlzLmNsZWFyQ29sb3IsIG9sZENsZWFyQWxwaGEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlbmRlcihyZW5kZXJlciwgY2FtZXJhLCBwaWNrTWF0ZXJpYWwsIG9jdHJlZXMsIHJheSwgcGlja1N0YXRlLCBwYXJhbXMpIHtcclxuICAgICAgICBjb25zdCByZW5kZXJlZE5vZGVzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBvY3RyZWUgb2Ygb2N0cmVlcykge1xyXG4gICAgICAgICAgICAvLyBHZXQgYWxsIHRoZSBvY3RyZWUgbm9kZXMgd2hpY2ggaW50ZXJzZWN0IHRoZSBwaWNraW5nIHJheS4gV2Ugb25seSBuZWVkIHRvIHJlbmRlciB0aG9zZS5cclxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLm5vZGVzT25SYXkob2N0cmVlLCByYXkpO1xyXG4gICAgICAgICAgICBpZiAoIW5vZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci51cGRhdGVQaWNrTWF0ZXJpYWwocGlja01hdGVyaWFsLCBvY3RyZWUubWF0ZXJpYWwsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIHBpY2tNYXRlcmlhbC51cGRhdGVNYXRlcmlhbChvY3RyZWUsIG5vZGVzLCBjYW1lcmEsIHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgaWYgKHBhcmFtcy5vbkJlZm9yZVBpY2tSZW5kZXIpIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcy5vbkJlZm9yZVBpY2tSZW5kZXIocGlja01hdGVyaWFsLCBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDcmVhdGUgY29waWVzIG9mIHRoZSBub2RlcyBzbyB3ZSBjYW4gcmVuZGVyIHRoZW0gZGlmZmVyZW50bHkgdGhhbiBpbiB0aGUgbm9ybWFsIHBvaW50IGNsb3VkLlxyXG4gICAgICAgICAgICBwaWNrU3RhdGUuc2NlbmUuY2hpbGRyZW4gPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmNyZWF0ZVRlbXBOb2RlcyhvY3RyZWUsIG5vZGVzLCBwaWNrTWF0ZXJpYWwsIHJlbmRlcmVkTm9kZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHBpY2tTdGF0ZS5zY2VuZSwgY2FtZXJhKTtcclxuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHJlbmRlcmVkTm9kZXMucHVzaCh7IG5vZGUsIG9jdHJlZSB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZE5vZGVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5vZGVzT25SYXkob2N0cmVlLCByYXkpIHtcclxuICAgICAgICBjb25zdCBub2Rlc09uUmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgcmF5Q2xvbmUgPSByYXkuY2xvbmUoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygb2N0cmVlLnZpc2libGVOb2Rlcykge1xyXG4gICAgICAgICAgICBjb25zdCBzcGhlcmUgPSBQb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclNwaGVyZVxyXG4gICAgICAgICAgICAgICAgLmNvcHkobm9kZS5ib3VuZGluZ1NwaGVyZSlcclxuICAgICAgICAgICAgICAgIC5hcHBseU1hdHJpeDQob2N0cmVlLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgaWYgKHJheUNsb25lLmludGVyc2VjdHNTcGhlcmUoc3BoZXJlKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZXNPblJheS5wdXNoKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2Rlc09uUmF5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJlYWRQaXhlbHMocmVuZGVyZXIsIHgsIHksIHBpY2tXbmRTaXplKSB7XHJcbiAgICAgICAgLy8gUmVhZCB0aGUgcGl4ZWwgZnJvbSB0aGUgcGljayByZW5kZXIgdGFyZ2V0LlxyXG4gICAgICAgIGNvbnN0IHBpeGVscyA9IG5ldyBVaW50OEFycmF5KDQgKiBwaWNrV25kU2l6ZSAqIHBpY2tXbmRTaXplKTtcclxuICAgICAgICByZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzKHJlbmRlcmVyLmdldFJlbmRlclRhcmdldCgpLCB4LCB5LCBwaWNrV25kU2l6ZSwgcGlja1duZFNpemUsIHBpeGVscyk7XHJcbiAgICAgICAgcmVuZGVyZXIuc2V0U2Npc3NvclRlc3QoZmFsc2UpO1xyXG4gICAgICAgIHJlbmRlcmVyLnNldFJlbmRlclRhcmdldChudWxsKTtcclxuICAgICAgICByZXR1cm4gcGl4ZWxzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZVRlbXBOb2RlcyhvY3RyZWUsIG5vZGVzLCBwaWNrTWF0ZXJpYWwsIG5vZGVJbmRleE9mZnNldCkge1xyXG4gICAgICAgIGNvbnN0IHRlbXBOb2RlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBzY2VuZU5vZGUgPSBub2RlLnNjZW5lTm9kZTtcclxuICAgICAgICAgICAgY29uc3QgdGVtcE5vZGUgPSBuZXcgUG9pbnRzKHNjZW5lTm9kZS5nZW9tZXRyeSwgcGlja01hdGVyaWFsKTtcclxuICAgICAgICAgICAgdGVtcE5vZGUubWF0cml4ID0gc2NlbmVOb2RlLm1hdHJpeDtcclxuICAgICAgICAgICAgdGVtcE5vZGUubWF0cml4V29ybGQgPSBzY2VuZU5vZGUubWF0cml4V29ybGQ7XHJcbiAgICAgICAgICAgIHRlbXBOb2RlLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGVtcE5vZGUuZnJ1c3R1bUN1bGxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBub2RlSW5kZXhPZmZzZXQgKyBpICsgMTtcclxuICAgICAgICAgICAgaWYgKG5vZGVJbmRleCA+IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTW9yZSB0aGFuIDI1NSBub2RlcyBmb3IgcGljayBhcmUgbm90IHN1cHBvcnRlZC4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wTm9kZS5vbkJlZm9yZVJlbmRlciA9IFBvaW50Q2xvdWRNYXRlcmlhbC5tYWtlT25CZWZvcmVSZW5kZXIob2N0cmVlLCBub2RlLCBub2RlSW5kZXgpO1xyXG4gICAgICAgICAgICB0ZW1wTm9kZXMucHVzaCh0ZW1wTm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZW1wTm9kZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBkYXRlUGlja01hdGVyaWFsKHBpY2tNYXRlcmlhbCwgbm9kZU1hdGVyaWFsLCBwYXJhbXMpIHtcclxuICAgICAgICBwaWNrTWF0ZXJpYWwucG9pbnRTaXplVHlwZSA9IG5vZGVNYXRlcmlhbC5wb2ludFNpemVUeXBlO1xyXG4gICAgICAgIHBpY2tNYXRlcmlhbC5zaGFwZSA9IG5vZGVNYXRlcmlhbC5zaGFwZTtcclxuICAgICAgICBwaWNrTWF0ZXJpYWwuc2l6ZSA9IG5vZGVNYXRlcmlhbC5zaXplO1xyXG4gICAgICAgIHBpY2tNYXRlcmlhbC5taW5TaXplID0gbm9kZU1hdGVyaWFsLm1pblNpemU7XHJcbiAgICAgICAgcGlja01hdGVyaWFsLm1heFNpemUgPSBub2RlTWF0ZXJpYWwubWF4U2l6ZTtcclxuICAgICAgICBwaWNrTWF0ZXJpYWwuY2xhc3NpZmljYXRpb24gPSBub2RlTWF0ZXJpYWwuY2xhc3NpZmljYXRpb247XHJcbiAgICAgICAgcGlja01hdGVyaWFsLnVzZUZpbHRlckJ5Tm9ybWFsID0gbm9kZU1hdGVyaWFsLnVzZUZpbHRlckJ5Tm9ybWFsO1xyXG4gICAgICAgIHBpY2tNYXRlcmlhbC5maWx0ZXJCeU5vcm1hbFRocmVzaG9sZCA9IG5vZGVNYXRlcmlhbC5maWx0ZXJCeU5vcm1hbFRocmVzaG9sZDtcclxuICAgICAgICBpZiAocGFyYW1zLnBpY2tPdXRzaWRlQ2xpcFJlZ2lvbikge1xyXG4gICAgICAgICAgICBwaWNrTWF0ZXJpYWwuY2xpcE1vZGUgPSBDbGlwTW9kZS5ESVNBQkxFRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBpY2tNYXRlcmlhbC5jbGlwTW9kZSA9IG5vZGVNYXRlcmlhbC5jbGlwTW9kZTtcclxuICAgICAgICAgICAgcGlja01hdGVyaWFsLnNldENsaXBCb3hlcyhub2RlTWF0ZXJpYWwuY2xpcE1vZGUgPT09IENsaXBNb2RlLkNMSVBfT1VUU0lERSA/IG5vZGVNYXRlcmlhbC5jbGlwQm94ZXMgOiBbXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHVwZGF0ZVBpY2tSZW5kZXJUYXJnZXQocGlja1N0YXRlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQud2lkdGggPT09IHdpZHRoICYmIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuaGVpZ2h0ID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0LmRpc3Bvc2UoKTtcclxuICAgICAgICBwaWNrU3RhdGUucmVuZGVyVGFyZ2V0ID0gUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5tYWtlUGlja1JlbmRlclRhcmdldCgpO1xyXG4gICAgICAgIHBpY2tTdGF0ZS5yZW5kZXJUYXJnZXQuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYWtlUGlja1JlbmRlclRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFdlYkdMUmVuZGVyVGFyZ2V0KDEsIDEsIHtcclxuICAgICAgICAgICAgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIsXHJcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogTmVhcmVzdEZpbHRlcixcclxuICAgICAgICAgICAgZm9ybWF0OiBSR0JBRm9ybWF0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRIaXQocGl4ZWxzLCBwaWNrV25kU2l6ZSkge1xyXG4gICAgICAgIGNvbnN0IGlidWZmZXIgPSBuZXcgVWludDMyQXJyYXkocGl4ZWxzLmJ1ZmZlcik7XHJcbiAgICAgICAgLy8gRmluZCBjbG9zZXN0IGhpdCBpbnNpZGUgcGl4ZWxXaW5kb3cgYm91bmRhcmllc1xyXG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBoaXQgPSBudWxsO1xyXG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgcGlja1duZFNpemU7IHUrKykge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHBpY2tXbmRTaXplOyB2KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHUgKyB2ICogcGlja1duZFNpemU7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGgucG93KHUgLSAocGlja1duZFNpemUgLSAxKSAvIDIsIDIpICsgTWF0aC5wb3codiAtIChwaWNrV25kU2l6ZSAtIDEpIC8gMiwgMik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwY0luZGV4ID0gcGl4ZWxzWzQgKiBvZmZzZXQgKyAzXTtcclxuICAgICAgICAgICAgICAgIHBpeGVsc1s0ICogb2Zmc2V0ICsgM10gPSAwO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcEluZGV4ID0gaWJ1ZmZlcltvZmZzZXRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBjSW5kZXggPiAwICYmIGRpc3RhbmNlIDwgbWluKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwSW5kZXg6IHBJbmRleCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGNJbmRleDogcGNJbmRleCAtIDEsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFBpY2tQb2ludChoaXQsIG5vZGVzKSB7XHJcbiAgICAgICAgaWYgKCFoaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBvaW50ID0ge307XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbm9kZXNbaGl0LnBjSW5kZXhdICYmIG5vZGVzW2hpdC5wY0luZGV4XS5ub2RlLnNjZW5lTm9kZTtcclxuICAgICAgICBpZiAoIXBvaW50cykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9pbnQucG9pbnRDbG91ZCA9IG5vZGVzW2hpdC5wY0luZGV4XS5vY3RyZWU7XHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHBvaW50cy5nZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBhdHRyaWJ1dGVzW3Byb3BlcnR5XTtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1zd2l0Y2hcclxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ID09PSAncG9zaXRpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBQb2ludENsb3VkT2N0cmVlUGlja2VyLmFkZFBvc2l0aW9uVG9QaWNrUG9pbnQocG9pbnQsIGhpdCwgdmFsdWVzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3BlcnR5ID09PSAnbm9ybWFsJykge1xyXG4gICAgICAgICAgICAgICAgUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5hZGROb3JtYWxUb1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09ICdpbmRpY2VzJykge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlcy5pdGVtU2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50W3Byb3BlcnR5XSA9IHZhbHVlcy5hcnJheVtoaXQucEluZGV4XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZXMuaXRlbVNpemU7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbHVlcy5hcnJheVt2YWx1ZXMuaXRlbVNpemUgKiBoaXQucEluZGV4ICsgal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb2ludFtwcm9wZXJ0eV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYWRkUG9zaXRpb25Ub1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cykge1xyXG4gICAgICAgIHBvaW50LnBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKVxyXG4gICAgICAgICAgICAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh2YWx1ZXMsIGhpdC5wSW5kZXgpXHJcbiAgICAgICAgICAgIC5hcHBseU1hdHJpeDQocG9pbnRzLm1hdHJpeFdvcmxkKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBhZGROb3JtYWxUb1BpY2tQb2ludChwb2ludCwgaGl0LCB2YWx1ZXMsIHBvaW50cykge1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IG5ldyBWZWN0b3IzKCkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh2YWx1ZXMsIGhpdC5wSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbDQgPSBuZXcgVmVjdG9yNChub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56LCAwKS5hcHBseU1hdHJpeDQocG9pbnRzLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICBub3JtYWwuc2V0KG5vcm1hbDQueCwgbm9ybWFsNC55LCBub3JtYWw0LnopO1xyXG4gICAgICAgIHBvaW50Lm5vcm1hbCA9IG5vcm1hbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRQaWNrU3RhdGUoKSB7XHJcbiAgICAgICAgY29uc3Qgc2NlbmUgPSBuZXcgU2NlbmUoKTtcclxuICAgICAgICBzY2VuZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgbWF0ZXJpYWwgPSBuZXcgUG9pbnRDbG91ZE1hdGVyaWFsKCk7XHJcbiAgICAgICAgbWF0ZXJpYWwucG9pbnRDb2xvclR5cGUgPSBQb2ludENvbG9yVHlwZS5QT0lOVF9JTkRFWDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByZW5kZXJUYXJnZXQ6IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIubWFrZVBpY2tSZW5kZXJUYXJnZXQoKSxcclxuICAgICAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxyXG4gICAgICAgICAgICBzY2VuZTogc2NlbmUsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5Qb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclZlYzMgPSBuZXcgVmVjdG9yMygpO1xyXG5Qb2ludENsb3VkT2N0cmVlUGlja2VyLmhlbHBlclNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcclxuUG9pbnRDbG91ZE9jdHJlZVBpY2tlci5jbGVhckNvbG9yID0gbmV3IENvbG9yKCk7XHJcbiIsImltcG9ydCB7IFNwaGVyZSB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGNsYXNzIE9jdHJlZUdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGxvYWRlciwgYm91bmRpbmdCb3gpIHtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IGxvYWRlcjtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XHJcbiAgICAgICAgdGhpcy5tYXhOdW1Ob2Rlc0xvYWRpbmcgPSAzO1xyXG4gICAgICAgIHRoaXMubnVtTm9kZXNMb2FkaW5nID0gMDtcclxuICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5wb2ludEF0dHJpYnV0ZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XHJcbiAgICAgICAgdGhpcy51cmwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGlnaHRCb3VuZGluZ0JveCA9IHRoaXMuYm91bmRpbmdCb3guY2xvbmUoKTtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xyXG4gICAgICAgIHRoaXMudGlnaHRCb3VuZGluZ1NwaGVyZSA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5yb290LnRyYXZlcnNlKChub2RlKSA9PiBub2RlLmRpc3Bvc2UoKSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgT2JqZWN0M0QgfSBmcm9tICd0aHJlZSc7XHJcbmV4cG9ydCBjbGFzcyBQb2ludENsb3VkVHJlZSBleHRlbmRzIE9iamVjdDNEIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QgIT09IG51bGw7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgQm94MywgT2JqZWN0M0QsIFBvaW50cywgU3BoZXJlLCBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xyXG5pbXBvcnQgeyBERUZBVUxUX01JTl9OT0RFX1BJWEVMX1NJWkUgfSBmcm9tICcuL2NvbnN0YW50cyc7XHJcbmltcG9ydCB7IE9jdHJlZUdlb21ldHJ5IH0gZnJvbSAnLi9sb2FkaW5nMi9vY3RyZWUtZ2VvbWV0cnknO1xyXG5pbXBvcnQgeyBQb2ludENsb3VkTWF0ZXJpYWwgfSBmcm9tICcuL21hdGVyaWFscyc7XHJcbmltcG9ydCB7IFBvaW50Q2xvdWRPY3RyZWVOb2RlIH0gZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtbm9kZSc7XHJcbmltcG9ydCB7IFBvaW50Q2xvdWRPY3RyZWVQaWNrZXIgfSBmcm9tICcuL3BvaW50LWNsb3VkLW9jdHJlZS1waWNrZXInO1xyXG5pbXBvcnQgeyBQb2ludENsb3VkVHJlZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtdHJlZSc7XHJcbmltcG9ydCB7IGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94IH0gZnJvbSAnLi91dGlscy9ib3VuZHMnO1xyXG5leHBvcnQgY2xhc3MgUG9pbnRDbG91ZE9jdHJlZSBleHRlbmRzIFBvaW50Q2xvdWRUcmVlIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvdHJlZSwgcGNvR2VvbWV0cnksIG1hdGVyaWFsKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sZXZlbCA9IDA7XHJcbiAgICAgICAgdGhpcy5tYXhMZXZlbCA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBtaW5pbXVtIHJhZGl1cyBvZiBhIG5vZGUncyBib3VuZGluZyBzcGhlcmUgb24gdGhlIHNjcmVlbiBpbiBvcmRlciB0byBiZSBkaXNwbGF5ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW5Ob2RlUGl4ZWxTaXplID0gREVGQVVMVF9NSU5fTk9ERV9QSVhFTF9TSVpFO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveE5vZGVzID0gW107XHJcbiAgICAgICAgdGhpcy52aXNpYmxlTm9kZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnZpc2libGVHZW9tZXRyeSA9IFtdO1xyXG4gICAgICAgIHRoaXMubnVtVmlzaWJsZVBvaW50cyA9IDA7XHJcbiAgICAgICAgdGhpcy5zaG93Qm91bmRpbmdCb3ggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZpc2libGVCb3VuZHMgPSBuZXcgQm94MygpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xyXG4gICAgICAgIHRoaXMucG90cmVlID0gcG90cmVlO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHBjb0dlb21ldHJ5LnJvb3Q7XHJcbiAgICAgICAgdGhpcy5wY29HZW9tZXRyeSA9IHBjb0dlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBwY29HZW9tZXRyeS5ib3VuZGluZ0JveDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gdGhpcy5ib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24uY29weShwY29HZW9tZXRyeS5vZmZzZXQpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbCA9XHJcbiAgICAgICAgICAgIG1hdGVyaWFsIHx8IHBjb0dlb21ldHJ5IGluc3RhbmNlb2YgT2N0cmVlR2VvbWV0cnlcclxuICAgICAgICAgICAgICAgID8gbmV3IFBvaW50Q2xvdWRNYXRlcmlhbCh7IGNvbG9yUmdiYTogdHJ1ZSB9KVxyXG4gICAgICAgICAgICAgICAgOiBuZXcgUG9pbnRDbG91ZE1hdGVyaWFsKCk7XHJcbiAgICAgICAgdGhpcy5pbml0TWF0ZXJpYWwodGhpcy5tYXRlcmlhbCk7XHJcbiAgICB9XHJcbiAgICBpbml0TWF0ZXJpYWwobWF0ZXJpYWwpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKHRydWUpO1xyXG4gICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IGNvbXB1dGVUcmFuc2Zvcm1lZEJvdW5kaW5nQm94KHRoaXMucGNvR2VvbWV0cnkudGlnaHRCb3VuZGluZ0JveCB8fCB0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKSwgdGhpcy5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgY29uc3QgYldpZHRoID0gbWF4LnogLSBtaW4uejtcclxuICAgICAgICBtYXRlcmlhbC5oZWlnaHRNaW4gPSBtaW4ueiAtIDAuMiAqIGJXaWR0aDtcclxuICAgICAgICBtYXRlcmlhbC5oZWlnaHRNYXggPSBtYXgueiArIDAuMiAqIGJXaWR0aDtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5LnJvb3QudHJhdmVyc2UobiA9PiB0aGlzLnBvdHJlZS5scnUucmVtb3ZlKG4pKTtcclxuICAgICAgICB0aGlzLnBjb0dlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLm1hdGVyaWFsLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLnZpc2libGVOb2RlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZUdlb21ldHJ5ID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMucGlja2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmRpc3Bvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5waWNrZXIgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvaW50U2l6ZVR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0ZXJpYWwucG9pbnRTaXplVHlwZTtcclxuICAgIH1cclxuICAgIHNldCBwb2ludFNpemVUeXBlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5tYXRlcmlhbC5wb2ludFNpemVUeXBlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICB0b1RyZWVOb2RlKGdlb21ldHJ5Tm9kZSwgcGFyZW50KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gbmV3IFBvaW50cyhnZW9tZXRyeU5vZGUuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwpO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgUG9pbnRDbG91ZE9jdHJlZU5vZGUoZ2VvbWV0cnlOb2RlLCBwb2ludHMpO1xyXG4gICAgICAgIHBvaW50cy5uYW1lID0gZ2VvbWV0cnlOb2RlLm5hbWU7XHJcbiAgICAgICAgcG9pbnRzLnBvc2l0aW9uLmNvcHkoZ2VvbWV0cnlOb2RlLmJvdW5kaW5nQm94Lm1pbik7XHJcbiAgICAgICAgcG9pbnRzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcclxuICAgICAgICBwb2ludHMub25CZWZvcmVSZW5kZXIgPSBQb2ludENsb3VkTWF0ZXJpYWwubWFrZU9uQmVmb3JlUmVuZGVyKHRoaXMsIG5vZGUpO1xyXG4gICAgICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICAgICAgcGFyZW50LnNjZW5lTm9kZS5hZGQocG9pbnRzKTtcclxuICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuW2dlb21ldHJ5Tm9kZS5pbmRleF0gPSBub2RlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeU5vZGUub25lVGltZURpc3Bvc2VIYW5kbGVycy5wdXNoKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZGlzcG9zZVNjZW5lTm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgcGFyZW50LnNjZW5lTm9kZS5yZW1vdmUobm9kZS5zY2VuZU5vZGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgdHJlZSBub2RlIChyZW5kZXJlZCBhbmQgaW4gdGhlIEdQVSkgd2l0aCB0aGUgZ2VvbWV0cnkgbm9kZS5cclxuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbltnZW9tZXRyeU5vZGUuaW5kZXhdID0gZ2VvbWV0cnlOb2RlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5vZGU7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKHBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmlzaWJsZUJvdW5kcygpIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSB0aGlzLnZpc2libGVCb3VuZHM7XHJcbiAgICAgICAgYm91bmRzLm1pbi5zZXQoSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgICAgYm91bmRzLm1heC5zZXQoLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudmlzaWJsZU5vZGVzKSB7XHJcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5leHBhbmRCeVBvaW50KG5vZGUuYm91bmRpbmdCb3gubWluKTtcclxuICAgICAgICAgICAgICAgIGJvdW5kcy5leHBhbmRCeVBvaW50KG5vZGUuYm91bmRpbmdCb3gubWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUJvdW5kaW5nQm94ZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNob3dCb3VuZGluZ0JveCB8fCAhdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYmJSb290ID0gdGhpcy5wYXJlbnQuZ2V0T2JqZWN0QnlOYW1lKCdiYnJvb3QnKTtcclxuICAgICAgICBpZiAoIWJiUm9vdCkge1xyXG4gICAgICAgICAgICBiYlJvb3QgPSBuZXcgT2JqZWN0M0QoKTtcclxuICAgICAgICAgICAgYmJSb290Lm5hbWUgPSAnYmJyb290JztcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYWRkKGJiUm9vdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHZpc2libGVCb3hlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnZpc2libGVOb2Rlcykge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ib3VuZGluZ0JveE5vZGUgIT09IHVuZGVmaW5lZCAmJiBub2RlLmlzTGVhZk5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZpc2libGVCb3hlcy5wdXNoKG5vZGUuYm91bmRpbmdCb3hOb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBiYlJvb3QuY2hpbGRyZW4gPSB2aXNpYmxlQm94ZXM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVNYXRyaXhXb3JsZChmb3JjZSkge1xyXG4gICAgICAgIGlmICh0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9PT0gdHJ1ZSB8fCBmb3JjZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoaWRlRGVzY2VuZGFudHMob2JqZWN0KSB7XHJcbiAgICAgICAgY29uc3QgdG9IaWRlID0gW107XHJcbiAgICAgICAgYWRkVmlzaWJsZUNoaWxkcmVuKG9iamVjdCk7XHJcbiAgICAgICAgd2hpbGUgKHRvSGlkZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ialRvSGlkZSA9IHRvSGlkZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBvYmpUb0hpZGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBhZGRWaXNpYmxlQ2hpbGRyZW4ob2JqVG9IaWRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gYWRkVmlzaWJsZUNoaWxkcmVuKG9iaikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG9iai5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b0hpZGUucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtb3ZlVG9PcmlnaW4oKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7IC8vIFJlc2V0LCB0aGVuIHRoZSBtYXRyaXggd2lsbCBiZSB1cGRhdGVkIGluIGdldEJvdW5kaW5nQm94V29ybGQoKVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24uc2V0KDAsIDAsIDApLnN1Yih0aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5nZXRDZW50ZXIobmV3IFZlY3RvcjMoKSkpO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvR3JvdW5kUGxhbmUoKSB7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ICs9IC10aGlzLmdldEJvdW5kaW5nQm94V29ybGQoKS5taW4ueTtcclxuICAgIH1cclxuICAgIGdldEJvdW5kaW5nQm94V29ybGQoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcclxuICAgICAgICByZXR1cm4gY29tcHV0ZVRyYW5zZm9ybWVkQm91bmRpbmdCb3godGhpcy5ib3VuZGluZ0JveCwgdGhpcy5tYXRyaXhXb3JsZCk7XHJcbiAgICB9XHJcbiAgICBnZXRWaXNpYmxlRXh0ZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVCb3VuZHMuYXBwbHlNYXRyaXg0KHRoaXMubWF0cml4V29ybGQpO1xyXG4gICAgfVxyXG4gICAgcGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIHBhcmFtcyA9IHt9KSB7XHJcbiAgICAgICAgdGhpcy5waWNrZXIgPSB0aGlzLnBpY2tlciB8fCBuZXcgUG9pbnRDbG91ZE9jdHJlZVBpY2tlcigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlci5waWNrKHJlbmRlcmVyLCBjYW1lcmEsIHJheSwgW3RoaXNdLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHByb2dyZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVHZW9tZXRyeS5sZW5ndGggPT09IDBcclxuICAgICAgICAgICAgPyAwXHJcbiAgICAgICAgICAgIDogdGhpcy52aXNpYmxlTm9kZXMubGVuZ3RoIC8gdGhpcy52aXNpYmxlR2VvbWV0cnkubGVuZ3RoO1xyXG4gICAgfVxyXG59XHJcbiIsImNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5jb25zdCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xyXG5leHBvcnQgY29uc3QgRkVBVFVSRVMgPSB7XHJcbiAgICBTSEFERVJfSU5URVJQT0xBVElPTjogaGFzRXh0ZW5zaW9uKCdFWFRfZnJhZ19kZXB0aCcpICYmIGhhc01pblZhcnlpbmdWZWN0b3JzKDgpLFxyXG4gICAgU0hBREVSX1NQTEFUUzogaGFzRXh0ZW5zaW9uKCdFWFRfZnJhZ19kZXB0aCcpICYmIGhhc0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcclxuICAgIFNIQURFUl9FREw6IGhhc0V4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyg4KSxcclxuICAgIHByZWNpc2lvbjogZ2V0UHJlY2lzaW9uKCksXHJcbn07XHJcbmZ1bmN0aW9uIGhhc0V4dGVuc2lvbihleHQpIHtcclxuICAgIHJldHVybiBnbCAhPT0gbnVsbCAmJiBCb29sZWFuKGdsLmdldEV4dGVuc2lvbihleHQpKTtcclxufVxyXG5mdW5jdGlvbiBoYXNNaW5WYXJ5aW5nVmVjdG9ycyh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGdsICE9PSBudWxsICYmIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkFSWUlOR19WRUNUT1JTKSA+PSB2YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oKSB7XHJcbiAgICBpZiAoZ2wgPT09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2c0hpZ2hwRmxvYXQgPSBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCk7XHJcbiAgICBjb25zdCB2c01lZGl1bXBGbG9hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpO1xyXG4gICAgY29uc3QgZnNIaWdocEZsb2F0ID0gZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCk7XHJcbiAgICBjb25zdCBmc01lZGl1bXBGbG9hdCA9IGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCk7XHJcbiAgICBjb25zdCBoaWdocEF2YWlsYWJsZSA9IHZzSGlnaHBGbG9hdCAmJiBmc0hpZ2hwRmxvYXQgJiYgdnNIaWdocEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgZnNIaWdocEZsb2F0LnByZWNpc2lvbiA+IDA7XHJcbiAgICBjb25zdCBtZWRpdW1wQXZhaWxhYmxlID0gdnNNZWRpdW1wRmxvYXQgJiZcclxuICAgICAgICBmc01lZGl1bXBGbG9hdCAmJlxyXG4gICAgICAgIHZzTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiZcclxuICAgICAgICBmc01lZGl1bXBGbG9hdC5wcmVjaXNpb24gPiAwO1xyXG4gICAgcmV0dXJuIGhpZ2hwQXZhaWxhYmxlID8gJ2hpZ2hwJyA6IG1lZGl1bXBBdmFpbGFibGUgPyAnbWVkaXVtcCcgOiAnbG93cCc7XHJcbn1cclxuIiwiZXhwb3J0IGNsYXNzIEFzeW5jQmxvY2tpbmdRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlc29sdmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMucHJvbWlzZXMgPSBbXTtcclxuICAgIH1cclxuICAgIGVucXVldWUodCkge1xyXG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc29sdmUgPSB0aGlzLnJlc29sdmVycy5zaGlmdCgpO1xyXG4gICAgICAgIHJlc29sdmUodCk7XHJcbiAgICB9XHJcbiAgICBkZXF1ZXVlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wcm9taXNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZXMuc2hpZnQoKTtcclxuICAgIH1cclxuICAgIGFkZCgpIHtcclxuICAgICAgICB0aGlzLnByb21pc2VzLnB1c2gobmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXJzLnB1c2gocmVzb2x2ZSk7XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFzeW5jQmxvY2tpbmdRdWV1ZSB9IGZyb20gJy4vYXN5bmMtYmxvY2tpbmctcXVldWUnO1xyXG5leHBvcnQgY2xhc3MgQXV0b1Rlcm1pbmF0aW5nV29ya2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdyYXBwZWRXb3JrZXIsIG1heElkbGUpIHtcclxuICAgICAgICB0aGlzLndyYXBwZWRXb3JrZXIgPSB3cmFwcGVkV29ya2VyO1xyXG4gICAgICAgIHRoaXMubWF4SWRsZSA9IG1heElkbGU7XHJcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgd29ya2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndyYXBwZWRXb3JrZXI7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNUZXJtaW5hdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlcm1pbmF0ZWQ7XHJcbiAgICB9XHJcbiAgICBtYXJrSWRsZSgpIHtcclxuICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50ZXJtaW5hdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy53cmFwcGVkV29ya2VyLnRlcm1pbmF0ZSgpO1xyXG4gICAgICAgIH0sIHRoaXMubWF4SWRsZSk7XHJcbiAgICB9XHJcbiAgICBtYXJrSW5Vc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgV29ya2VyUG9vbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhXb3JrZXJzLCB3b3JrZXJUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5tYXhXb3JrZXJzID0gbWF4V29ya2VycztcclxuICAgICAgICB0aGlzLndvcmtlclR5cGUgPSB3b3JrZXJUeXBlO1xyXG4gICAgICAgIHRoaXMucG9vbCA9IG5ldyBBc3luY0Jsb2NraW5nUXVldWUoKTtcclxuICAgICAgICB0aGlzLnBvb2xTaXplID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHdvcmtlciBwcm9taXNlIHdoaWNoIGlzIHJlc29sdmVkIHdoZW4gb25lIGlzIGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0V29ya2VyKCkge1xyXG4gICAgICAgIC8vIElmIHRoZSBudW1iZXIgb2YgYWN0aXZlIHdvcmtlcnMgaXMgc21hbGxlciB0aGFuIHRoZSBtYXhpbXVtLCByZXR1cm4gYSBuZXcgb25lLlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgcHJvbWlzZSBmb3Igd29ya2VyIGZyb20gdGhlIHBvb2wuXHJcbiAgICAgICAgaWYgKHRoaXMucG9vbFNpemUgPCB0aGlzLm1heFdvcmtlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5wb29sU2l6ZSsrO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBBdXRvVGVybWluYXRpbmdXb3JrZXIobmV3IHRoaXMud29ya2VyVHlwZSgpLCBXb3JrZXJQb29sLlBPT0xfTUFYX0lETEUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvb2wuZGVxdWV1ZSgpLnRoZW4od29ya2VyID0+IHtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5tYXJrSW5Vc2UoKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkZXF1ZXVlZCB3b3JrZXIgaGFzIGJlZW4gdGVybWluYXRlZCwgZGVjcmVhc2UgdGhlIHBvb2wgc2l6ZSBhbmQgbWFrZSBhIHJlY3Vyc2l2ZSBjYWxsIHRvIGdldCBhIG5ldyB3b3JrZXJcclxuICAgICAgICAgICAgICAgIGlmICh3b3JrZXIuaXNUZXJtaW5hdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb29sU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFdvcmtlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtlcjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWxlYXNlcyBhIFdvcmtlciBiYWNrIGludG8gdGhlIHBvb2xcclxuICAgICAqIEBwYXJhbSB3b3JrZXJcclxuICAgICAqL1xyXG4gICAgcmVsZWFzZVdvcmtlcih3b3JrZXIpIHtcclxuICAgICAgICB3b3JrZXIubWFya0lkbGUoKTtcclxuICAgICAgICB0aGlzLnBvb2wuZW5xdWV1ZSh3b3JrZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBhbW91bnQgb2YgaWRsZSB0aW1lIHRoYXQgY2FuIGVsYXBzZSBiZWZvcmUgYSB3b3JrZXIgZnJvbSB0aGlzIHBvb2wgaXMgYXV0b21hdGljYWxseSB0ZXJtaW5hdGVkXHJcbiAqL1xyXG5Xb3JrZXJQb29sLlBPT0xfTUFYX0lETEUgPSA3MDAwO1xyXG4iLCJleHBvcnQgY2xhc3MgVmVyc2lvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICAgICAgY29uc3Qgdm1MZW5ndGggPSB2ZXJzaW9uLmluZGV4T2YoJy4nKSA9PT0gLTEgPyB2ZXJzaW9uLmxlbmd0aCA6IHZlcnNpb24uaW5kZXhPZignLicpO1xyXG4gICAgICAgIHRoaXMudmVyc2lvbk1ham9yID0gcGFyc2VJbnQodmVyc2lvbi5zdWJzdHIoMCwgdm1MZW5ndGgpLCAxMCk7XHJcbiAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSBwYXJzZUludCh2ZXJzaW9uLnN1YnN0cih2bUxlbmd0aCArIDEpLCAxMCk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMudmVyc2lvbk1pbm9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnNpb25NaW5vciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbmV3ZXJUaGFuKHZlcnNpb24pIHtcclxuICAgICAgICBjb25zdCB2ID0gbmV3IFZlcnNpb24odmVyc2lvbik7XHJcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+IHYudmVyc2lvbk1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVxdWFsT3JIaWdoZXIodmVyc2lvbikge1xyXG4gICAgICAgIGNvbnN0IHYgPSBuZXcgVmVyc2lvbih2ZXJzaW9uKTtcclxuICAgICAgICBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPiB2LnZlcnNpb25NYWpvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy52ZXJzaW9uTWFqb3IgPT09IHYudmVyc2lvbk1ham9yICYmIHRoaXMudmVyc2lvbk1pbm9yID49IHYudmVyc2lvbk1pbm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwVG8odmVyc2lvbikge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5uZXdlclRoYW4odmVyc2lvbik7XHJcbiAgICB9XHJcbn1cclxuIiwiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuaW1wb3J0IHsgQm94MywgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgVWludDhCdWZmZXJBdHRyaWJ1dGUsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XHJcbmltcG9ydCB7IFBvaW50QXR0cmlidXRlTmFtZSB9IGZyb20gJy4uL3BvaW50LWF0dHJpYnV0ZXMnO1xyXG5pbXBvcnQgeyBoYW5kbGVFbXB0eUJ1ZmZlciwgaGFuZGxlRmFpbGVkUmVxdWVzdCB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcclxuaW1wb3J0IHsgV29ya2VyUG9vbCB9IGZyb20gJy4uL3V0aWxzL3dvcmtlci1wb29sJztcclxuaW1wb3J0IHsgVmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24nO1xyXG5leHBvcnQgY2xhc3MgQmluYXJ5TG9hZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHsgZ2V0VXJsID0gcyA9PiBQcm9taXNlLnJlc29sdmUocyksIHZlcnNpb24sIGJvdW5kaW5nQm94LCBzY2FsZSwgeGhyUmVxdWVzdCwgfSkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVyc2lvbiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54aHJSZXF1ZXN0ID0geGhyUmVxdWVzdDtcclxuICAgICAgICB0aGlzLmdldFVybCA9IGdldFVybDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgbG9hZChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUubG9hZGVkIHx8IHRoaXMuZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2V0VXJsKHRoaXMuZ2V0Tm9kZVVybChub2RlKSkpXHJcbiAgICAgICAgICAgIC50aGVuKHVybCA9PiB0aGlzLnhoclJlcXVlc3QodXJsLCB7IG1vZGU6ICdjb3JzJyB9KSlcclxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzKSlcclxuICAgICAgICAgICAgLnRoZW4ob2tSZXMgPT4gb2tSZXMuYXJyYXlCdWZmZXIoKSlcclxuICAgICAgICAgICAgLnRoZW4oYnVmZmVyID0+IGhhbmRsZUVtcHR5QnVmZmVyKGJ1ZmZlcikpXHJcbiAgICAgICAgICAgIC50aGVuKG9rQnVmZmVyID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5wYXJzZShub2RlLCBva0J1ZmZlciwgcmVzb2x2ZSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZVVybChub2RlKSB7XHJcbiAgICAgICAgbGV0IHVybCA9IG5vZGUuZ2V0VXJsKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbi5lcXVhbE9ySGlnaGVyKCcxLjQnKSkge1xyXG4gICAgICAgICAgICB1cmwgKz0gJy5iaW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgfVxyXG4gICAgcGFyc2Uobm9kZSwgYnVmZmVyLCByZXNvbHZlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJpbmFyeUxvYWRlci5XT1JLRVJfUE9PTC5nZXRXb3JrZXIoKS50aGVuKGF1dG9UZXJtaW5hdGluZ1dvcmtlciA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlcyA9IG5vZGUucGNvR2VvbWV0cnkucG9pbnRBdHRyaWJ1dGVzO1xyXG4gICAgICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBidWZmZXIuYnl0ZUxlbmd0aCAvIHBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudmVyc2lvbi51cFRvKCcxLjUnKSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5udW1Qb2ludHMgPSBudW1Qb2ludHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXV0b1Rlcm1pbmF0aW5nV29ya2VyLndvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgQmluYXJ5TG9hZGVyLldPUktFUl9QT09MLnJlbGVhc2VXb3JrZXIoYXV0b1Rlcm1pbmF0aW5nV29ya2VyKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZS5kYXRhO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSAobm9kZS5nZW9tZXRyeSA9IG5vZGUuZ2VvbWV0cnkgfHwgbmV3IEJ1ZmZlckdlb21ldHJ5KCkpO1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuYm91bmRpbmdCb3ggPSBub2RlLmJvdW5kaW5nQm94O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRCdWZmZXJBdHRyaWJ1dGVzKGdlb21ldHJ5LCBkYXRhLmF0dHJpYnV0ZUJ1ZmZlcnMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmRpY2VzKGdlb21ldHJ5LCBkYXRhLmluZGljZXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGROb3JtYWxBdHRyaWJ1dGUoZ2VvbWV0cnksIG51bVBvaW50cyk7XHJcbiAgICAgICAgICAgICAgICBub2RlLm1lYW4gPSBuZXcgVmVjdG9yMygpLmZyb21BcnJheShkYXRhLm1lYW4pO1xyXG4gICAgICAgICAgICAgICAgbm9kZS50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5nZXRUaWdodEJvdW5kaW5nQm94KGRhdGEudGlnaHRCb3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG5vZGUuZmFpbGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBub2RlLnBjb0dlb21ldHJ5Lm51bU5vZGVzTG9hZGluZy0tO1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wY29HZW9tZXRyeS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKG5vZGUpKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIEJpbmFyeUxvYWRlci5XT1JLRVJfUE9PTC5yZWxlYXNlV29ya2VyKGF1dG9UZXJtaW5hdGluZ1dvcmtlcik7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIsXHJcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24udmVyc2lvbixcclxuICAgICAgICAgICAgICAgIG1pbjogbm9kZS5ib3VuZGluZ0JveC5taW4udG9BcnJheSgpLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBub2RlLnBjb0dlb21ldHJ5Lm9mZnNldC50b0FycmF5KCksXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSxcclxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IG5vZGUuc3BhY2luZyxcclxuICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuOiBub2RlLmhhc0NoaWxkcmVuLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhdXRvVGVybWluYXRpbmdXb3JrZXIud29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFttZXNzYWdlLmJ1ZmZlcl0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0VGlnaHRCb3VuZGluZ0JveCh7IG1pbiwgbWF4IH0pIHtcclxuICAgICAgICBjb25zdCBib3ggPSBuZXcgQm94MyhuZXcgVmVjdG9yMygpLmZyb21BcnJheShtaW4pLCBuZXcgVmVjdG9yMygpLmZyb21BcnJheShtYXgpKTtcclxuICAgICAgICBib3gubWF4LnN1Yihib3gubWluKTtcclxuICAgICAgICBib3gubWluLnNldCgwLCAwLCAwKTtcclxuICAgICAgICByZXR1cm4gYm94O1xyXG4gICAgfVxyXG4gICAgYWRkQnVmZmVyQXR0cmlidXRlcyhnZW9tZXRyeSwgYnVmZmVycykge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKGJ1ZmZlcnMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW3Byb3BlcnR5XS5idWZmZXI7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuUE9TSVRJT05fQ0FSVEVTSUFOKSkge1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5pc0F0dHJpYnV0ZShwcm9wZXJ0eSwgUG9pbnRBdHRyaWJ1dGVOYW1lLkNPTE9SX1BBQ0tFRCkpIHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDMsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuSU5URU5TSVRZKSkge1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbnRlbnNpdHknLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5DTEFTU0lGSUNBVElPTikpIHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnY2xhc3NpZmljYXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX1NQSEVSRU1BUFBFRCkpIHtcclxuICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmlzQXR0cmlidXRlKHByb3BlcnR5LCBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2KSkge1xyXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuaXNBdHRyaWJ1dGUocHJvcGVydHksIFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUwpKSB7XHJcbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFkZEluZGljZXMoZ2VvbWV0cnksIGluZGljZXMpIHtcclxuICAgICAgICBjb25zdCBpbmRpY2VzQXR0cmlidXRlID0gbmV3IFVpbnQ4QnVmZmVyQXR0cmlidXRlKGluZGljZXMsIDQpO1xyXG4gICAgICAgIGluZGljZXNBdHRyaWJ1dGUubm9ybWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgZ2VvbWV0cnkuc2V0QXR0cmlidXRlKCdpbmRpY2VzJywgaW5kaWNlc0F0dHJpYnV0ZSk7XHJcbiAgICB9XHJcbiAgICBhZGROb3JtYWxBdHRyaWJ1dGUoZ2VvbWV0cnksIG51bVBvaW50cykge1xyXG4gICAgICAgIGlmICghZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdub3JtYWwnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KG51bVBvaW50cyAqIDMpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ25vcm1hbCcsIG5ldyBCdWZmZXJBdHRyaWJ1dGUobmV3IEZsb2F0MzJBcnJheShidWZmZXIpLCAzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNBdHRyaWJ1dGUocHJvcGVydHksIG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQocHJvcGVydHksIDEwKSA9PT0gbmFtZTtcclxuICAgIH1cclxufVxyXG5CaW5hcnlMb2FkZXIuV09SS0VSX1BPT0wgPSBuZXcgV29ya2VyUG9vbCgzMiwgcmVxdWlyZSgnLi4vd29ya2Vycy9iaW5hcnktZGVjb2Rlci53b3JrZXIuanMnKS5kZWZhdWx0KTtcclxuIiwiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb252ZXJ0ZWQgdG8gVHlwZXNjcmlwdCBhbmQgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuaW1wb3J0IHsgQm94MywgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgUG9pbnRBdHRyaWJ1dGVzIH0gZnJvbSAnLi4vcG9pbnQtYXR0cmlidXRlcyc7XHJcbmltcG9ydCB7IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeSB9IGZyb20gJy4uL3BvaW50LWNsb3VkLW9jdHJlZS1nZW9tZXRyeSc7XHJcbmltcG9ydCB7IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUgfSBmcm9tICcuLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnktbm9kZSc7XHJcbmltcG9ydCB7IGNyZWF0ZUNoaWxkQUFCQiB9IGZyb20gJy4uL3V0aWxzL2JvdW5kcyc7XHJcbmltcG9ydCB7IGdldEluZGV4RnJvbU5hbWUsIGhhbmRsZUZhaWxlZFJlcXVlc3QgfSBmcm9tICcuLi91dGlscy91dGlscyc7XHJcbmltcG9ydCB7IFZlcnNpb24gfSBmcm9tICcuLi92ZXJzaW9uJztcclxuaW1wb3J0IHsgQmluYXJ5TG9hZGVyIH0gZnJvbSAnLi9iaW5hcnktbG9hZGVyJztcclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB1cmxcclxuICogICAgVGhlIHVybCBvZiB0aGUgcG9pbnQgY2xvdWQgZmlsZSAodXN1YWxseSBjbG91ZC5qcykuXHJcbiAqIEBwYXJhbSBnZXRVcmxcclxuICogICAgRnVuY3Rpb24gd2hpY2ggcmVjZWl2ZXMgdGhlIHJlbGF0aXZlIFVSTCBvZiBhIHBvaW50IGNsb3VkIGNodW5rIGZpbGUgd2hpY2ggaXMgdG8gYmUgbG9hZGVkXHJcbiAqICAgIGFuZCBzaG91ZCByZXR1cm4gYSBuZXcgdXJsIChlLmcuIHNpZ25lZCkgaW4gdGhlIGZvcm0gb2YgYSBzdHJpbmcgb3IgYSBwcm9taXNlLlxyXG4gKiBAcGFyYW0geGhyUmVxdWVzdCBBbiBhcnJvdyBmdW5jdGlvbiBmb3IgYSBmZXRjaCByZXF1ZXN0XHJcbiAqIEByZXR1cm5zXHJcbiAqICAgIEFuIG9ic2VydmFibGUgd2hpY2ggZW1pdHMgb25jZSB3aGVuIHRoZSBmaXJzdCBMT0Qgb2YgdGhlIHBvaW50IGNsb3VkIGlzIGxvYWRlZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkUE9DKHVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdldFVybCh1cmwpKS50aGVuKHRyYW5zZm9ybWVkVXJsID0+IHtcclxuICAgICAgICByZXR1cm4geGhyUmVxdWVzdCh0cmFuc2Zvcm1lZFVybCwgeyBtb2RlOiAnY29ycycgfSlcclxuICAgICAgICAgICAgLnRoZW4ocmVzID0+IGhhbmRsZUZhaWxlZFJlcXVlc3QocmVzKSlcclxuICAgICAgICAgICAgLnRoZW4ob2tSZXMgPT4gb2tSZXMuanNvbigpKVxyXG4gICAgICAgICAgICAudGhlbihwYXJzZSh0cmFuc2Zvcm1lZFVybCwgZ2V0VXJsLCB4aHJSZXF1ZXN0KSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZSh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCkge1xyXG4gICAgcmV0dXJuIChkYXRhKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBvZmZzZXQsIGJvdW5kaW5nQm94LCB0aWdodEJvdW5kaW5nQm94IH0gPSBnZXRCb3VuZGluZ0JveGVzKGRhdGEpO1xyXG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBCaW5hcnlMb2FkZXIoe1xyXG4gICAgICAgICAgICBnZXRVcmwsXHJcbiAgICAgICAgICAgIHZlcnNpb246IGRhdGEudmVyc2lvbixcclxuICAgICAgICAgICAgYm91bmRpbmdCb3gsXHJcbiAgICAgICAgICAgIHNjYWxlOiBkYXRhLnNjYWxlLFxyXG4gICAgICAgICAgICB4aHJSZXF1ZXN0LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHBjbyA9IG5ldyBQb2ludENsb3VkT2N0cmVlR2VvbWV0cnkobG9hZGVyLCBib3VuZGluZ0JveCwgdGlnaHRCb3VuZGluZ0JveCwgb2Zmc2V0LCB4aHJSZXF1ZXN0KTtcclxuICAgICAgICBwY28udXJsID0gdXJsO1xyXG4gICAgICAgIHBjby5vY3RyZWVEaXIgPSBkYXRhLm9jdHJlZURpcjtcclxuICAgICAgICBwY28ubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgIHBjby5zcGFjaW5nID0gZGF0YS5zcGFjaW5nO1xyXG4gICAgICAgIHBjby5oaWVyYXJjaHlTdGVwU2l6ZSA9IGRhdGEuaGllcmFyY2h5U3RlcFNpemU7XHJcbiAgICAgICAgcGNvLnByb2plY3Rpb24gPSBkYXRhLnByb2plY3Rpb247XHJcbiAgICAgICAgcGNvLm9mZnNldCA9IG9mZnNldDtcclxuICAgICAgICBwY28ucG9pbnRBdHRyaWJ1dGVzID0gbmV3IFBvaW50QXR0cmlidXRlcyhkYXRhLnBvaW50QXR0cmlidXRlcyk7XHJcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB7fTtcclxuICAgICAgICBjb25zdCB2ZXJzaW9uID0gbmV3IFZlcnNpb24oZGF0YS52ZXJzaW9uKTtcclxuICAgICAgICByZXR1cm4gbG9hZFJvb3QocGNvLCBkYXRhLCBub2RlcywgdmVyc2lvbikudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uLnVwVG8oJzEuNCcpKSB7XHJcbiAgICAgICAgICAgICAgICBsb2FkUmVtYWluaW5nSGllcmFyY2h5KHBjbywgZGF0YSwgbm9kZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBjby5ub2RlcyA9IG5vZGVzO1xyXG4gICAgICAgICAgICByZXR1cm4gcGNvO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0JveGVzKGRhdGEpIHtcclxuICAgIGNvbnN0IG1pbiA9IG5ldyBWZWN0b3IzKGRhdGEuYm91bmRpbmdCb3gubHgsIGRhdGEuYm91bmRpbmdCb3gubHksIGRhdGEuYm91bmRpbmdCb3gubHopO1xyXG4gICAgY29uc3QgbWF4ID0gbmV3IFZlY3RvcjMoZGF0YS5ib3VuZGluZ0JveC51eCwgZGF0YS5ib3VuZGluZ0JveC51eSwgZGF0YS5ib3VuZGluZ0JveC51eik7XHJcbiAgICBjb25zdCBib3VuZGluZ0JveCA9IG5ldyBCb3gzKG1pbiwgbWF4KTtcclxuICAgIGNvbnN0IHRpZ2h0Qm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xyXG4gICAgY29uc3Qgb2Zmc2V0ID0gbWluLmNsb25lKCk7XHJcbiAgICBpZiAoZGF0YS50aWdodEJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgY29uc3QgeyBseCwgbHksIGx6LCB1eCwgdXksIHV6IH0gPSBkYXRhLnRpZ2h0Qm91bmRpbmdCb3g7XHJcbiAgICAgICAgdGlnaHRCb3VuZGluZ0JveC5taW4uc2V0KGx4LCBseSwgbHopO1xyXG4gICAgICAgIHRpZ2h0Qm91bmRpbmdCb3gubWF4LnNldCh1eCwgdXksIHV6KTtcclxuICAgIH1cclxuICAgIGJvdW5kaW5nQm94Lm1pbi5zdWIob2Zmc2V0KTtcclxuICAgIGJvdW5kaW5nQm94Lm1heC5zdWIob2Zmc2V0KTtcclxuICAgIHRpZ2h0Qm91bmRpbmdCb3gubWluLnN1YihvZmZzZXQpO1xyXG4gICAgdGlnaHRCb3VuZGluZ0JveC5tYXguc3ViKG9mZnNldCk7XHJcbiAgICByZXR1cm4geyBvZmZzZXQsIGJvdW5kaW5nQm94LCB0aWdodEJvdW5kaW5nQm94IH07XHJcbn1cclxuZnVuY3Rpb24gbG9hZFJvb3QocGNvLCBkYXRhLCBub2RlcywgdmVyc2lvbikge1xyXG4gICAgY29uc3QgbmFtZSA9ICdyJztcclxuICAgIGNvbnN0IHJvb3QgPSBuZXcgUG9pbnRDbG91ZE9jdHJlZUdlb21ldHJ5Tm9kZShuYW1lLCBwY28sIHBjby5ib3VuZGluZ0JveCk7XHJcbiAgICByb290Lmhhc0NoaWxkcmVuID0gdHJ1ZTtcclxuICAgIHJvb3Quc3BhY2luZyA9IHBjby5zcGFjaW5nO1xyXG4gICAgaWYgKHZlcnNpb24udXBUbygnMS41JykpIHtcclxuICAgICAgICByb290Lm51bVBvaW50cyA9IGRhdGEuaGllcmFyY2h5WzBdWzFdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcm9vdC5udW1Qb2ludHMgPSAwO1xyXG4gICAgfVxyXG4gICAgcGNvLnJvb3QgPSByb290O1xyXG4gICAgbm9kZXNbbmFtZV0gPSByb290O1xyXG4gICAgcmV0dXJuIHBjby5yb290LmxvYWQoKTtcclxufVxyXG5mdW5jdGlvbiBsb2FkUmVtYWluaW5nSGllcmFyY2h5KHBjbywgZGF0YSwgbm9kZXMpIHtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBbbmFtZSwgbnVtUG9pbnRzXSA9IGRhdGEuaGllcmFyY2h5W2ldO1xyXG4gICAgICAgIGNvbnN0IHsgaW5kZXgsIHBhcmVudE5hbWUsIGxldmVsIH0gPSBwYXJzZU5hbWUobmFtZSk7XHJcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGVzW3BhcmVudE5hbWVdO1xyXG4gICAgICAgIGNvbnN0IGJvdW5kaW5nQm94ID0gY3JlYXRlQ2hpbGRBQUJCKHBhcmVudE5vZGUuYm91bmRpbmdCb3gsIGluZGV4KTtcclxuICAgICAgICBjb25zdCBub2RlID0gbmV3IFBvaW50Q2xvdWRPY3RyZWVHZW9tZXRyeU5vZGUobmFtZSwgcGNvLCBib3VuZGluZ0JveCk7XHJcbiAgICAgICAgbm9kZS5sZXZlbCA9IGxldmVsO1xyXG4gICAgICAgIG5vZGUubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xyXG4gICAgICAgIG5vZGUuc3BhY2luZyA9IHBjby5zcGFjaW5nIC8gTWF0aC5wb3coMiwgbm9kZS5sZXZlbCk7XHJcbiAgICAgICAgbm9kZXNbbmFtZV0gPSBub2RlO1xyXG4gICAgICAgIHBhcmVudE5vZGUuYWRkQ2hpbGQobm9kZSk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VOYW1lKG5hbWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaW5kZXg6IGdldEluZGV4RnJvbU5hbWUobmFtZSksXHJcbiAgICAgICAgcGFyZW50TmFtZTogbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKSxcclxuICAgICAgICBsZXZlbDogbmFtZS5sZW5ndGggLSAxLFxyXG4gICAgfTtcclxufVxyXG4iLCJleHBvcnQgKiBmcm9tICcuL2JpbmFyeS1sb2FkZXInO1xyXG5leHBvcnQgKiBmcm9tICcuL2xvYWQtcG9jJztcclxuZXhwb3J0ICogZnJvbSAnLi90eXBlcyc7XHJcbiIsImltcG9ydCB7IFNwaGVyZSB9IGZyb20gJ3RocmVlJztcclxuZXhwb3J0IGNsYXNzIE9jdHJlZUdlb21ldHJ5Tm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBvY3RyZWVHZW9tZXRyeSwgYm91bmRpbmdCb3gpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMub2N0cmVlR2VvbWV0cnkgPSBvY3RyZWVHZW9tZXRyeTtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3g7XHJcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZhaWxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0xlYWZOb2RlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzVHJlZU5vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzR2VvbWV0cnlOb2RlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW1xyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsLFxyXG4gICAgICAgICAgICBudWxsXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLmlkID0gT2N0cmVlR2VvbWV0cnlOb2RlLklEQ291bnQrKztcclxuICAgICAgICB0aGlzLmluZGV4ID0gcGFyc2VJbnQobmFtZS5jaGFyQXQobmFtZS5sZW5ndGggLSAxKSk7XHJcbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nQm94LmdldEJvdW5kaW5nU3BoZXJlKG5ldyBTcGhlcmUoKSk7XHJcbiAgICAgICAgdGhpcy50aWdodEJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcclxuICAgICAgICB0aGlzLm51bVBvaW50cyA9IDA7XHJcbiAgICAgICAgdGhpcy5vbmVUaW1lRGlzcG9zZUhhbmRsZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRMZXZlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sZXZlbDtcclxuICAgIH1cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlZDtcclxuICAgIH1cclxuICAgIGdldEJvdW5kaW5nU3BoZXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgfVxyXG4gICAgZ2V0Qm91bmRpbmdCb3goKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3g7XHJcbiAgICB9XHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLm9jdHJlZUdlb21ldHJ5Lm51bU5vZGVzTG9hZGluZyA+PSB0aGlzLm9jdHJlZUdlb21ldHJ5Lm1heE51bU5vZGVzTG9hZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5vY3RyZWVHZW9tZXRyeS5sb2FkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGBMb2FkZXIgbm90IGluaXRpYWxpemVkIGZvciAke3RoaXMubmFtZX1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2N0cmVlR2VvbWV0cnkubG9hZGVyLmxvYWQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBnZXROdW1Qb2ludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtUG9pbnRzO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5nZW9tZXRyeSAmJiB0aGlzLnBhcmVudCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMub25lVGltZURpc3Bvc2VIYW5kbGVyc1tpXTtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uZVRpbWVEaXNwb3NlSGFuZGxlcnMgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB0cmF2ZXJzZShjYiwgaW5jbHVkZVNlbGYgPSB0cnVlKSB7XHJcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBpbmNsdWRlU2VsZiA/IFt0aGlzXSA6IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50O1xyXG4gICAgICAgIHdoaWxlICgoY3VycmVudCA9IHN0YWNrLnBvcCgpKSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNiKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGN1cnJlbnQuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk9jdHJlZUdlb21ldHJ5Tm9kZS5JRENvdW50ID0gMDtcclxuT2N0cmVlR2VvbWV0cnlOb2RlLklEQ291bnQgPSAwO1xyXG4iLCIvKipcclxuICogU29tZSB0eXBlcyBvZiBwb3NzaWJsZSBwb2ludCBhdHRyaWJ1dGUgZGF0YSBmb3JtYXRzXHJcbiAqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuY29uc3QgUG9pbnRBdHRyaWJ1dGVUeXBlcyA9IHtcclxuICAgIERBVEFfVFlQRV9ET1VCTEU6IHsgb3JkaW5hbDogMCwgbmFtZTogJ2RvdWJsZScsIHNpemU6IDggfSxcclxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBuYW1lOiAnZmxvYXQnLCBzaXplOiA0IH0sXHJcbiAgICBEQVRBX1RZUEVfSU5UODogeyBvcmRpbmFsOiAyLCBuYW1lOiAnaW50OCcsIHNpemU6IDEgfSxcclxuICAgIERBVEFfVFlQRV9VSU5UODogeyBvcmRpbmFsOiAzLCBuYW1lOiAndWludDgnLCBzaXplOiAxIH0sXHJcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgbmFtZTogJ2ludDE2Jywgc2l6ZTogMiB9LFxyXG4gICAgREFUQV9UWVBFX1VJTlQxNjogeyBvcmRpbmFsOiA1LCBuYW1lOiAndWludDE2Jywgc2l6ZTogMiB9LFxyXG4gICAgREFUQV9UWVBFX0lOVDMyOiB7IG9yZGluYWw6IDYsIG5hbWU6ICdpbnQzMicsIHNpemU6IDQgfSxcclxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgbmFtZTogJ3VpbnQzMicsIHNpemU6IDQgfSxcclxuICAgIERBVEFfVFlQRV9JTlQ2NDogeyBvcmRpbmFsOiA4LCBuYW1lOiAnaW50NjQnLCBzaXplOiA4IH0sXHJcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIG5hbWU6ICd1aW50NjQnLCBzaXplOiA4IH1cclxufTtcclxubGV0IGkgPSAwO1xyXG5mb3IgKGNvbnN0IG9iaiBpbiBQb2ludEF0dHJpYnV0ZVR5cGVzKSB7XHJcbiAgICBQb2ludEF0dHJpYnV0ZVR5cGVzW2ldID0gUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdO1xyXG4gICAgaSsrO1xyXG59XHJcbmV4cG9ydCB7IFBvaW50QXR0cmlidXRlVHlwZXMgfTtcclxuY2xhc3MgUG9pbnRBdHRyaWJ1dGUge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgbnVtRWxlbWVudHMsIHJhbmdlID0gW0luZmluaXR5LCAtSW5maW5pdHldLCB1cmkgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5udW1FbGVtZW50cyA9IG51bUVsZW1lbnRzO1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcclxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gdGhpcy5udW1FbGVtZW50cyAqIHRoaXMudHlwZS5zaXplO1xyXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSAnJztcclxuICAgIH1cclxufVxyXG5leHBvcnQgeyBQb2ludEF0dHJpYnV0ZSB9O1xyXG5leHBvcnQgY29uc3QgUE9JTlRfQVRUUklCVVRFUyA9IHtcclxuICAgIFBPU0lUSU9OX0NBUlRFU0lBTjogbmV3IFBvaW50QXR0cmlidXRlKCdQT1NJVElPTl9DQVJURVNJQU4nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXHJcbiAgICBSR0JBX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcclxuICAgIENPTE9SX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCA0KSxcclxuICAgIFJHQl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgMyksXHJcbiAgICBOT1JNQUxfRkxPQVRTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9GTE9BVFMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXHJcbiAgICBJTlRFTlNJVFk6IG5ldyBQb2ludEF0dHJpYnV0ZSgnSU5URU5TSVRZJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcclxuICAgIENMQVNTSUZJQ0FUSU9OOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NMQVNTSUZJQ0FUSU9OJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxyXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfU1BIRVJFTUFQUEVEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxyXG4gICAgTk9STUFMX09DVDE2OiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9PQ1QxNicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcclxuICAgIE5PUk1BTDogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUwnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMyksXHJcbiAgICBSRVRVUk5fTlVNQkVSOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1JFVFVSTl9OVU1CRVInLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXHJcbiAgICBOVU1CRVJfT0ZfUkVUVVJOUzogbmV3IFBvaW50QXR0cmlidXRlKCdOVU1CRVJfT0ZfUkVUVVJOUycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcclxuICAgIFNPVVJDRV9JRDogbmV3IFBvaW50QXR0cmlidXRlKCdTT1VSQ0VfSUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UMTYsIDEpLFxyXG4gICAgSU5ESUNFUzogbmV3IFBvaW50QXR0cmlidXRlKCdJTkRJQ0VTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLCAxKSxcclxuICAgIFNQQUNJTkc6IG5ldyBQb2ludEF0dHJpYnV0ZSgnU1BBQ0lORycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAxKSxcclxuICAgIEdQU19USU1FOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0dQU19USU1FJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRE9VQkxFLCAxKVxyXG59O1xyXG5leHBvcnQgY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50QXR0cmlidXRlcywgYXR0cmlidXRlcyA9IFtdLCBieXRlU2l6ZSA9IDAsIHNpemUgPSAwLCB2ZWN0b3JzID0gW10pIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZTtcclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XHJcbiAgICAgICAgaWYgKHBvaW50QXR0cmlidXRlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZXNbaV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChwb2ludEF0dHJpYnV0ZSkge1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcclxuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xyXG4gICAgfVxyXG4gICAgYWRkVmVjdG9yKHZlY3Rvcikge1xyXG4gICAgICAgIHRoaXMudmVjdG9ycy5wdXNoKHZlY3Rvcik7XHJcbiAgICB9XHJcbiAgICBoYXNOb3JtYWxzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfU1BIRVJFTUFQUEVEIHx8XHJcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfRkxPQVRTIHx8XHJcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUwgfHxcclxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9PQ1QxNikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoYXR0ciA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8vIENyZWF0ZSBlbnVtcyBmb3IgZGlmZmVyZW50IHR5cGVzIG9mIHdvcmtlcnNcclxuZXhwb3J0IHZhciBXb3JrZXJUeXBlO1xyXG4oZnVuY3Rpb24gKFdvcmtlclR5cGUpIHtcclxuICAgIFdvcmtlclR5cGVbXCJERUNPREVSX1dPUktFUlwiXSA9IFwiREVDT0RFUl9XT1JLRVJcIjtcclxuICAgIFdvcmtlclR5cGVbXCJERUNPREVSX1dPUktFUl9HTFRGXCJdID0gXCJERUNPREVSX1dPUktFUl9HTFRGXCI7XHJcbn0pKFdvcmtlclR5cGUgfHwgKFdvcmtlclR5cGUgPSB7fSkpO1xyXG4vLyBXb3JrZXIgSlMgbmFtZXM6ICdCaW5hcnlEZWNvZGVyV29ya2VyLmpzJywgJ0RFTVdvcmtlci5qcycsICdFcHRCaW5hcnlEZWNvZGVyV29ya2VyLmpzJywgJ0VwdExhc3ppcERlY29kZXJXb3JrZXIuanMnLFxyXG4vLyBFcHRac3RhbmRhcmREZWNvZGVyX3ByZWFtYmxlLmpzJywgJ0VwdFpzdGFuZGFyZERlY29kZXJXb3JrZXIuanMnLCAnTEFTRGVjb2Rlcldvcmtlci5qcycsICdMQVNMQVpXb3JrZXIuanMnLCAnTGF6TG9hZGVyV29ya2VyLmpzJ1xyXG5mdW5jdGlvbiBjcmVhdGVXb3JrZXIodHlwZSkge1xyXG4gICAgLy8gY29uc29sZS5sb2codHlwZSlcclxuICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgIGNhc2UgV29ya2VyVHlwZS5ERUNPREVSX1dPUktFUjoge1xyXG4gICAgICAgICAgICBjb25zdCBEZWNvZGVyV29ya2VyID0gcmVxdWlyZSgnLi9kZWNvZGVyLndvcmtlci5qcycpLmRlZmF1bHQ7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjb2RlcldvcmtlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFdvcmtlclR5cGUuREVDT0RFUl9XT1JLRVJfR0xURjoge1xyXG4gICAgICAgICAgICBjb25zdCBEZWNvZGVyV29ya2VyX0dMVEYgPSByZXF1aXJlKCcuL2dsdGYtZGVjb2Rlci53b3JrZXIuanMnKS5kZWZhdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IERlY29kZXJXb3JrZXJfR0xURigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gd29ya2VyIHR5cGUnKTtcclxuICAgIH1cclxufVxyXG5leHBvcnQgY2xhc3MgV29ya2VyUG9vbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvLyBXb3JrZXJzIHdpbGwgYmUgYW4gb2JqZWN0IHRoYXQgaGFzIGEga2V5IGZvciBlYWNoIHdvcmtlciB0eXBlIGFuZCB0aGUgdmFsdWUgaXMgYW4gYXJyYXkgb2YgV29ya2VycyB0aGF0IGNhbiBiZSBlbXB0eVxyXG4gICAgICAgIHRoaXMud29ya2VycyA9IHsgREVDT0RFUl9XT1JLRVI6IFtdLCBERUNPREVSX1dPUktFUl9HTFRGOiBbXSB9O1xyXG4gICAgfVxyXG4gICAgZ2V0V29ya2VyKHdvcmtlclR5cGUpIHtcclxuICAgICAgICAvLyBUaHJvdyBlcnJvciBpZiB3b3JrZXJUeXBlIGlzIG5vdCByZWNvZ25pemVkXHJcbiAgICAgICAgaWYgKHRoaXMud29ya2Vyc1t3b3JrZXJUeXBlXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB3b3JrZXIgdHlwZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHaXZlbiBhIHdvcmtlciBVUkwsIGlmIFVSTCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgd29ya2VyIG9iamVjdCwgY3JlYXRlIGEgbmV3IGFycmF5IHdpdGggdGhlIFVSTCBhcyBhIGtleVxyXG4gICAgICAgIGlmICh0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IGNyZWF0ZVdvcmtlcih3b3JrZXJUeXBlKTtcclxuICAgICAgICAgICAgdGhpcy53b3JrZXJzW3dvcmtlclR5cGVdLnB1c2god29ya2VyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd29ya2VyID0gdGhpcy53b3JrZXJzW3dvcmtlclR5cGVdLnBvcCgpO1xyXG4gICAgICAgIGlmICh3b3JrZXIgPT09IHVuZGVmaW5lZCkgeyAvLyBUeXBlc2NyaXB0IG5lZWRzIHRoaXNcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB3b3JrZXJzIGF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXR1cm4gdGhlIGxhc3Qgd29ya2VyIGluIHRoZSBhcnJheSBhbmQgcmVtb3ZlIGl0IGZyb20gdGhlIGFycmF5XHJcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcclxuICAgIH1cclxuICAgIHJldHVybldvcmtlcih3b3JrZXJUeXBlLCB3b3JrZXIpIHtcclxuICAgICAgICB0aGlzLndvcmtlcnNbd29ya2VyVHlwZV0ucHVzaCh3b3JrZXIpO1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBleHRyYWN0QmFzZVBhdGgodXJsKSB7XHJcbiAgICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBidWlsZFVybChiYXNlUGF0aCwgZmlsZU5hbWUpIHtcclxuICAgIHJldHVybiBgJHtiYXNlUGF0aH0ke2ZpbGVOYW1lfWA7XHJcbn1cclxuIiwiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlLCBCdWZmZXJHZW9tZXRyeSwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgQm94MywgU3BoZXJlIH0gZnJvbSAndGhyZWUnO1xyXG5pbXBvcnQgeyBPY3RyZWVHZW9tZXRyeSB9IGZyb20gJy4vb2N0cmVlLWdlb21ldHJ5JztcclxuaW1wb3J0IHsgT2N0cmVlR2VvbWV0cnlOb2RlIH0gZnJvbSAnLi9vY3RyZWUtZ2VvbWV0cnktbm9kZSc7XHJcbmltcG9ydCB7IFBvaW50QXR0cmlidXRlLCBQb2ludEF0dHJpYnV0ZXMsIFBvaW50QXR0cmlidXRlVHlwZXMgfSBmcm9tICcuL3BvaW50LWF0dHJpYnV0ZXMnO1xyXG5pbXBvcnQgeyBXb3JrZXJQb29sLCBXb3JrZXJUeXBlIH0gZnJvbSAnLi93b3JrZXItcG9vbCc7XHJcbmltcG9ydCB7IGJ1aWxkVXJsLCBleHRyYWN0QmFzZVBhdGggfSBmcm9tICcuL3V0aWxzJztcclxuLy8gQnVmZmVyIGZpbGVzIGZvciBERUZBVUxUIGVuY29kaW5nXHJcbmV4cG9ydCBjb25zdCBISUVSQVJDSFlfRklMRSA9ICdoaWVyYXJjaHkuYmluJztcclxuZXhwb3J0IGNvbnN0IE9DVFJFRV9GSUxFID0gJ29jdHJlZS5iaW4nO1xyXG4vLyBEZWZhdWx0IGJ1ZmZlciBmaWxlcyBmb3IgR0xURiBlbmNvZGluZ1xyXG5leHBvcnQgY29uc3QgR0xURl9DT0xPUlNfRklMRSA9ICdjb2xvcnMuZ2xiaW4nO1xyXG5leHBvcnQgY29uc3QgR0xURl9QT1NJVElPTlNfRklMRSA9ICdwb3NpdGlvbnMuZ2xiaW4nO1xyXG5leHBvcnQgY2xhc3MgTm9kZUxvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXRVcmwsIHVybCwgd29ya2VyUG9vbCwgbWV0YWRhdGEpIHtcclxuICAgICAgICB0aGlzLmdldFVybCA9IGdldFVybDtcclxuICAgICAgICB0aGlzLnVybCA9IHVybDtcclxuICAgICAgICB0aGlzLndvcmtlclBvb2wgPSB3b3JrZXJQb29sO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcclxuICAgICAgICB0aGlzLmhpZXJhcmNoeVBhdGggPSAnJztcclxuICAgICAgICB0aGlzLm9jdHJlZVBhdGggPSAnJztcclxuICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gJyc7XHJcbiAgICAgICAgdGhpcy5nbHRmUG9zaXRpb25zUGF0aCA9ICcnO1xyXG4gICAgfVxyXG4gICAgYXN5bmMgbG9hZChub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUubG9hZGVkIHx8IG5vZGUubG9hZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5vZGUubG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgbm9kZS5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmcrKztcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5sb2FkSGllcmFyY2h5KG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgYnl0ZU9mZnNldCwgYnl0ZVNpemUgfSA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgfHwgYnl0ZVNpemUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdieXRlT2Zmc2V0IGFuZCBieXRlU2l6ZSBhcmUgcmVxdWlyZWQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgYnVmZmVyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5lbmNvZGluZyA9PT0gXCJHTFRGXCIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVybENvbG9ycyA9IGF3YWl0IHRoaXMuZ2V0VXJsKHRoaXMuZ2x0ZkNvbG9yc1BhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdXJsUG9zaXRpb25zID0gYXdhaXQgdGhpcy5nZXRVcmwodGhpcy5nbHRmUG9zaXRpb25zUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZVNpemUgPT09IEJpZ0ludCgwKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigwKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGxvYWRlZCBub2RlIHdpdGggMCBieXRlczogJHtub2RlLm5hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFBvc2l0aW9ucyA9IGJ5dGVPZmZzZXQgKiA0biAqIDNuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RQb3NpdGlvbnMgPSBieXRlT2Zmc2V0ICogNG4gKiAzbiArIGJ5dGVTaXplICogNG4gKiAzbiAtIDFuO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnNQb3NpdGlvbnMgPSB7IFJhbmdlOiBgYnl0ZXM9JHtmaXJzdFBvc2l0aW9uc30tJHtsYXN0UG9zaXRpb25zfWAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVBvc2l0aW9ucyA9IGF3YWl0IGZldGNoKHVybFBvc2l0aW9ucywgeyBoZWFkZXJzOiBoZWFkZXJzUG9zaXRpb25zIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclBvc2l0aW9ucyA9IGF3YWl0IHJlc3BvbnNlUG9zaXRpb25zLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDb2xvcnMgPSBieXRlT2Zmc2V0ICogNG47XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdENvbG9ycyA9IGJ5dGVPZmZzZXQgKiA0biArIGJ5dGVTaXplICogNG4gLSAxbjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzQ29sb3JzID0geyBSYW5nZTogYGJ5dGVzPSR7Zmlyc3RDb2xvcnN9LSR7bGFzdENvbG9yc31gIH07XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb2xvcnMgPSBhd2FpdCBmZXRjaCh1cmxDb2xvcnMsIHsgaGVhZGVyczogaGVhZGVyc0NvbG9ycyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJDb2xvcnMgPSBhd2FpdCByZXNwb25zZUNvbG9ycy5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGFwcGVuZEJ1ZmZlcihidWZmZXJQb3NpdGlvbnMsIGJ1ZmZlckNvbG9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cmxPY3RyZWUgPSBhd2FpdCB0aGlzLmdldFVybCh0aGlzLm9jdHJlZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBieXRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IGJ5dGVPZmZzZXQgKyBieXRlU2l6ZSAtIEJpZ0ludCgxKTtcclxuICAgICAgICAgICAgICAgIGlmIChieXRlU2l6ZSA9PT0gQmlnSW50KDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgbG9hZGVkIG5vZGUgd2l0aCAwIGJ5dGVzOiAke25vZGUubmFtZX1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7IFJhbmdlOiBgYnl0ZXM9JHtmaXJzdH0tJHtsYXN0fWAgfTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybE9jdHJlZSwgeyBoZWFkZXJzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgd29ya2VyVHlwZSA9IHRoaXMubWV0YWRhdGEuZW5jb2RpbmcgPT09ICdHTFRGJyA/IFdvcmtlclR5cGUuREVDT0RFUl9XT1JLRVJfR0xURiA6IFdvcmtlclR5cGUuREVDT0RFUl9XT1JLRVI7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMud29ya2VyUG9vbC5nZXRXb3JrZXIod29ya2VyVHlwZSk7XHJcbiAgICAgICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBkYXRhLmF0dHJpYnV0ZUJ1ZmZlcnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndvcmtlclBvb2wucmV0dXJuV29ya2VyKHdvcmtlclR5cGUsIHdvcmtlcik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBidWZmZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYnVmZmVyc1twcm9wZXJ0eV0uYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eSA9PT0gJ3Bvc2l0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09ICdyZ2JhJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3JnYmEnLCBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDQsIHRydWUpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09ICdOT1JNQUwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciksIDMpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvcGVydHkgPT09ICdJTkRJQ0VTJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBVaW50OEFycmF5KGJ1ZmZlciksIDQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUubm9ybWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZSgnaW5kaWNlcycsIGJ1ZmZlckF0dHJpYnV0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJBdHRyaWJ1dGUgPSBuZXcgQnVmZmVyQXR0cmlidXRlKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoQXR0cmlidXRlID0gYnVmZmVyc1twcm9wZXJ0eV0uYXR0cmlidXRlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJBdHRyaWJ1dGUucG90cmVlID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBidWZmZXJzW3Byb3BlcnR5XS5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTogYnVmZmVyc1twcm9wZXJ0eV0uc2NhbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVjaXNlQnVmZmVyOiBidWZmZXJzW3Byb3BlcnR5XS5wcmVjaXNlQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGJhdGNoQXR0cmlidXRlLnJhbmdlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgYnVmZmVyQXR0cmlidXRlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBub2RlLmRlbnNpdHkgPSBkYXRhLmRlbnNpdHk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIG5vZGUub2N0cmVlR2VvbWV0cnkubnVtTm9kZXNMb2FkaW5nLS07XHJcbiAgICAgICAgICAgICAgICBub2RlLm9jdHJlZUdlb21ldHJ5Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG5vZGUudGlnaHRCb3VuZGluZ0JveCA9IHRoaXMuZ2V0VGlnaHRCb3VuZGluZ0JveChkYXRhLnRpZ2h0Qm91bmRpbmdCb3gpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZXMgPSBub2RlLm9jdHJlZUdlb21ldHJ5LnBvaW50QXR0cmlidXRlcztcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBub2RlLm9jdHJlZUdlb21ldHJ5LnNjYWxlO1xyXG4gICAgICAgICAgICBjb25zdCBib3ggPSBub2RlLmJvdW5kaW5nQm94O1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSBub2RlLm9jdHJlZUdlb21ldHJ5Lm9mZnNldC5jbG9uZSgpLmFkZChib3gubWluKTtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGJveC5tYXguY2xvbmUoKS5zdWIoYm94Lm1pbik7XHJcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IG1pbi5jbG9uZSgpLmFkZChzaXplKTtcclxuICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzID0gbm9kZS5udW1Qb2ludHM7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG5vZGUub2N0cmVlR2VvbWV0cnkubG9hZGVyLm9mZnNldDtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcclxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGVzOiBwb2ludEF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBzY2FsZTogc2NhbGUsXHJcbiAgICAgICAgICAgICAgICBtaW46IG1pbixcclxuICAgICAgICAgICAgICAgIG1heDogbWF4LFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogc2l6ZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgbnVtUG9pbnRzOiBudW1Qb2ludHNcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIFttZXNzYWdlLmJ1ZmZlcl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBub2RlLmxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBub2RlLmxvYWRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgbm9kZS5vY3RyZWVHZW9tZXRyeS5udW1Ob2Rlc0xvYWRpbmctLTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJzZUhpZXJhcmNoeShub2RlLCBidWZmZXIpIHtcclxuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcbiAgICAgICAgY29uc3QgYnl0ZXNQZXJOb2RlID0gMjI7XHJcbiAgICAgICAgY29uc3QgbnVtTm9kZXMgPSBidWZmZXIuYnl0ZUxlbmd0aCAvIGJ5dGVzUGVyTm9kZTtcclxuICAgICAgICBjb25zdCBvY3RyZWUgPSBub2RlLm9jdHJlZUdlb21ldHJ5O1xyXG4gICAgICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KG51bU5vZGVzKTtcclxuICAgICAgICBub2Rlc1swXSA9IG5vZGU7XHJcbiAgICAgICAgbGV0IG5vZGVQb3MgPSAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gbm9kZXNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB2aWV3LmdldFVpbnQ4KGkgKiBieXRlc1Blck5vZGUgKyAwKTtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGRNYXNrID0gdmlldy5nZXRVaW50OChpICogYnl0ZXNQZXJOb2RlICsgMSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG51bVBvaW50cyA9IHZpZXcuZ2V0VWludDMyKGkgKiBieXRlc1Blck5vZGUgKyAyLCB0cnVlKTtcclxuICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHZpZXcuZ2V0QmlnSW50NjQoaSAqIGJ5dGVzUGVyTm9kZSArIDYsIHRydWUpO1xyXG4gICAgICAgICAgICBjb25zdCBieXRlU2l6ZSA9IHZpZXcuZ2V0QmlnSW50NjQoaSAqIGJ5dGVzUGVyTm9kZSArIDE0LCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgcHJveHkgd2l0aCByZWFsIG5vZGVcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuYnl0ZU9mZnNldCA9IGJ5dGVPZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmJ5dGVTaXplID0gYnl0ZVNpemU7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm51bVBvaW50cyA9IG51bVBvaW50cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2FkIHByb3h5XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LmhpZXJhcmNoeUJ5dGVPZmZzZXQgPSBieXRlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5oaWVyYXJjaHlCeXRlU2l6ZSA9IGJ5dGVTaXplO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5udW1Qb2ludHMgPSBudW1Qb2ludHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2FkIHJlYWwgbm9kZVxyXG4gICAgICAgICAgICAgICAgY3VycmVudC5ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuYnl0ZVNpemUgPSBieXRlU2l6ZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubnVtUG9pbnRzID0gbnVtUG9pbnRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnQubm9kZVR5cGUgPSB0eXBlO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGRJbmRleCA9IDA7IGNoaWxkSW5kZXggPCA4OyBjaGlsZEluZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkRXhpc3RzID0gKDEgPDwgY2hpbGRJbmRleCAmIGNoaWxkTWFzaykgIT09IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkRXhpc3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5hbWUgPSBjdXJyZW50Lm5hbWUgKyBjaGlsZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRBQUJCID0gY3JlYXRlQ2hpbGRBQUJCKGN1cnJlbnQuYm91bmRpbmdCb3gsIGNoaWxkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBuZXcgT2N0cmVlR2VvbWV0cnlOb2RlKGNoaWxkTmFtZSwgb2N0cmVlLCBjaGlsZEFBQkIpO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQubmFtZSA9IGNoaWxkTmFtZTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnNwYWNpbmcgPSBjdXJyZW50LnNwYWNpbmcgLyAyO1xyXG4gICAgICAgICAgICAgICAgY2hpbGQubGV2ZWwgPSBjdXJyZW50LmxldmVsICsgMTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQuY2hpbGRyZW5bY2hpbGRJbmRleF0gPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1tub2RlUG9zXSA9IGNoaWxkO1xyXG4gICAgICAgICAgICAgICAgbm9kZVBvcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYXN5bmMgbG9hZEhpZXJhcmNoeShub2RlKSB7XHJcbiAgICAgICAgY29uc3QgeyBoaWVyYXJjaHlCeXRlT2Zmc2V0LCBoaWVyYXJjaHlCeXRlU2l6ZSB9ID0gbm9kZTtcclxuICAgICAgICBpZiAoaGllcmFyY2h5Qnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGhpZXJhcmNoeUJ5dGVTaXplID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoaWVyYXJjaHlCeXRlT2Zmc2V0IGFuZCBoaWVyYXJjaHlCeXRlU2l6ZSBhcmUgdW5kZWZpbmVkIGZvciBub2RlICR7bm9kZS5uYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBoaWVyYXJjaHlVcmwgPSBhd2FpdCB0aGlzLmdldFVybCh0aGlzLmhpZXJhcmNoeVBhdGgpO1xyXG4gICAgICAgIGNvbnN0IGZpcnN0ID0gaGllcmFyY2h5Qnl0ZU9mZnNldDtcclxuICAgICAgICBjb25zdCBsYXN0ID0gZmlyc3QgKyBoaWVyYXJjaHlCeXRlU2l6ZSAtIEJpZ0ludCgxKTtcclxuICAgICAgICBjb25zdCBoZWFkZXJzID0geyBSYW5nZTogYGJ5dGVzPSR7Zmlyc3R9LSR7bGFzdH1gIH07XHJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChoaWVyYXJjaHlVcmwsIHsgaGVhZGVycyB9KTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBhd2FpdCByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMucGFyc2VIaWVyYXJjaHkobm9kZSwgYnVmZmVyKTtcclxuICAgIH1cclxuICAgIGdldFRpZ2h0Qm91bmRpbmdCb3goeyBtaW4sIG1heCB9KSB7XHJcbiAgICAgICAgY29uc3QgYm94ID0gbmV3IEJveDMobmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkobWluKSwgbmV3IFZlY3RvcjMoKS5mcm9tQXJyYXkobWF4KSk7XHJcbiAgICAgICAgYm94Lm1heC5zdWIoYm94Lm1pbik7XHJcbiAgICAgICAgYm94Lm1pbi5zZXQoMCwgMCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIGJveDtcclxuICAgIH1cclxufVxyXG5jb25zdCB0bXBWZWMzID0gbmV3IFZlY3RvcjMoKTtcclxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRBQUJCKGFhYmIsIGluZGV4KSB7XHJcbiAgICBjb25zdCBtaW4gPSBhYWJiLm1pbi5jbG9uZSgpO1xyXG4gICAgY29uc3QgbWF4ID0gYWFiYi5tYXguY2xvbmUoKTtcclxuICAgIGNvbnN0IHNpemUgPSB0bXBWZWMzLnN1YlZlY3RvcnMobWF4LCBtaW4pO1xyXG4gICAgaWYgKChpbmRleCAmIDBiMDAwMSkgPiAwKSB7XHJcbiAgICAgICAgbWluLnogKz0gc2l6ZS56IC8gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1heC56IC09IHNpemUueiAvIDI7XHJcbiAgICB9XHJcbiAgICBpZiAoKGluZGV4ICYgMGIwMDEwKSA+IDApIHtcclxuICAgICAgICBtaW4ueSArPSBzaXplLnkgLyAyO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWF4LnkgLT0gc2l6ZS55IC8gMjtcclxuICAgIH1cclxuICAgIGlmICgoaW5kZXggJiAwYjAxMDApID4gMCkge1xyXG4gICAgICAgIG1pbi54ICs9IHNpemUueCAvIDI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBtYXgueCAtPSBzaXplLnggLyAyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBCb3gzKG1pbiwgbWF4KTtcclxufVxyXG5mdW5jdGlvbiBhcHBlbmRCdWZmZXIoYnVmZmVyMSwgYnVmZmVyMikge1xyXG4gICAgdmFyIHRtcCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEuYnl0ZUxlbmd0aCArIGJ1ZmZlcjIuYnl0ZUxlbmd0aCk7XHJcbiAgICB0bXAuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZmZlcjEpLCAwKTtcclxuICAgIHRtcC5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyMiksIGJ1ZmZlcjEuYnl0ZUxlbmd0aCk7XHJcbiAgICByZXR1cm4gdG1wLmJ1ZmZlcjtcclxufVxyXG5jb25zdCB0eXBlbmFtZVR5cGVhdHRyaWJ1dGVNYXAgPSB7XHJcbiAgICBkb3VibGU6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0RPVUJMRSxcclxuICAgIGZsb2F0OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCxcclxuICAgIGludDg6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsXHJcbiAgICB1aW50ODogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsXHJcbiAgICBpbnQxNjogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UMTYsXHJcbiAgICB1aW50MTY6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNixcclxuICAgIGludDMyOiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQzMixcclxuICAgIHVpbnQzMjogUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDMyLFxyXG4gICAgaW50NjQ6IFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDY0LFxyXG4gICAgdWludDY0OiBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UNjRcclxufTtcclxuZXhwb3J0IGNsYXNzIE9jdHJlZUxvYWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXRVcmwsIHVybCkge1xyXG4gICAgICAgIHRoaXMud29ya2VyUG9vbCA9IG5ldyBXb3JrZXJQb29sKCk7XHJcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9ICcnO1xyXG4gICAgICAgIHRoaXMuaGllcmFyY2h5UGF0aCA9ICcnO1xyXG4gICAgICAgIHRoaXMub2N0cmVlUGF0aCA9ICcnO1xyXG4gICAgICAgIHRoaXMuZ2x0ZkNvbG9yc1BhdGggPSAnJztcclxuICAgICAgICB0aGlzLmdsdGZQb3NpdGlvbnNQYXRoID0gJyc7XHJcbiAgICAgICAgdGhpcy5nZXRVcmwgPSBnZXRVcmw7XHJcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IGV4dHJhY3RCYXNlUGF0aCh1cmwpO1xyXG4gICAgICAgIHRoaXMuaGllcmFyY2h5UGF0aCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVBhdGgsIEhJRVJBUkNIWV9GSUxFKTtcclxuICAgICAgICB0aGlzLm9jdHJlZVBhdGggPSBidWlsZFVybCh0aGlzLmJhc2VQYXRoLCBPQ1RSRUVfRklMRSk7XHJcbiAgICAgICAgLy8gV2UgZGVmYXVsdCB0byB0aGUga25vd24gbmFtaW5nIGNvbnZlbnRpb24gZm9yIGdsVEYgZGF0YXNldHNcclxuICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gYnVpbGRVcmwodGhpcy5iYXNlUGF0aCwgR0xURl9DT0xPUlNfRklMRSk7XHJcbiAgICAgICAgdGhpcy5nbHRmUG9zaXRpb25zUGF0aCA9IGJ1aWxkVXJsKHRoaXMuYmFzZVBhdGgsIEdMVEZfUE9TSVRJT05TX0ZJTEUpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHBhcnNlQXR0cmlidXRlcyhqc29uQXR0cmlidXRlcykge1xyXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgUG9pbnRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnRzID0geyByZ2I6ICdyZ2JhJyB9O1xyXG4gICAgICAgIGZvciAoY29uc3QganNvbkF0dHJpYnV0ZSBvZiBqc29uQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBjb25zdCB7IG5hbWUsIG51bUVsZW1lbnRzLCBtaW4sIG1heCwgYnVmZmVyVmlldyB9ID0ganNvbkF0dHJpYnV0ZTtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVuYW1lVHlwZWF0dHJpYnV0ZU1hcFtqc29uQXR0cmlidXRlLnR5cGVdO1xyXG4gICAgICAgICAgICBjb25zdCBwb3RyZWVBdHRyaWJ1dGVOYW1lID0gcmVwbGFjZW1lbnRzW25hbWVdID8gcmVwbGFjZW1lbnRzW25hbWVdIDogbmFtZTtcclxuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gbmV3IFBvaW50QXR0cmlidXRlKHBvdHJlZUF0dHJpYnV0ZU5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKTtcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlclZpZXcpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS51cmkgPSBidWZmZXJWaWV3LnVyaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobnVtRWxlbWVudHMgPT09IDEgJiYgbWluICYmIG1heCkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLnJhbmdlID0gW21pblswXSwgbWF4WzBdXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5yYW5nZSA9IFttaW4sIG1heF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdncHMtdGltZScpIHsgLy8gSEFDSzogR3VhcmQgYWdhaW5zdCBiYWQgZ3BzVGltZSByYW5nZSBpbiBtZXRhZGF0YSwgc2VlIHBvdHJlZS9wb3RyZWUjOTA5XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZS5yYW5nZVswXSA9PT0gJ251bWJlcicgJiYgYXR0cmlidXRlLnJhbmdlWzBdID09PSBhdHRyaWJ1dGUucmFuZ2VbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUucmFuZ2VbMV0gKz0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhdHRyaWJ1dGUuaW5pdGlhbFJhbmdlID0gYXR0cmlidXRlLnJhbmdlO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhhc05vcm1hbHMgPSBhdHRyaWJ1dGVzLmF0dHJpYnV0ZXMuZmluZCgoYSkgPT4gYS5uYW1lID09PSAnTm9ybWFsWCcpICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYXR0cmlidXRlcy5maW5kKChhKSA9PiBhLm5hbWUgPT09ICdOb3JtYWxZJykgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5hdHRyaWJ1dGVzLmZpbmQoKGEpID0+IGEubmFtZSA9PT0gJ05vcm1hbFonKSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICBpZiAoaGFzTm9ybWFscykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmVjdG9yID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdOT1JNQUwnLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFsnTm9ybWFsWCcsICdOb3JtYWxZJywgJ05vcm1hbFonXVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuYWRkVmVjdG9yKHZlY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcbiAgICBhc3luYyBsb2FkKHVybCwgeGhyUmVxdWVzdCkge1xyXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gYXdhaXQgdGhpcy5mZXRjaE1ldGFkYXRhKHVybCwgeGhyUmVxdWVzdCk7XHJcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9jdHJlZUxvYWRlci5wYXJzZUF0dHJpYnV0ZXMobWV0YWRhdGEuYXR0cmlidXRlcyk7XHJcbiAgICAgICAgdGhpcy5hcHBseUN1c3RvbUJ1ZmZlclVSSShtZXRhZGF0YS5lbmNvZGluZywgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5jcmVhdGVMb2FkZXIodXJsLCBtZXRhZGF0YSwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSB0aGlzLmNyZWF0ZUJvdW5kaW5nQm94KG1ldGFkYXRhKTtcclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldE9mZnNldChib3VuZGluZ0JveCk7XHJcbiAgICAgICAgY29uc3Qgb2N0cmVlID0gdGhpcy5pbml0aWFsaXplT2N0cmVlKGxvYWRlciwgdXJsLCBtZXRhZGF0YSwgYm91bmRpbmdCb3gsIG9mZnNldCwgYXR0cmlidXRlcyk7XHJcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuaW5pdGlhbGl6ZVJvb3ROb2RlKG9jdHJlZSwgYm91bmRpbmdCb3gsIG1ldGFkYXRhKTtcclxuICAgICAgICBvY3RyZWUucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgbG9hZGVyLmxvYWQocm9vdCk7XHJcbiAgICAgICAgcmV0dXJuIHsgZ2VvbWV0cnk6IG9jdHJlZSB9O1xyXG4gICAgfVxyXG4gICAgYXN5bmMgZmV0Y2hNZXRhZGF0YSh1cmwsIHhoclJlcXVlc3QpIHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHhoclJlcXVlc3QodXJsKTtcclxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gICAgfVxyXG4gICAgYXBwbHlDdXN0b21CdWZmZXJVUkkoZW5jb2RpbmcsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAvLyBPbmx5IGRhdGFzZXRzIHdpdGggR0xURiBlbmNvZGluZyBzdXBwb3J0IGN1c3RvbSBidWZmZXIgVVJJcyAtXHJcbiAgICAgICAgLy8gYXMgb3Bwb3NlZCB0byBkYXRhc2V0cyB3aXRoIERFRkFVTFQgZW5jb2RpbmcgY29taW5nIGZyb20gUG90cmVlQ29udmVydGVyXHJcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnR0xURicpIHtcclxuICAgICAgICAgICAgdGhpcy5nbHRmUG9zaXRpb25zUGF0aCA9IGF0dHJpYnV0ZXMuZ2V0QXR0cmlidXRlKFwicG9zaXRpb25cIik/LnVyaSA/PyB0aGlzLmdsdGZQb3NpdGlvbnNQYXRoO1xyXG4gICAgICAgICAgICB0aGlzLmdsdGZDb2xvcnNQYXRoID0gYXR0cmlidXRlcy5nZXRBdHRyaWJ1dGUoXCJyZ2JhXCIpPy51cmkgPz8gdGhpcy5nbHRmQ29sb3JzUGF0aDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjcmVhdGVMb2FkZXIodXJsLCBtZXRhZGF0YSwgYXR0cmlidXRlcykge1xyXG4gICAgICAgIGNvbnN0IGxvYWRlciA9IG5ldyBOb2RlTG9hZGVyKHRoaXMuZ2V0VXJsLCB1cmwsIHRoaXMud29ya2VyUG9vbCwgbWV0YWRhdGEpO1xyXG4gICAgICAgIGxvYWRlci5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICBsb2FkZXIuc2NhbGUgPSBtZXRhZGF0YS5zY2FsZTtcclxuICAgICAgICBsb2FkZXIub2Zmc2V0ID0gbWV0YWRhdGEub2Zmc2V0O1xyXG4gICAgICAgIGxvYWRlci5oaWVyYXJjaHlQYXRoID0gdGhpcy5oaWVyYXJjaHlQYXRoO1xyXG4gICAgICAgIGxvYWRlci5vY3RyZWVQYXRoID0gdGhpcy5vY3RyZWVQYXRoO1xyXG4gICAgICAgIGxvYWRlci5nbHRmQ29sb3JzUGF0aCA9IHRoaXMuZ2x0ZkNvbG9yc1BhdGg7XHJcbiAgICAgICAgbG9hZGVyLmdsdGZQb3NpdGlvbnNQYXRoID0gdGhpcy5nbHRmUG9zaXRpb25zUGF0aDtcclxuICAgICAgICByZXR1cm4gbG9hZGVyO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlQm91bmRpbmdCb3gobWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCBtaW4gPSBuZXcgVmVjdG9yMyguLi5tZXRhZGF0YS5ib3VuZGluZ0JveC5taW4pO1xyXG4gICAgICAgIGNvbnN0IG1heCA9IG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1heCk7XHJcbiAgICAgICAgY29uc3QgYm91bmRpbmdCb3ggPSBuZXcgQm94MyhtaW4sIG1heCk7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kaW5nQm94O1xyXG4gICAgfVxyXG4gICAgZ2V0T2Zmc2V0KGJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gYm91bmRpbmdCb3gubWluLmNsb25lKCk7XHJcbiAgICAgICAgYm91bmRpbmdCb3gubWluLnN1YihvZmZzZXQpO1xyXG4gICAgICAgIGJvdW5kaW5nQm94Lm1heC5zdWIob2Zmc2V0KTtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZU9jdHJlZShsb2FkZXIsIHVybCwgbWV0YWRhdGEsIGJvdW5kaW5nQm94LCBvZmZzZXQsIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICBjb25zdCBvY3RyZWUgPSBuZXcgT2N0cmVlR2VvbWV0cnkobG9hZGVyLCBib3VuZGluZ0JveCk7XHJcbiAgICAgICAgb2N0cmVlLnVybCA9IHVybDtcclxuICAgICAgICBvY3RyZWUuc3BhY2luZyA9IG1ldGFkYXRhLnNwYWNpbmc7XHJcbiAgICAgICAgb2N0cmVlLnNjYWxlID0gbWV0YWRhdGEuc2NhbGU7XHJcbiAgICAgICAgb2N0cmVlLnByb2plY3Rpb24gPSBtZXRhZGF0YS5wcm9qZWN0aW9uO1xyXG4gICAgICAgIG9jdHJlZS5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xyXG4gICAgICAgIG9jdHJlZS5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nQm94LmdldEJvdW5kaW5nU3BoZXJlKG5ldyBTcGhlcmUoKSk7XHJcbiAgICAgICAgb2N0cmVlLnRpZ2h0Qm91bmRpbmdTcGhlcmUgPSBib3VuZGluZ0JveC5nZXRCb3VuZGluZ1NwaGVyZShuZXcgU3BoZXJlKCkpO1xyXG4gICAgICAgIG9jdHJlZS50aWdodEJvdW5kaW5nQm94ID0gdGhpcy5nZXRUaWdodEJvdW5kaW5nQm94KG1ldGFkYXRhKTtcclxuICAgICAgICBvY3RyZWUub2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgICAgIG9jdHJlZS5wb2ludEF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG4gICAgICAgIHJldHVybiBvY3RyZWU7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplUm9vdE5vZGUob2N0cmVlLCBib3VuZGluZ0JveCwgbWV0YWRhdGEpIHtcclxuICAgICAgICBjb25zdCByb290ID0gbmV3IE9jdHJlZUdlb21ldHJ5Tm9kZSgncicsIG9jdHJlZSwgYm91bmRpbmdCb3gpO1xyXG4gICAgICAgIHJvb3QubGV2ZWwgPSAwO1xyXG4gICAgICAgIHJvb3Qubm9kZVR5cGUgPSAyO1xyXG4gICAgICAgIHJvb3QuaGllcmFyY2h5Qnl0ZU9mZnNldCA9IEJpZ0ludCgwKTtcclxuICAgICAgICByb290LmhpZXJhcmNoeUJ5dGVTaXplID0gQmlnSW50KG1ldGFkYXRhLmhpZXJhcmNoeS5maXJzdENodW5rU2l6ZSk7XHJcbiAgICAgICAgcm9vdC5zcGFjaW5nID0gb2N0cmVlLnNwYWNpbmc7XHJcbiAgICAgICAgcm9vdC5ieXRlT2Zmc2V0ID0gQmlnSW50KDApO1xyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfVxyXG4gICAgZ2V0VGlnaHRCb3VuZGluZ0JveChtZXRhZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlID0gbWV0YWRhdGEuYXR0cmlidXRlcy5maW5kKChhdHRyKSA9PiBhdHRyLm5hbWUgPT09ICdwb3NpdGlvbicpO1xyXG4gICAgICAgIGlmICghcG9zaXRpb25BdHRyaWJ1dGUgfHwgIXBvc2l0aW9uQXR0cmlidXRlLm1pbiB8fCAhcG9zaXRpb25BdHRyaWJ1dGUubWF4KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUG9zaXRpb24gYXR0cmlidXRlIChtaW4sIG1heCkgbm90IGZvdW5kLiBGYWxsaW5nIGJhY2sgdG8gYm91bmRpbmdCb3ggZm9yIHRpZ2h0Qm91bmRpbmdCb3gnKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3gzKG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1pbiksIG5ldyBWZWN0b3IzKC4uLm1ldGFkYXRhLmJvdW5kaW5nQm94Lm1heCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSBtZXRhZGF0YS5ib3VuZGluZ0JveC5taW47XHJcbiAgICAgICAgY29uc3QgdGlnaHRCb3VuZGluZ0JveCA9IG5ldyBCb3gzKG5ldyBWZWN0b3IzKHBvc2l0aW9uQXR0cmlidXRlLm1pblswXSAtIG9mZnNldFswXSwgcG9zaXRpb25BdHRyaWJ1dGUubWluWzFdIC0gb2Zmc2V0WzFdLCBwb3NpdGlvbkF0dHJpYnV0ZS5taW5bMl0gLSBvZmZzZXRbMl0pLCBuZXcgVmVjdG9yMyhwb3NpdGlvbkF0dHJpYnV0ZS5tYXhbMF0gLSBvZmZzZXRbMF0sIHBvc2l0aW9uQXR0cmlidXRlLm1heFsxXSAtIG9mZnNldFsxXSwgcG9zaXRpb25BdHRyaWJ1dGUubWF4WzJdIC0gb2Zmc2V0WzJdKSk7XHJcbiAgICAgICAgcmV0dXJuIHRpZ2h0Qm91bmRpbmdCb3g7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgT2N0cmVlTG9hZGVyIH0gZnJvbSAnLi9vY3RyZWUtbG9hZGVyJztcclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRPY3RyZWUodXJsLCBnZXRVcmwsIHhoclJlcXVlc3QpIHtcclxuICAgIGNvbnN0IHRydWVVcmwgPSBhd2FpdCBnZXRVcmwodXJsKTtcclxuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBPY3RyZWVMb2FkZXIoZ2V0VXJsLCB1cmwpO1xyXG4gICAgY29uc3QgeyBnZW9tZXRyeSB9ID0gYXdhaXQgbG9hZGVyLmxvYWQodHJ1ZVVybCwgeGhyUmVxdWVzdCk7XHJcbiAgICByZXR1cm4gZ2VvbWV0cnk7XHJcbn1cclxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzR2VvbWV0cnlOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZSAhPT0gbnVsbCAmJiBub2RlLmlzR2VvbWV0cnlOb2RlO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBpc1RyZWVOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlICE9PSB1bmRlZmluZWQgJiYgbm9kZSAhPT0gbnVsbCAmJiBub2RlLmlzVHJlZU5vZGU7XHJcbn1cclxuIiwiLyoqXG4gKiBmcm9tOiBodHRwOi8vZWxvcXVlbnRqYXZhc2NyaXB0Lm5ldC8xc3RfZWRpdGlvbi9hcHBlbmRpeDIuaHRtbFxuICpcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gQmluYXJ5SGVhcChzY29yZUZ1bmN0aW9uKSB7XG4gIHRoaXMuY29udGVudCA9IFtdO1xuICB0aGlzLnNjb3JlRnVuY3Rpb24gPSBzY29yZUZ1bmN0aW9uO1xufVxuQmluYXJ5SGVhcC5wcm90b3R5cGUgPSB7XG4gIHB1c2g6IGZ1bmN0aW9uIHB1c2goZWxlbWVudCkge1xuICAgIC8vIEFkZCB0aGUgbmV3IGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkuXG4gICAgdGhpcy5jb250ZW50LnB1c2goZWxlbWVudCk7XG4gICAgLy8gQWxsb3cgaXQgdG8gYnViYmxlIHVwLlxuICAgIHRoaXMuYnViYmxlVXAodGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpO1xuICB9LFxuICBwb3A6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAvLyBTdG9yZSB0aGUgZmlyc3QgZWxlbWVudCBzbyB3ZSBjYW4gcmV0dXJuIGl0IGxhdGVyLlxuICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbnRlbnRbMF07XG4gICAgLy8gR2V0IHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIGFueSBlbGVtZW50cyBsZWZ0LCBwdXQgdGhlIGVuZCBlbGVtZW50IGF0IHRoZVxuICAgIC8vIHN0YXJ0LCBhbmQgbGV0IGl0IHNpbmsgZG93bi5cbiAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29udGVudFswXSA9IGVuZDtcbiAgICAgIHRoaXMuc2lua0Rvd24oMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5vZGUpIHtcbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgICAvLyBUbyByZW1vdmUgYSB2YWx1ZSwgd2UgbXVzdCBzZWFyY2ggdGhyb3VnaCB0aGUgYXJyYXkgdG8gZmluZFxuICAgIC8vIGl0LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnRbaV0gIT0gbm9kZSkgY29udGludWU7XG4gICAgICAvLyBXaGVuIGl0IGlzIGZvdW5kLCB0aGUgcHJvY2VzcyBzZWVuIGluICdwb3AnIGlzIHJlcGVhdGVkXG4gICAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgICAgdmFyIGVuZCA9IHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IHdlIHBvcHBlZCB3YXMgdGhlIG9uZSB3ZSBuZWVkZWQgdG8gcmVtb3ZlLFxuICAgICAgLy8gd2UncmUgZG9uZS5cbiAgICAgIGlmIChpID09IGxlbmd0aCAtIDEpIGJyZWFrO1xuICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSByZXBsYWNlIHRoZSByZW1vdmVkIGVsZW1lbnQgd2l0aCB0aGUgcG9wcGVkXG4gICAgICAvLyBvbmUsIGFuZCBhbGxvdyBpdCB0byBmbG9hdCB1cCBvciBzaW5rIGRvd24gYXMgYXBwcm9wcmlhdGUuXG4gICAgICB0aGlzLmNvbnRlbnRbaV0gPSBlbmQ7XG4gICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xuICAgICAgdGhpcy5zaW5rRG93bihpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDtcbiAgfSxcbiAgYnViYmxlVXA6IGZ1bmN0aW9uIGJ1YmJsZVVwKG4pIHtcbiAgICAvLyBGZXRjaCB0aGUgZWxlbWVudCB0aGF0IGhhcyB0byBiZSBtb3ZlZC5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXSxcbiAgICAgIHNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IGdvIHVwIGFueSBmdXJ0aGVyLlxuICAgIHdoaWxlIChuID4gMCkge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgcGFyZW50IGVsZW1lbnQncyBpbmRleCwgYW5kIGZldGNoIGl0LlxuICAgICAgdmFyIHBhcmVudE4gPSBNYXRoLmZsb29yKChuICsgMSkgLyAyKSAtIDEsXG4gICAgICAgIHBhcmVudCA9IHRoaXMuY29udGVudFtwYXJlbnROXTtcbiAgICAgIC8vIElmIHRoZSBwYXJlbnQgaGFzIGEgbGVzc2VyIHNjb3JlLCB0aGluZ3MgYXJlIGluIG9yZGVyIGFuZCB3ZVxuICAgICAgLy8gYXJlIGRvbmUuXG4gICAgICBpZiAoc2NvcmUgPj0gdGhpcy5zY29yZUZ1bmN0aW9uKHBhcmVudCkpIGJyZWFrO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgdGhlIHBhcmVudCB3aXRoIHRoZSBjdXJyZW50IGVsZW1lbnQgYW5kXG4gICAgICAvLyBjb250aW51ZS5cbiAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbnRlbnRbbl0gPSBwYXJlbnQ7XG4gICAgICBuID0gcGFyZW50TjtcbiAgICB9XG4gIH0sXG4gIHNpbmtEb3duOiBmdW5jdGlvbiBzaW5rRG93bihuKSB7XG4gICAgLy8gTG9vayB1cCB0aGUgdGFyZ2V0IGVsZW1lbnQgYW5kIGl0cyBzY29yZS5cbiAgICB2YXIgbGVuZ3RoID0gdGhpcy5jb250ZW50Lmxlbmd0aCxcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmNvbnRlbnRbbl0sXG4gICAgICBlbGVtU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oZWxlbWVudCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpICogMixcbiAgICAgICAgY2hpbGQxTiA9IGNoaWxkMk4gLSAxO1xuICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsXG4gICAgICAvLyBpZiBhbnkuXG4gICAgICB2YXIgc3dhcCA9IG51bGw7XG4gICAgICAvLyBJZiB0aGUgZmlyc3QgY2hpbGQgZXhpc3RzIChpcyBpbnNpZGUgdGhlIGFycmF5KS4uLlxuICAgICAgaWYgKGNoaWxkMU4gPCBsZW5ndGgpIHtcbiAgICAgICAgLy8gTG9vayBpdCB1cCBhbmQgY29tcHV0ZSBpdHMgc2NvcmUuXG4gICAgICAgIHZhciBjaGlsZDEgPSB0aGlzLmNvbnRlbnRbY2hpbGQxTl0sXG4gICAgICAgICAgY2hpbGQxU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQxKTtcbiAgICAgICAgLy8gSWYgdGhlIHNjb3JlIGlzIGxlc3MgdGhhbiBvdXIgZWxlbWVudCdzLCB3ZSBuZWVkIHRvIHN3YXAuXG4gICAgICAgIGlmIChjaGlsZDFTY29yZSA8IGVsZW1TY29yZSkgc3dhcCA9IGNoaWxkMU47XG4gICAgICB9XG4gICAgICAvLyBEbyB0aGUgc2FtZSBjaGVja3MgZm9yIHRoZSBvdGhlciBjaGlsZC5cbiAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl0sXG4gICAgICAgICAgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT0gbnVsbCA/IGVsZW1TY29yZSA6IGNoaWxkMVNjb3JlKSkgc3dhcCA9IGNoaWxkMk47XG4gICAgICB9XG5cbiAgICAgIC8vIE5vIG5lZWQgdG8gc3dhcCBmdXJ0aGVyLCB3ZSBhcmUgZG9uZS5cbiAgICAgIGlmIChzd2FwID09IG51bGwpIGJyZWFrO1xuXG4gICAgICAvLyBPdGhlcndpc2UsIHN3YXAgYW5kIGNvbnRpbnVlLlxuICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgdGhpcy5jb250ZW50W3N3YXBdID0gZWxlbWVudDtcbiAgICAgIG4gPSBzd2FwO1xuICAgIH1cbiAgfVxufTsiLCJpbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEJ1ZmZlckdlb21ldHJ5LCBDb2xvciwgTGluZUJhc2ljTWF0ZXJpYWwsIExpbmVTZWdtZW50cywgfSBmcm9tICd0aHJlZSc7XHJcbi8qKlxyXG4gKlxyXG4gKiBjb2RlIGFkYXB0ZWQgZnJvbSB0aHJlZS5qcyBCb3hIZWxwZXIuanNcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iL2Rldi9zcmMvaGVscGVycy9Cb3hIZWxwZXIuanNcclxuICpcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xyXG4gKiBAYXV0aG9yIG1zY2h1ZXR6IC8gaHR0cDovL3BvdHJlZS5vcmdcclxuICovXHJcbmV4cG9ydCBjbGFzcyBCb3gzSGVscGVyIGV4dGVuZHMgTGluZVNlZ21lbnRzIHtcclxuICAgIGNvbnN0cnVjdG9yKGJveCwgY29sb3IgPSBuZXcgQ29sb3IoMHhmZmZmMDApKSB7XHJcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXHJcbiAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShbMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgN10pO1xyXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1pbi56LFxyXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1pbi56LFxyXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5taW4ueSwgYm94Lm1heC56LFxyXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5taW4ueSwgYm94Lm1heC56LFxyXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5tYXgueSwgYm94Lm1pbi56LFxyXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1pbi56LFxyXG4gICAgICAgICAgICBib3gubWF4LngsIGJveC5tYXgueSwgYm94Lm1heC56LFxyXG4gICAgICAgICAgICBib3gubWluLngsIGJveC5tYXgueSwgYm94Lm1heC56XHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcclxuICAgICAgICBnZW9tZXRyeS5zZXRJbmRleChuZXcgQnVmZmVyQXR0cmlidXRlKGluZGljZXMsIDEpKTtcclxuICAgICAgICBnZW9tZXRyeS5zZXRBdHRyaWJ1dGUoJ3Bvc2l0aW9uJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZShwb3NpdGlvbnMsIDMpKTtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCh7IGNvbG9yOiBjb2xvciB9KTtcclxuICAgICAgICBzdXBlcihnZW9tZXRyeSwgbWF0ZXJpYWwpO1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBjbGFzcyBMUlVJdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgZG91Ymx5LWxpbmtlZC1saXN0IG9mIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkIGVsZW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExSVSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEJ1ZGdldCA9IDEwMDAwMDApIHtcclxuICAgICAgICB0aGlzLnBvaW50QnVkZ2V0ID0gcG9pbnRCdWRnZXQ7XHJcbiAgICAgICAgLy8gdGhlIGxlYXN0IHJlY2VudGx5IHVzZWQgaXRlbVxyXG4gICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xyXG4gICAgICAgIC8vIHRoZSBtb3N0IHJlY2VudGx5IHVzZWQgaXRlbVxyXG4gICAgICAgIHRoaXMubGFzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgPSAwO1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5zaXplO1xyXG4gICAgfVxyXG4gICAgaGFzKG5vZGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5oYXMobm9kZS5pZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1ha2VzIHRoZSBzcGVjaWZpZWQgdGhlIG1vc3QgcmVjZW50bHkgdXNlZCBpdGVtLiBpZiB0aGUgbGlzdCBkb2VzIG5vdCBjb250YWluIG5vZGUsIGl0IHdpbGxcclxuICAgICAqIGJlIGFkZGVkLlxyXG4gICAgICovXHJcbiAgICB0b3VjaChub2RlKSB7XHJcbiAgICAgICAgaWYgKCFub2RlLmxvYWRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLml0ZW1zLmdldChub2RlLmlkKTtcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICB0aGlzLnRvdWNoRXhpc3RpbmcoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmFkZE5ldyhub2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGROZXcobm9kZSkge1xyXG4gICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgTFJVSXRlbShub2RlKTtcclxuICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xyXG4gICAgICAgIHRoaXMubGFzdCA9IGl0ZW07XHJcbiAgICAgICAgaWYgKGl0ZW0ucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmZpcnN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBpdGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLml0ZW1zLnNldChub2RlLmlkLCBpdGVtKTtcclxuICAgICAgICB0aGlzLm51bVBvaW50cyArPSBub2RlLm51bVBvaW50cztcclxuICAgIH1cclxuICAgIHRvdWNoRXhpc3RpbmcoaXRlbSkge1xyXG4gICAgICAgIGlmICghaXRlbS5wcmV2aW91cykge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgdG91Y2ggb24gZmlyc3QgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoaXRlbS5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gaXRlbS5uZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdC5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xyXG4gICAgICAgICAgICAgICAgaXRlbS5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdCA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWl0ZW0ubmV4dCkge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgdG91Y2ggb24gbGFzdCBlbGVtZW50XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBoYW5kbGUgdG91Y2ggb24gYW55IG90aGVyIGVsZW1lbnRcclxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbS5uZXh0O1xyXG4gICAgICAgICAgICBpdGVtLm5leHQucHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xyXG4gICAgICAgICAgICBpdGVtLnByZXZpb3VzID0gdGhpcy5sYXN0O1xyXG4gICAgICAgICAgICBpdGVtLm5leHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmxhc3QgPSBpdGVtO1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gaXRlbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShub2RlKSB7XHJcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXMuZ2V0KG5vZGUuaWQpO1xyXG4gICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLml0ZW1zLnNpemUgPT09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5maXJzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3QgPSBpdGVtLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0LnByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gaXRlbS5wcmV2aW91cztcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdC5uZXh0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91cyAmJiBpdGVtLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMubmV4dCA9IGl0ZW0ubmV4dDtcclxuICAgICAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2aW91cyA9IGl0ZW0ucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pdGVtcy5kZWxldGUobm9kZS5pZCk7XHJcbiAgICAgICAgdGhpcy5udW1Qb2ludHMgLT0gbm9kZS5udW1Qb2ludHM7XHJcbiAgICB9XHJcbiAgICBnZXRMUlVJdGVtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpcnN0ID8gdGhpcy5maXJzdC5ub2RlIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZnJlZU1lbW9yeSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pdGVtcy5zaXplIDw9IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aGlsZSAodGhpcy5udW1Qb2ludHMgPiB0aGlzLnBvaW50QnVkZ2V0ICogMikge1xyXG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXRMUlVJdGVtKCk7XHJcbiAgICAgICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VTdWJ0cmVlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGlzcG9zZVN1YnRyZWUobm9kZSkge1xyXG4gICAgICAgIC8vIENvbGxlY3QgYWxsIHRoZSBub2RlcyB3aGljaCBhcmUgdG8gYmUgZGlzcG9zZWQgYW5kIHJlbW92ZWQuXHJcbiAgICAgICAgY29uc3Qgbm9kZXNUb0Rpc3Bvc2UgPSBbbm9kZV07XHJcbiAgICAgICAgbm9kZS50cmF2ZXJzZShuID0+IHtcclxuICAgICAgICAgICAgaWYgKG4ubG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICBub2Rlc1RvRGlzcG9zZS5wdXNoKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gRGlzcG9zZSBvZiBhbGwgdGhlIG5vZGVzIGluIG9uZSBnby5cclxuICAgICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNUb0Rpc3Bvc2UpIHtcclxuICAgICAgICAgICAgbi5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKG4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBCb3gzLCBGcnVzdHVtLCBNYXRyaXg0LCBWZWN0b3IyLCBWZWN0b3IzLCB9IGZyb20gJ3RocmVlJztcclxuaW1wb3J0IHsgREVGQVVMVF9QT0lOVF9CVURHRVQsIE1BWF9MT0FEU19UT19HUFUsIE1BWF9OVU1fTk9ERVNfTE9BRElORywgUEVSU1BFQ1RJVkVfQ0FNRVJBLCB9IGZyb20gJy4vY29uc3RhbnRzJztcclxuaW1wb3J0IHsgRkVBVFVSRVMgfSBmcm9tICcuL2ZlYXR1cmVzJztcclxuaW1wb3J0IHsgQmluYXJ5TG9hZGVyLCBsb2FkUE9DIH0gZnJvbSAnLi9sb2FkaW5nJztcclxuaW1wb3J0IHsgbG9hZE9jdHJlZSB9IGZyb20gJy4vbG9hZGluZzIvbG9hZC1vY3RyZWUnO1xyXG5pbXBvcnQgeyBDbGlwTW9kZSB9IGZyb20gJy4vbWF0ZXJpYWxzJztcclxuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZSB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlJztcclxuaW1wb3J0IHsgUG9pbnRDbG91ZE9jdHJlZVBpY2tlciB9IGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XHJcbmltcG9ydCB7IGlzR2VvbWV0cnlOb2RlLCBpc1RyZWVOb2RlIH0gZnJvbSAnLi90eXBlLXByZWRpY2F0ZXMnO1xyXG5pbXBvcnQgeyBCaW5hcnlIZWFwIH0gZnJvbSAnLi91dGlscy9iaW5hcnktaGVhcCc7XHJcbmltcG9ydCB7IEJveDNIZWxwZXIgfSBmcm9tICcuL3V0aWxzL2JveDMtaGVscGVyJztcclxuaW1wb3J0IHsgTFJVIH0gZnJvbSAnLi91dGlscy9scnUnO1xyXG5leHBvcnQgY2xhc3MgUXVldWVJdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50Q2xvdWRJbmRleCwgd2VpZ2h0LCBub2RlLCBwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLnBvaW50Q2xvdWRJbmRleCA9IHBvaW50Q2xvdWRJbmRleDtcclxuICAgICAgICB0aGlzLndlaWdodCA9IHdlaWdodDtcclxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IEdFT01FVFJZX0xPQURFUlMgPSB7XHJcbiAgICB2MTogbG9hZFBPQyxcclxuICAgIHYyOiBsb2FkT2N0cmVlXHJcbn07XHJcbmV4cG9ydCBjbGFzcyBQb3RyZWUge1xyXG4gICAgY29uc3RydWN0b3IodmVyc2lvbiA9IFwidjFcIikge1xyXG4gICAgICAgIHRoaXMuX3BvaW50QnVkZ2V0ID0gREVGQVVMVF9QT0lOVF9CVURHRVQ7XHJcbiAgICAgICAgdGhpcy5fcmVuZGVyZXJTaXplID0gbmV3IFZlY3RvcjIoKTtcclxuICAgICAgICB0aGlzLm1heE51bU5vZGVzTG9hZGluZyA9IE1BWF9OVU1fTk9ERVNfTE9BRElORztcclxuICAgICAgICB0aGlzLmZlYXR1cmVzID0gRkVBVFVSRVM7XHJcbiAgICAgICAgdGhpcy5scnUgPSBuZXcgTFJVKHRoaXMuX3BvaW50QnVkZ2V0KTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHlTdHJ1Y3R1cmVzID0gKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnJ1c3R1bU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGludmVyc2VXb3JsZE1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbWVyYU1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiAocG9pbnRDbG91ZHMsIGNhbWVyYSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZnJ1c3R1bXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbWVyYVBvc2l0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlRdWV1ZSA9IG5ldyBCaW5hcnlIZWFwKHggPT4gMSAvIHgud2VpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDbG91ZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludENsb3VkID0gcG9pbnRDbG91ZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwb2ludENsb3VkLmluaXRpYWxpemVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50Q2xvdWQubnVtVmlzaWJsZVBvaW50cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlTm9kZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLnZpc2libGVHZW9tZXRyeSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRnVyc3R1bSBpbiBvYmplY3Qgc3BhY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW52ZXJzZVZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmxkTWF0cml4ID0gcG9pbnRDbG91ZC5tYXRyaXhXb3JsZDtcclxuICAgICAgICAgICAgICAgICAgICBmcnVzdHVtTWF0cml4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pZGVudGl0eSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tdWx0aXBseShjYW1lcmEucHJvamVjdGlvbk1hdHJpeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGludmVyc2VWaWV3TWF0cml4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubXVsdGlwbHkod29ybGRNYXRyaXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZydXN0dW1zLnB1c2gobmV3IEZydXN0dW0oKS5zZXRGcm9tUHJvamVjdGlvbk1hdHJpeChmcnVzdHVtTWF0cml4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FtZXJhIHBvc2l0aW9uIGluIG9iamVjdCBzcGFjZVxyXG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VXb3JsZE1hdHJpeC5jb3B5KHdvcmxkTWF0cml4KS5pbnZlcnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjYW1lcmFNYXRyaXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmlkZW50aXR5KClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGludmVyc2VXb3JsZE1hdHJpeClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm11bHRpcGx5KGNhbWVyYS5tYXRyaXhXb3JsZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FtZXJhUG9zaXRpb25zLnB1c2gobmV3IFZlY3RvcjMoKS5zZXRGcm9tTWF0cml4UG9zaXRpb24oY2FtZXJhTWF0cml4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50Q2xvdWQudmlzaWJsZSAmJiBwb2ludENsb3VkLnJvb3QgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHlRdWV1ZS5wdXNoKG5ldyBRdWV1ZUl0ZW0oaSwgd2VpZ2h0LCBwb2ludENsb3VkLnJvb3QpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSGlkZSBhbnkgcHJldmlvdXNseSB2aXNpYmxlIG5vZGVzLiBXZSB3aWxsIGxhdGVyIHNob3cgb25seSB0aGUgbmVlZGVkIG9uZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVHJlZU5vZGUocG9pbnRDbG91ZC5yb290KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludENsb3VkLmhpZGVEZXNjZW5kYW50cyhwb2ludENsb3VkLnJvb3Quc2NlbmVOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBib3VuZGluZ0JveE5vZGUgb2YgcG9pbnRDbG91ZC5ib3VuZGluZ0JveE5vZGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kaW5nQm94Tm9kZS52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJ1c3R1bXMsIGNhbWVyYVBvc2l0aW9ucywgcHJpb3JpdHlRdWV1ZSB9O1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pKCk7XHJcbiAgICAgICAgdGhpcy5sb2FkR2VvbWV0cnkgPSBHRU9NRVRSWV9MT0FERVJTW3ZlcnNpb25dO1xyXG4gICAgfVxyXG4gICAgbG9hZFBvaW50Q2xvdWQodXJsLCBnZXRVcmwsIHhoclJlcXVlc3QgPSAoaW5wdXQsIGluaXQpID0+IGZldGNoKGlucHV0LCBpbml0KSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRHZW9tZXRyeSh1cmwsIGdldFVybCwgeGhyUmVxdWVzdCkudGhlbihnZW9tZXRyeSA9PiBuZXcgUG9pbnRDbG91ZE9jdHJlZSh0aGlzLCBnZW9tZXRyeSkpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUG9pbnRDbG91ZHMocG9pbnRDbG91ZHMsIGNhbWVyYSwgcmVuZGVyZXIpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnVwZGF0ZVZpc2liaWxpdHkocG9pbnRDbG91ZHMsIGNhbWVyYSwgcmVuZGVyZXIpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRDbG91ZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZCA9IHBvaW50Q2xvdWRzW2ldO1xyXG4gICAgICAgICAgICBpZiAocG9pbnRDbG91ZC5kaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9pbnRDbG91ZC5tYXRlcmlhbC51cGRhdGVNYXRlcmlhbChwb2ludENsb3VkLCBwb2ludENsb3VkLnZpc2libGVOb2RlcywgY2FtZXJhLCByZW5kZXJlcik7XHJcbiAgICAgICAgICAgIHBvaW50Q2xvdWQudXBkYXRlVmlzaWJsZUJvdW5kcygpO1xyXG4gICAgICAgICAgICBwb2ludENsb3VkLnVwZGF0ZUJvdW5kaW5nQm94ZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5scnUuZnJlZU1lbW9yeSgpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcGljayhwb2ludENsb3VkcywgcmVuZGVyZXIsIGNhbWVyYSwgcmF5LCBwYXJhbXMgPSB7fSkge1xyXG4gICAgICAgIFBvdHJlZS5waWNrZXIgPSBQb3RyZWUucGlja2VyIHx8IG5ldyBQb2ludENsb3VkT2N0cmVlUGlja2VyKCk7XHJcbiAgICAgICAgcmV0dXJuIFBvdHJlZS5waWNrZXIucGljayhyZW5kZXJlciwgY2FtZXJhLCByYXksIHBvaW50Q2xvdWRzLCBwYXJhbXMpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvaW50QnVkZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludEJ1ZGdldDtcclxuICAgIH1cclxuICAgIHNldCBwb2ludEJ1ZGdldCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9pbnRCdWRnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRCdWRnZXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5scnUucG9pbnRCdWRnZXQgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5scnUuZnJlZU1lbW9yeSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXQgbWF4TG9hZGVyV29ya2Vycyh2YWx1ZSkge1xyXG4gICAgICAgIEJpbmFyeUxvYWRlci5XT1JLRVJfUE9PTC5tYXhXb3JrZXJzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IG1heExvYWRlcldvcmtlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJpbmFyeUxvYWRlci5XT1JLRVJfUE9PTC5tYXhXb3JrZXJzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmlzaWJpbGl0eShwb2ludENsb3VkcywgY2FtZXJhLCByZW5kZXJlcikge1xyXG4gICAgICAgIGxldCBudW1WaXNpYmxlUG9pbnRzID0gMDtcclxuICAgICAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB1bmxvYWRlZEdlb21ldHJ5ID0gW107XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIG9iamVjdCBzcGFjZSBmcnVzdHVtIGFuZCBjYW0gcG9zIGFuZCBzZXR1cCBwcmlvcml0eSBxdWV1ZVxyXG4gICAgICAgIGNvbnN0IHsgZnJ1c3R1bXMsIGNhbWVyYVBvc2l0aW9ucywgcHJpb3JpdHlRdWV1ZSB9ID0gdGhpcy51cGRhdGVWaXNpYmlsaXR5U3RydWN0dXJlcyhwb2ludENsb3VkcywgY2FtZXJhKTtcclxuICAgICAgICBsZXQgbG9hZGVkVG9HUFVUaGlzRnJhbWUgPSAwO1xyXG4gICAgICAgIGxldCBleGNlZWRlZE1heExvYWRzVG9HUFUgPSBmYWxzZTtcclxuICAgICAgICBsZXQgbm9kZUxvYWRGYWlsZWQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgcXVldWVJdGVtO1xyXG4gICAgICAgIHdoaWxlICgocXVldWVJdGVtID0gcHJpb3JpdHlRdWV1ZS5wb3AoKSkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZXQgbm9kZSA9IHF1ZXVlSXRlbS5ub2RlO1xyXG4gICAgICAgICAgICAvLyBJZiB3ZSB3aWxsIGVuZCB1cCB3aXRoIHRvbyBtYW55IHBvaW50cywgd2Ugc3RvcCByaWdodCBhd2F5LlxyXG4gICAgICAgICAgICBpZiAobnVtVmlzaWJsZVBvaW50cyArIG5vZGUubnVtUG9pbnRzID4gdGhpcy5wb2ludEJ1ZGdldCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZEluZGV4ID0gcXVldWVJdGVtLnBvaW50Q2xvdWRJbmRleDtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRDbG91ZCA9IHBvaW50Q2xvdWRzW3BvaW50Q2xvdWRJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IG1heExldmVsID0gcG9pbnRDbG91ZC5tYXhMZXZlbCAhPT0gdW5kZWZpbmVkID8gcG9pbnRDbG91ZC5tYXhMZXZlbCA6IEluZmluaXR5O1xyXG4gICAgICAgICAgICBpZiAobm9kZS5sZXZlbCA+IG1heExldmVsIHx8XHJcbiAgICAgICAgICAgICAgICAhZnJ1c3R1bXNbcG9pbnRDbG91ZEluZGV4XS5pbnRlcnNlY3RzQm94KG5vZGUuYm91bmRpbmdCb3gpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZENsaXAocG9pbnRDbG91ZCwgbm9kZS5ib3VuZGluZ0JveCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG51bVZpc2libGVQb2ludHMgKz0gbm9kZS5udW1Qb2ludHM7XHJcbiAgICAgICAgICAgIHBvaW50Q2xvdWQubnVtVmlzaWJsZVBvaW50cyArPSBub2RlLm51bVBvaW50cztcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHF1ZXVlSXRlbS5wYXJlbnQ7XHJcbiAgICAgICAgICAgIGlmIChpc0dlb21ldHJ5Tm9kZShub2RlKSAmJiAoIXBhcmVudE5vZGUgfHwgaXNUcmVlTm9kZShwYXJlbnROb2RlKSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmxvYWRlZCAmJiBsb2FkZWRUb0dQVVRoaXNGcmFtZSA8IE1BWF9MT0FEU19UT19HUFUpIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gcG9pbnRDbG91ZC50b1RyZWVOb2RlKG5vZGUsIHBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxvYWRlZFRvR1BVVGhpc0ZyYW1lKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghbm9kZS5mYWlsZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sb2FkZWQgJiYgbG9hZGVkVG9HUFVUaGlzRnJhbWUgPj0gTUFYX0xPQURTX1RPX0dQVSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleGNlZWRlZE1heExvYWRzVG9HUFUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB1bmxvYWRlZEdlb21ldHJ5LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlR2VvbWV0cnkucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb2FkRmFpbGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNUcmVlTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlTm9kZVZpc2liaWxpdHkocG9pbnRDbG91ZCwgbm9kZSwgdmlzaWJsZU5vZGVzKTtcclxuICAgICAgICAgICAgICAgIHBvaW50Q2xvdWQudmlzaWJsZUdlb21ldHJ5LnB1c2gobm9kZS5nZW9tZXRyeU5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGhhbGZIZWlnaHQgPSAwLjUgKiByZW5kZXJlci5nZXRTaXplKHRoaXMuX3JlbmRlcmVyU2l6ZSkuaGVpZ2h0ICogcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkVmlzaWJpbGl0eShxdWV1ZUl0ZW0sIHByaW9yaXR5UXVldWUsIHBvaW50Q2xvdWQsIG5vZGUsIGNhbWVyYVBvc2l0aW9uc1twb2ludENsb3VkSW5kZXhdLCBjYW1lcmEsIGhhbGZIZWlnaHQpO1xyXG4gICAgICAgIH0gLy8gZW5kIHByaW9yaXR5IHF1ZXVlIGxvb3BcclxuICAgICAgICBjb25zdCBudW1Ob2Rlc1RvTG9hZCA9IE1hdGgubWluKHRoaXMubWF4TnVtTm9kZXNMb2FkaW5nLCB1bmxvYWRlZEdlb21ldHJ5Lmxlbmd0aCk7XHJcbiAgICAgICAgY29uc3Qgbm9kZUxvYWRQcm9taXNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTm9kZXNUb0xvYWQ7IGkrKykge1xyXG4gICAgICAgICAgICBub2RlTG9hZFByb21pc2VzLnB1c2godW5sb2FkZWRHZW9tZXRyeVtpXS5sb2FkKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB2aXNpYmxlTm9kZXM6IHZpc2libGVOb2RlcyxcclxuICAgICAgICAgICAgbnVtVmlzaWJsZVBvaW50czogbnVtVmlzaWJsZVBvaW50cyxcclxuICAgICAgICAgICAgZXhjZWVkZWRNYXhMb2Fkc1RvR1BVOiBleGNlZWRlZE1heExvYWRzVG9HUFUsXHJcbiAgICAgICAgICAgIG5vZGVMb2FkRmFpbGVkOiBub2RlTG9hZEZhaWxlZCxcclxuICAgICAgICAgICAgbm9kZUxvYWRQcm9taXNlczogbm9kZUxvYWRQcm9taXNlcyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVHJlZU5vZGVWaXNpYmlsaXR5KHBvaW50Q2xvdWQsIG5vZGUsIHZpc2libGVOb2Rlcykge1xyXG4gICAgICAgIHRoaXMubHJ1LnRvdWNoKG5vZGUuZ2VvbWV0cnlOb2RlKTtcclxuICAgICAgICBjb25zdCBzY2VuZU5vZGUgPSBub2RlLnNjZW5lTm9kZTtcclxuICAgICAgICBzY2VuZU5vZGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgc2NlbmVOb2RlLm1hdGVyaWFsID0gcG9pbnRDbG91ZC5tYXRlcmlhbDtcclxuICAgICAgICBzY2VuZU5vZGUudXBkYXRlTWF0cml4KCk7XHJcbiAgICAgICAgc2NlbmVOb2RlLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMocG9pbnRDbG91ZC5tYXRyaXhXb3JsZCwgc2NlbmVOb2RlLm1hdHJpeCk7XHJcbiAgICAgICAgdmlzaWJsZU5vZGVzLnB1c2gobm9kZSk7XHJcbiAgICAgICAgcG9pbnRDbG91ZC52aXNpYmxlTm9kZXMucHVzaChub2RlKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94VmlzaWJpbGl0eShwb2ludENsb3VkLCBub2RlKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUNoaWxkVmlzaWJpbGl0eShxdWV1ZUl0ZW0sIHByaW9yaXR5UXVldWUsIHBvaW50Q2xvdWQsIG5vZGUsIGNhbWVyYVBvc2l0aW9uLCBjYW1lcmEsIGhhbGZIZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNwaGVyZSA9IGNoaWxkLmJvdW5kaW5nU3BoZXJlO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUbyhjYW1lcmFQb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XHJcbiAgICAgICAgICAgIGxldCBwcm9qZWN0aW9uRmFjdG9yID0gMC4wO1xyXG4gICAgICAgICAgICBpZiAoY2FtZXJhLnR5cGUgPT09IFBFUlNQRUNUSVZFX0NBTUVSQSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGVyc3BlY3RpdmUgPSBjYW1lcmE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmb3YgPSAocGVyc3BlY3RpdmUuZm92ICogTWF0aC5QSSkgLyAxODAuMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3BlID0gTWF0aC50YW4oZm92IC8gMi4wKTtcclxuICAgICAgICAgICAgICAgIHByb2plY3Rpb25GYWN0b3IgPSBoYWxmSGVpZ2h0IC8gKHNsb3BlICogZGlzdGFuY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3J0aG9ncmFwaGljID0gY2FtZXJhO1xyXG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbkZhY3RvciA9ICgyICogaGFsZkhlaWdodCkgLyAob3J0aG9ncmFwaGljLnRvcCAtIG9ydGhvZ3JhcGhpYy5ib3R0b20pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlblBpeGVsUmFkaXVzID0gcmFkaXVzICogcHJvamVjdGlvbkZhY3RvcjtcclxuICAgICAgICAgICAgLy8gRG9uJ3QgYWRkIHRoZSBub2RlIGlmIGl0J2xsIGJlIHRvbyBzbWFsbCBvbiB0aGUgc2NyZWVuLlxyXG4gICAgICAgICAgICBpZiAoc2NyZWVuUGl4ZWxSYWRpdXMgPCBwb2ludENsb3VkLm1pbk5vZGVQaXhlbFNpemUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vZGVzIHdoaWNoIGFyZSBsYXJnZXIgd2lsbCBoYXZlIHByaW9yaXR5IGluIGxvYWRpbmcvZGlzcGxheWluZy5cclxuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZGlzdGFuY2UgPCByYWRpdXMgPyBOdW1iZXIuTUFYX1ZBTFVFIDogc2NyZWVuUGl4ZWxSYWRpdXMgKyAxIC8gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIHByaW9yaXR5UXVldWUucHVzaChuZXcgUXVldWVJdGVtKHF1ZXVlSXRlbS5wb2ludENsb3VkSW5kZXgsIHdlaWdodCwgY2hpbGQsIG5vZGUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVCb3VuZGluZ0JveFZpc2liaWxpdHkocG9pbnRDbG91ZCwgbm9kZSkge1xyXG4gICAgICAgIGlmIChwb2ludENsb3VkLnNob3dCb3VuZGluZ0JveCAmJiAhbm9kZS5ib3VuZGluZ0JveE5vZGUpIHtcclxuICAgICAgICAgICAgY29uc3QgYm94SGVscGVyID0gbmV3IEJveDNIZWxwZXIobm9kZS5ib3VuZGluZ0JveCk7XHJcbiAgICAgICAgICAgIGJveEhlbHBlci5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHBvaW50Q2xvdWQuYm91bmRpbmdCb3hOb2Rlcy5wdXNoKGJveEhlbHBlcik7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlID0gYm94SGVscGVyO1xyXG4gICAgICAgICAgICBub2RlLmJvdW5kaW5nQm94Tm9kZS5tYXRyaXguY29weShwb2ludENsb3VkLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocG9pbnRDbG91ZC5zaG93Qm91bmRpbmdCb3ggJiYgbm9kZS5ib3VuZGluZ0JveE5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZGluZ0JveE5vZGUudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG5vZGUuYm91bmRpbmdCb3hOb2RlLm1hdHJpeC5jb3B5KHBvaW50Q2xvdWQubWF0cml4V29ybGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghcG9pbnRDbG91ZC5zaG93Qm91bmRpbmdCb3ggJiYgbm9kZS5ib3VuZGluZ0JveE5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5ib3VuZGluZ0JveE5vZGUudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNob3VsZENsaXAocG9pbnRDbG91ZCwgYm91bmRpbmdCb3gpIHtcclxuICAgICAgICBjb25zdCBtYXRlcmlhbCA9IHBvaW50Q2xvdWQubWF0ZXJpYWw7XHJcbiAgICAgICAgaWYgKG1hdGVyaWFsLm51bUNsaXBCb3hlcyA9PT0gMCB8fCBtYXRlcmlhbC5jbGlwTW9kZSAhPT0gQ2xpcE1vZGUuQ0xJUF9PVVRTSURFKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYm94MiA9IGJvdW5kaW5nQm94LmNsb25lKCk7XHJcbiAgICAgICAgcG9pbnRDbG91ZC51cGRhdGVNYXRyaXhXb3JsZCh0cnVlKTtcclxuICAgICAgICBib3gyLmFwcGx5TWF0cml4NChwb2ludENsb3VkLm1hdHJpeFdvcmxkKTtcclxuICAgICAgICBjb25zdCBjbGlwQm94ZXMgPSBtYXRlcmlhbC5jbGlwQm94ZXM7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGlwQm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY2xpcE1hdHJpeFdvcmxkID0gY2xpcEJveGVzW2ldLm1hdHJpeDtcclxuICAgICAgICAgICAgY29uc3QgY2xpcEJveFdvcmxkID0gbmV3IEJveDMobmV3IFZlY3RvcjMoLTAuNSwgLTAuNSwgLTAuNSksIG5ldyBWZWN0b3IzKDAuNSwgMC41LCAwLjUpKS5hcHBseU1hdHJpeDQoY2xpcE1hdHJpeFdvcmxkKTtcclxuICAgICAgICAgICAgaWYgKGJveDIuaW50ZXJzZWN0c0JveChjbGlwQm94V29ybGQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiZXhwb3J0ICogZnJvbSAnLi9sb2FkLW9jdHJlZSc7XHJcbiIsImV4cG9ydCAqIGZyb20gJy4vbWF0ZXJpYWxzJztcclxuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1hdHRyaWJ1dGVzJztcclxuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtZ2VvbWV0cnktbm9kZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLWdlb21ldHJ5JztcclxuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC1vY3RyZWUtbm9kZSc7XHJcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlLXBpY2tlcic7XHJcbmV4cG9ydCAqIGZyb20gJy4vcG9pbnQtY2xvdWQtb2N0cmVlJztcclxuZXhwb3J0ICogZnJvbSAnLi9wb2ludC1jbG91ZC10cmVlJztcclxuZXhwb3J0ICogZnJvbSAnLi9wb3RyZWUnO1xyXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJztcclxuZXhwb3J0ICogZnJvbSAnLi92ZXJzaW9uJztcclxuZXhwb3J0IHsgbG9hZFBPQyBhcyBWMV9MT0FERVIgfSBmcm9tICcuL2xvYWRpbmcnO1xyXG5leHBvcnQgeyBsb2FkT2N0cmVlIGFzIFYyX0xPQURFUiB9IGZyb20gJy4vbG9hZGluZzInO1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///238\n")},300:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"(()=>{\\\"use strict\\\";var __webpack_modules__={256:()=>{eval(\\\"\\\\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\\\\n/**\\\\r\\\\n * Some types of possible point attribute data formats\\\\r\\\\n *\\\\r\\\\n * @class\\\\r\\\\n */\\\\r\\\\nconst PointAttributeTypes = {\\\\r\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\\\\r\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\\\\r\\\\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\\\\r\\\\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\\\\r\\\\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\\\\r\\\\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\\\\r\\\\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\\\\r\\\\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\\\\r\\\\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\\\\r\\\\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\\\\r\\\\n};\\\\r\\\\nlet i = 0;\\\\r\\\\nfor (const obj in PointAttributeTypes) {\\\\r\\\\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\\\\r\\\\n    i++;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nclass PointAttribute {\\\\r\\\\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\\\\r\\\\n        this.name = name;\\\\r\\\\n        this.type = type;\\\\r\\\\n        this.numElements = numElements;\\\\r\\\\n        this.range = range;\\\\r\\\\n        this.uri = uri;\\\\r\\\\n        this.byteSize = this.numElements * this.type.size;\\\\r\\\\n        this.description = '';\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nconst POINT_ATTRIBUTES = {\\\\r\\\\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\r\\\\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\r\\\\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\\\\r\\\\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\r\\\\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\r\\\\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\\\\r\\\\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\\\\r\\\\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\\\\r\\\\n};\\\\r\\\\nclass PointAttributes {\\\\r\\\\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\\\\r\\\\n        this.attributes = attributes;\\\\r\\\\n        this.byteSize = byteSize;\\\\r\\\\n        this.size = size;\\\\r\\\\n        this.vectors = vectors;\\\\r\\\\n        if (pointAttributes != null) {\\\\r\\\\n            for (let i = 0; i < pointAttributes.length; i++) {\\\\r\\\\n                const pointAttributeName = pointAttributes[i];\\\\r\\\\n                const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\r\\\\n                this.attributes.push(pointAttribute);\\\\r\\\\n                this.byteSize += pointAttribute.byteSize;\\\\r\\\\n                this.size++;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    add(pointAttribute) {\\\\r\\\\n        this.attributes.push(pointAttribute);\\\\r\\\\n        this.byteSize += pointAttribute.byteSize;\\\\r\\\\n        this.size++;\\\\r\\\\n    }\\\\r\\\\n    addVector(vector) {\\\\r\\\\n        this.vectors.push(vector);\\\\r\\\\n    }\\\\r\\\\n    hasNormals() {\\\\r\\\\n        for (const name in this.attributes) {\\\\r\\\\n            const pointAttribute = this.attributes[name];\\\\r\\\\n            if (pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\\\\r\\\\n                return true;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        return false;\\\\r\\\\n    }\\\\r\\\\n    getAttribute(attributeName) {\\\\r\\\\n        return this.attributes.find(attr => attr.name === attributeName);\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/loading2/decoder.worker.js\\\\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\\\\nfunction _nonIterableRest() { throw new TypeError(\\\\\\\"Invalid attempt to destructure non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); }\\\\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \\\\\\\"undefined\\\\\\\" != typeof Symbol && r[Symbol.iterator] || r[\\\\\\\"@@iterator\\\\\\\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\\\\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\\\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \\\\\\\"undefined\\\\\\\" && o[Symbol.iterator] || o[\\\\\\\"@@iterator\\\\\\\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\\\\\"number\\\\\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\\\\\"Invalid attempt to iterate non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\\\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\\\\\"string\\\\\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\\\\\"Object\\\\\\\" && o.constructor) n = o.constructor.name; if (n === \\\\\\\"Map\\\\\\\" || n === \\\\\\\"Set\\\\\\\") return Array.from(o); if (n === \\\\\\\"Arguments\\\\\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\\\\n\\\\nvar typedArrayMapping = {\\\\n  'int8': Int8Array,\\\\n  'int16': Int16Array,\\\\n  'int32': Int32Array,\\\\n  'int64': Float64Array,\\\\n  'uint8': Uint8Array,\\\\n  'uint16': Uint16Array,\\\\n  'uint32': Uint32Array,\\\\n  'uint64': Float64Array,\\\\n  'float': Float32Array,\\\\n  'double': Float64Array\\\\n};\\\\nonmessage = function onmessage(event) {\\\\n  var _event$data = event.data,\\\\n    buffer = _event$data.buffer,\\\\n    pointAttributes = _event$data.pointAttributes,\\\\n    scale = _event$data.scale,\\\\n    name = _event$data.name,\\\\n    min = _event$data.min,\\\\n    max = _event$data.max,\\\\n    size = _event$data.size,\\\\n    offset = _event$data.offset,\\\\n    numPoints = _event$data.numPoints;\\\\n  var view = new DataView(buffer);\\\\n  var attributeBuffers = {};\\\\n  var attributeOffset = 0;\\\\n  var bytesPerPoint = 0;\\\\n  var _iterator = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step;\\\\n  try {\\\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\\\n      var pointAttribute = _step.value;\\\\n      bytesPerPoint += pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator.e(err);\\\\n  } finally {\\\\n    _iterator.f();\\\\n  }\\\\n  var gridSize = 32;\\\\n  var grid = new Uint32Array(Math.pow(gridSize, 3));\\\\n  var toIndex = function toIndex(x, y, z) {\\\\n    // min is already subtracted\\\\n    var dx = gridSize * x / size.x;\\\\n    var dy = gridSize * y / size.y;\\\\n    var dz = gridSize * z / size.z;\\\\n    var ix = Math.min(parseInt(dx), gridSize - 1);\\\\n    var iy = Math.min(parseInt(dy), gridSize - 1);\\\\n    var iz = Math.min(parseInt(dz), gridSize - 1);\\\\n    var index = ix + iy * gridSize + iz * gridSize * gridSize;\\\\n    return index;\\\\n  };\\\\n  var numOccupiedCells = 0;\\\\n  var tightBoxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\\\\n  var tightBoxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\\\\n  var _iterator2 = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step2;\\\\n  try {\\\\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\\\n      var _pointAttribute = _step2.value;\\\\n      if (['POSITION_CARTESIAN', 'position'].includes(_pointAttribute.name)) {\\\\n        var _buff = new ArrayBuffer(numPoints * 4 * 3);\\\\n        var positions = new Float32Array(_buff);\\\\n        for (var _j = 0; _j < numPoints; _j++) {\\\\n          var pointOffset = _j * bytesPerPoint;\\\\n          var x = view.getInt32(pointOffset + attributeOffset + 0, true) * scale[0] + offset[0] - min.x;\\\\n          var y = view.getInt32(pointOffset + attributeOffset + 4, true) * scale[1] + offset[1] - min.y;\\\\n          var z = view.getInt32(pointOffset + attributeOffset + 8, true) * scale[2] + offset[2] - min.z;\\\\n          tightBoxMin[0] = Math.min(tightBoxMin[0], x);\\\\n          tightBoxMin[1] = Math.min(tightBoxMin[1], y);\\\\n          tightBoxMin[2] = Math.min(tightBoxMin[2], z);\\\\n          tightBoxMax[0] = Math.max(tightBoxMax[0], x);\\\\n          tightBoxMax[1] = Math.max(tightBoxMax[1], y);\\\\n          tightBoxMax[2] = Math.max(tightBoxMax[2], z);\\\\n          var index = toIndex(x, y, z);\\\\n          var count = grid[index]++;\\\\n          if (count === 0) {\\\\n            numOccupiedCells++;\\\\n          }\\\\n          positions[3 * _j + 0] = x;\\\\n          positions[3 * _j + 1] = y;\\\\n          positions[3 * _j + 2] = z;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else if (['RGBA', 'rgba'].includes(_pointAttribute.name)) {\\\\n        var _buff2 = new ArrayBuffer(numPoints * 4);\\\\n        var colors = new Uint8Array(_buff2);\\\\n        for (var _j2 = 0; _j2 < numPoints; _j2++) {\\\\n          var _pointOffset = _j2 * bytesPerPoint;\\\\n          var r = view.getUint16(_pointOffset + attributeOffset + 0, true);\\\\n          var g = view.getUint16(_pointOffset + attributeOffset + 2, true);\\\\n          var b = view.getUint16(_pointOffset + attributeOffset + 4, true);\\\\n          colors[4 * _j2 + 0] = r > 255 ? r / 256 : r;\\\\n          colors[4 * _j2 + 1] = g > 255 ? g / 256 : g;\\\\n          colors[4 * _j2 + 2] = b > 255 ? b / 256 : b;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff2,\\\\n          attribute: _pointAttribute\\\\n        };\\\\n      } else {\\\\n        var _buff3 = new ArrayBuffer(numPoints * 4);\\\\n        var _f = new Float32Array(_buff3);\\\\n        var TypedArray = typedArrayMapping[_pointAttribute.type.name];\\\\n        var preciseBuffer = new TypedArray(numPoints);\\\\n        var _offset2 = 0,\\\\n          _scale2 = 1;\\\\n        var getterMap = {\\\\n          'int8': view.getInt8,\\\\n          'int16': view.getInt16,\\\\n          'int32': view.getInt32,\\\\n          // 'int64':  view.getInt64,\\\\n          'uint8': view.getUint8,\\\\n          'uint16': view.getUint16,\\\\n          'uint32': view.getUint32,\\\\n          // 'uint64': view.getUint64,\\\\n          'float': view.getFloat32,\\\\n          'double': view.getFloat64\\\\n        };\\\\n        var _getter = getterMap[_pointAttribute.type.name].bind(view);\\\\n\\\\n        // compute offset and scale to pack larger types into 32 bit floats\\\\n        if (_pointAttribute.type.size > 4) {\\\\n          var _pointAttribute$range = _slicedToArray(_pointAttribute.range, 2),\\\\n            amin = _pointAttribute$range[0],\\\\n            amax = _pointAttribute$range[1];\\\\n          _offset2 = amin;\\\\n          _scale2 = 1 / (amax - amin);\\\\n        }\\\\n        for (var _j3 = 0; _j3 < numPoints; _j3++) {\\\\n          var _pointOffset2 = _j3 * bytesPerPoint;\\\\n          var _value = _getter(_pointOffset2 + attributeOffset, true);\\\\n          _f[_j3] = (_value - _offset2) * _scale2;\\\\n          preciseBuffer[_j3] = _value;\\\\n        }\\\\n        attributeBuffers[_pointAttribute.name] = {\\\\n          buffer: _buff3,\\\\n          preciseBuffer: preciseBuffer,\\\\n          attribute: _pointAttribute,\\\\n          offset: _offset2,\\\\n          scale: _scale2\\\\n        };\\\\n      }\\\\n      attributeOffset += _pointAttribute.byteSize;\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator2.e(err);\\\\n  } finally {\\\\n    _iterator2.f();\\\\n  }\\\\n  var occupancy = parseInt(numPoints / numOccupiedCells);\\\\n  {\\\\n    // add indices\\\\n    var buff = new ArrayBuffer(numPoints * 4);\\\\n    var indices = new Uint32Array(buff);\\\\n    for (var i = 0; i < numPoints; i++) {\\\\n      indices[i] = i;\\\\n    }\\\\n    attributeBuffers['INDICES'] = {\\\\n      buffer: buff,\\\\n      attribute: PointAttribute.INDICES\\\\n    };\\\\n  }\\\\n  {\\\\n    // handle attribute vectors\\\\n    var vectors = pointAttributes.vectors;\\\\n    var _iterator3 = _createForOfIteratorHelper(vectors),\\\\n      _step3;\\\\n    try {\\\\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\\\n        var vector = _step3.value;\\\\n        var _name = vector.name,\\\\n          attributes = vector.attributes;\\\\n        var numVectorElements = attributes.length;\\\\n        var _buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\\\\n        var f32 = new Float32Array(_buffer);\\\\n        var iElement = 0;\\\\n        var _iterator4 = _createForOfIteratorHelper(attributes),\\\\n          _step4;\\\\n        try {\\\\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\\\\n            var sourceName = _step4.value;\\\\n            var sourceBuffer = attributeBuffers[sourceName];\\\\n            var _offset = sourceBuffer.offset,\\\\n              _scale = sourceBuffer.scale;\\\\n            var _view = new DataView(sourceBuffer.buffer);\\\\n            var getter = _view.getFloat32.bind(_view);\\\\n            for (var j = 0; j < numPoints; j++) {\\\\n              var value = getter(j * 4, true);\\\\n              f32[j * numVectorElements + iElement] = value / _scale + _offset;\\\\n            }\\\\n            iElement++;\\\\n          }\\\\n        } catch (err) {\\\\n          _iterator4.e(err);\\\\n        } finally {\\\\n          _iterator4.f();\\\\n        }\\\\n        var vecAttribute = new PointAttribute(_name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\\\\n        attributeBuffers[_name] = {\\\\n          buffer: _buffer,\\\\n          attribute: vecAttribute\\\\n        };\\\\n      }\\\\n    } catch (err) {\\\\n      _iterator3.e(err);\\\\n    } finally {\\\\n      _iterator3.f();\\\\n    }\\\\n  }\\\\n  var message = {\\\\n    buffer: buffer,\\\\n    attributeBuffers: attributeBuffers,\\\\n    density: occupancy,\\\\n    tightBoundingBox: {\\\\n      min: tightBoxMin,\\\\n      max: tightBoxMax\\\\n    }\\\\n  };\\\\n  var transferables = [];\\\\n  for (var property in message.attributeBuffers) {\\\\n    transferables.push(message.attributeBuffers[property].buffer);\\\\n  }\\\\n  transferables.push(buffer);\\\\n  postMessage(message, transferables);\\\\n};//# sourceURL=[module]\\\\n\\\")}},__webpack_exports__={};__webpack_modules__[256]()})();\", \"Worker\", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAwLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzP2RiNzgiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgd29ya2VyIGZyb20gXCIhIS4uLy4uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gV29ya2VyX2ZuKCkge1xuICByZXR1cm4gd29ya2VyKFwiKCgpPT57XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBfX3dlYnBhY2tfbW9kdWxlc19fPXsyNTY6KCk9PntldmFsKFxcXCJcXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy9sb2FkaW5nMi9wb2ludC1hdHRyaWJ1dGVzLnRzXFxcXG4vKipcXFxcclxcXFxuICogU29tZSB0eXBlcyBvZiBwb3NzaWJsZSBwb2ludCBhdHRyaWJ1dGUgZGF0YSBmb3JtYXRzXFxcXHJcXFxcbiAqXFxcXHJcXFxcbiAqIEBjbGFzc1xcXFxyXFxcXG4gKi9cXFxcclxcXFxuY29uc3QgUG9pbnRBdHRyaWJ1dGVUeXBlcyA9IHtcXFxcclxcXFxuICAgIERBVEFfVFlQRV9ET1VCTEU6IHsgb3JkaW5hbDogMCwgbmFtZTogJ2RvdWJsZScsIHNpemU6IDggfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9GTE9BVDogeyBvcmRpbmFsOiAxLCBuYW1lOiAnZmxvYXQnLCBzaXplOiA0IH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfSU5UODogeyBvcmRpbmFsOiAyLCBuYW1lOiAnaW50OCcsIHNpemU6IDEgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9VSU5UODogeyBvcmRpbmFsOiAzLCBuYW1lOiAndWludDgnLCBzaXplOiAxIH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfSU5UMTY6IHsgb3JkaW5hbDogNCwgbmFtZTogJ2ludDE2Jywgc2l6ZTogMiB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX1VJTlQxNjogeyBvcmRpbmFsOiA1LCBuYW1lOiAndWludDE2Jywgc2l6ZTogMiB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX0lOVDMyOiB7IG9yZGluYWw6IDYsIG5hbWU6ICdpbnQzMicsIHNpemU6IDQgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9VSU5UMzI6IHsgb3JkaW5hbDogNywgbmFtZTogJ3VpbnQzMicsIHNpemU6IDQgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQ2NDogeyBvcmRpbmFsOiA4LCBuYW1lOiAnaW50NjQnLCBzaXplOiA4IH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIG5hbWU6ICd1aW50NjQnLCBzaXplOiA4IH1cXFxcclxcXFxufTtcXFxcclxcXFxubGV0IGkgPSAwO1xcXFxyXFxcXG5mb3IgKGNvbnN0IG9iaiBpbiBQb2ludEF0dHJpYnV0ZVR5cGVzKSB7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZVR5cGVzW2ldID0gUG9pbnRBdHRyaWJ1dGVUeXBlc1tvYmpdO1xcXFxyXFxcXG4gICAgaSsrO1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5jbGFzcyBQb2ludEF0dHJpYnV0ZSB7XFxcXHJcXFxcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlLCBudW1FbGVtZW50cywgcmFuZ2UgPSBbSW5maW5pdHksIC1JbmZpbml0eV0sIHVyaSA9IHVuZGVmaW5lZCkge1xcXFxyXFxcXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XFxcXHJcXFxcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcXFxcclxcXFxuICAgICAgICB0aGlzLm51bUVsZW1lbnRzID0gbnVtRWxlbWVudHM7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xcXFxyXFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSB0aGlzLm51bUVsZW1lbnRzICogdGhpcy50eXBlLnNpemU7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9ICcnO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxyXFxcXG5jb25zdCBQT0lOVF9BVFRSSUJVVEVTID0ge1xcXFxyXFxcXG4gICAgUE9TSVRJT05fQ0FSVEVTSUFOOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1BPU0lUSU9OX0NBUlRFU0lBTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcclxcXFxuICAgIFJHQkFfUEFDS0VEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NPTE9SX1BBQ0tFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDQpLFxcXFxyXFxcXG4gICAgQ09MT1JfUEFDS0VEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NPTE9SX1BBQ0tFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDQpLFxcXFxyXFxcXG4gICAgUkdCX1BBQ0tFRDogbmV3IFBvaW50QXR0cmlidXRlKCdDT0xPUl9QQUNLRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9JTlQ4LCAzKSxcXFxcclxcXFxuICAgIE5PUk1BTF9GTE9BVFM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMX0ZMT0FUUycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcclxcXFxuICAgIElOVEVOU0lUWTogbmV3IFBvaW50QXR0cmlidXRlKCdJTlRFTlNJVFknLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UMTYsIDEpLFxcXFxyXFxcXG4gICAgQ0xBU1NJRklDQVRJT046IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ0xBU1NJRklDQVRJT04nLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXHJcXFxcbiAgICBOT1JNQUxfU1BIRVJFTUFQUEVEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTF9TUEhFUkVNQVBQRUQnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXFxcXHJcXFxcbiAgICBOT1JNQUxfT0NUMTY6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMX09DVDE2JywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxyXFxcXG4gICAgTk9STUFMOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05PUk1BTCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcclxcXFxuICAgIFJFVFVSTl9OVU1CRVI6IG5ldyBQb2ludEF0dHJpYnV0ZSgnUkVUVVJOX05VTUJFUicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcclxcXFxuICAgIE5VTUJFUl9PRl9SRVRVUk5TOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ05VTUJFUl9PRl9SRVRVUk5TJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxcXFxyXFxcXG4gICAgU09VUkNFX0lEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NPVVJDRV9JRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXHJcXFxcbiAgICBJTkRJQ0VTOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lORElDRVMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UMzIsIDEpLFxcXFxyXFxcXG4gICAgU1BBQ0lORzogbmV3IFBvaW50QXR0cmlidXRlKCdTUEFDSU5HJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDEpLFxcXFxyXFxcXG4gICAgR1BTX1RJTUU6IG5ldyBQb2ludEF0dHJpYnV0ZSgnR1BTX1RJTUUnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9ET1VCTEUsIDEpXFxcXHJcXFxcbn07XFxcXHJcXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlcyB7XFxcXHJcXFxcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMgPSBbXSwgYnl0ZVNpemUgPSAwLCBzaXplID0gMCwgdmVjdG9ycyA9IFtdKSB7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcXFxcclxcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gYnl0ZVNpemU7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcXFxcclxcXFxuICAgICAgICB0aGlzLnZlY3RvcnMgPSB2ZWN0b3JzO1xcXFxyXFxcXG4gICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZXMgIT0gbnVsbCkge1xcXFxyXFxcXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50QXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGVOYW1lID0gcG9pbnRBdHRyaWJ1dGVzW2ldO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSBQT0lOVF9BVFRSSUJVVEVTW3BvaW50QXR0cmlidXRlTmFtZV07XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplKys7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBhZGQocG9pbnRBdHRyaWJ1dGUpIHtcXFxcclxcXFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcclxcXFxuICAgICAgICB0aGlzLnNpemUrKztcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGFkZFZlY3Rvcih2ZWN0b3IpIHtcXFxcclxcXFxuICAgICAgICB0aGlzLnZlY3RvcnMucHVzaCh2ZWN0b3IpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaGFzTm9ybWFscygpIHtcXFxcclxcXFxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW25hbWVdO1xcXFxyXFxcXG4gICAgICAgICAgICBpZiAocG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX1NQSEVSRU1BUFBFRCB8fFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMX0ZMT0FUUyB8fFxcXFxyXFxcXG4gICAgICAgICAgICAgICAgcG9pbnRBdHRyaWJ1dGUgPT09IFBPSU5UX0FUVFJJQlVURVMuTk9STUFMIHx8XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfT0NUMTYpIHtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxyXFxcXG4gICAgICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB7XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGF0dHIgPT4gYXR0ci5uYW1lID09PSBhdHRyaWJ1dGVOYW1lKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4vc3JjL2xvYWRpbmcyL2RlY29kZXIud29ya2VyLmpzXFxcXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxcXFxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFxcXFxcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfVxcXFxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHsgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1xcXFxcXFwiQEBpdGVyYXRvclxcXFxcXFwiXTsgaWYgKG51bGwgIT0gdCkgeyB2YXIgZSwgbiwgaSwgdSwgYSA9IFtdLCBmID0gITAsIG8gPSAhMTsgdHJ5IHsgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkgeyBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47IGYgPSAhMTsgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApOyB9IGNhdGNoIChyKSB7IG8gPSAhMCwgbiA9IHI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuOyB9IGZpbmFsbHkgeyBpZiAobykgdGhyb3cgbjsgfSB9IHJldHVybiBhOyB9IH1cXFxcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxcXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFxcXFxcIkBAaXRlcmF0b3JcXFxcXFxcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcXFxcXCJudW1iZXJcXFxcXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cXFxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFxcXFxcXFwiT2JqZWN0XFxcXFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXFxcXFwiTWFwXFxcXFxcXCIgfHwgbiA9PT0gXFxcXFxcXCJTZXRcXFxcXFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcXFxcXFxcIkFyZ3VtZW50c1xcXFxcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxcXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cXFxcblxcXFxudmFyIHR5cGVkQXJyYXlNYXBwaW5nID0ge1xcXFxuICAnaW50OCc6IEludDhBcnJheSxcXFxcbiAgJ2ludDE2JzogSW50MTZBcnJheSxcXFxcbiAgJ2ludDMyJzogSW50MzJBcnJheSxcXFxcbiAgJ2ludDY0JzogRmxvYXQ2NEFycmF5LFxcXFxuICAndWludDgnOiBVaW50OEFycmF5LFxcXFxuICAndWludDE2JzogVWludDE2QXJyYXksXFxcXG4gICd1aW50MzInOiBVaW50MzJBcnJheSxcXFxcbiAgJ3VpbnQ2NCc6IEZsb2F0NjRBcnJheSxcXFxcbiAgJ2Zsb2F0JzogRmxvYXQzMkFycmF5LFxcXFxuICAnZG91YmxlJzogRmxvYXQ2NEFycmF5XFxcXG59O1xcXFxub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XFxcXG4gIHZhciBfZXZlbnQkZGF0YSA9IGV2ZW50LmRhdGEsXFxcXG4gICAgYnVmZmVyID0gX2V2ZW50JGRhdGEuYnVmZmVyLFxcXFxuICAgIHBvaW50QXR0cmlidXRlcyA9IF9ldmVudCRkYXRhLnBvaW50QXR0cmlidXRlcyxcXFxcbiAgICBzY2FsZSA9IF9ldmVudCRkYXRhLnNjYWxlLFxcXFxuICAgIG5hbWUgPSBfZXZlbnQkZGF0YS5uYW1lLFxcXFxuICAgIG1pbiA9IF9ldmVudCRkYXRhLm1pbixcXFxcbiAgICBtYXggPSBfZXZlbnQkZGF0YS5tYXgsXFxcXG4gICAgc2l6ZSA9IF9ldmVudCRkYXRhLnNpemUsXFxcXG4gICAgb2Zmc2V0ID0gX2V2ZW50JGRhdGEub2Zmc2V0LFxcXFxuICAgIG51bVBvaW50cyA9IF9ldmVudCRkYXRhLm51bVBvaW50cztcXFxcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcXFxcbiAgdmFyIGF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcXFxcbiAgdmFyIGF0dHJpYnV0ZU9mZnNldCA9IDA7XFxcXG4gIHZhciBieXRlc1BlclBvaW50ID0gMDtcXFxcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIHBvaW50QXR0cmlidXRlID0gX3N0ZXAudmFsdWU7XFxcXG4gICAgICBieXRlc1BlclBvaW50ICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxuICAgIH1cXFxcbiAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IuZigpO1xcXFxuICB9XFxcXG4gIHZhciBncmlkU2l6ZSA9IDMyO1xcXFxuICB2YXIgZ3JpZCA9IG5ldyBVaW50MzJBcnJheShNYXRoLnBvdyhncmlkU2l6ZSwgMykpO1xcXFxuICB2YXIgdG9JbmRleCA9IGZ1bmN0aW9uIHRvSW5kZXgoeCwgeSwgeikge1xcXFxuICAgIC8vIG1pbiBpcyBhbHJlYWR5IHN1YnRyYWN0ZWRcXFxcbiAgICB2YXIgZHggPSBncmlkU2l6ZSAqIHggLyBzaXplLng7XFxcXG4gICAgdmFyIGR5ID0gZ3JpZFNpemUgKiB5IC8gc2l6ZS55O1xcXFxuICAgIHZhciBkeiA9IGdyaWRTaXplICogeiAvIHNpemUuejtcXFxcbiAgICB2YXIgaXggPSBNYXRoLm1pbihwYXJzZUludChkeCksIGdyaWRTaXplIC0gMSk7XFxcXG4gICAgdmFyIGl5ID0gTWF0aC5taW4ocGFyc2VJbnQoZHkpLCBncmlkU2l6ZSAtIDEpO1xcXFxuICAgIHZhciBpeiA9IE1hdGgubWluKHBhcnNlSW50KGR6KSwgZ3JpZFNpemUgLSAxKTtcXFxcbiAgICB2YXIgaW5kZXggPSBpeCArIGl5ICogZ3JpZFNpemUgKyBpeiAqIGdyaWRTaXplICogZ3JpZFNpemU7XFxcXG4gICAgcmV0dXJuIGluZGV4O1xcXFxuICB9O1xcXFxuICB2YXIgbnVtT2NjdXBpZWRDZWxscyA9IDA7XFxcXG4gIHZhciB0aWdodEJveE1pbiA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXTtcXFxcbiAgdmFyIHRpZ2h0Qm94TWF4ID0gW051bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFldO1xcXFxuICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDI7XFxcXG4gIHRyeSB7XFxcXG4gICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcXFxcbiAgICAgIHZhciBfcG9pbnRBdHRyaWJ1dGUgPSBfc3RlcDIudmFsdWU7XFxcXG4gICAgICBpZiAoWydQT1NJVElPTl9DQVJURVNJQU4nLCAncG9zaXRpb24nXS5pbmNsdWRlcyhfcG9pbnRBdHRyaWJ1dGUubmFtZSkpIHtcXFxcbiAgICAgICAgdmFyIF9idWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmYpO1xcXFxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtUG9pbnRzOyBfaisrKSB7XFxcXG4gICAgICAgICAgdmFyIHBvaW50T2Zmc2V0ID0gX2ogKiBieXRlc1BlclBvaW50O1xcXFxuICAgICAgICAgIHZhciB4ID0gdmlldy5nZXRJbnQzMihwb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDAsIHRydWUpICogc2NhbGVbMF0gKyBvZmZzZXRbMF0gLSBtaW4ueDtcXFxcbiAgICAgICAgICB2YXIgeSA9IHZpZXcuZ2V0SW50MzIocG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyA0LCB0cnVlKSAqIHNjYWxlWzFdICsgb2Zmc2V0WzFdIC0gbWluLnk7XFxcXG4gICAgICAgICAgdmFyIHogPSB2aWV3LmdldEludDMyKHBvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgOCwgdHJ1ZSkgKiBzY2FsZVsyXSArIG9mZnNldFsyXSAtIG1pbi56O1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzBdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMF0sIHgpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzFdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMV0sIHkpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWluWzJdID0gTWF0aC5taW4odGlnaHRCb3hNaW5bMl0sIHopO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzBdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMF0sIHgpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzFdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMV0sIHkpO1xcXFxuICAgICAgICAgIHRpZ2h0Qm94TWF4WzJdID0gTWF0aC5tYXgodGlnaHRCb3hNYXhbMl0sIHopO1xcXFxuICAgICAgICAgIHZhciBpbmRleCA9IHRvSW5kZXgoeCwgeSwgeik7XFxcXG4gICAgICAgICAgdmFyIGNvdW50ID0gZ3JpZFtpbmRleF0rKztcXFxcbiAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcXFxcbiAgICAgICAgICAgIG51bU9jY3VwaWVkQ2VsbHMrKztcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgICAgcG9zaXRpb25zWzMgKiBfaiArIDBdID0geDtcXFxcbiAgICAgICAgICBwb3NpdGlvbnNbMyAqIF9qICsgMV0gPSB5O1xcXFxuICAgICAgICAgIHBvc2l0aW9uc1szICogX2ogKyAyXSA9IHo7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgYXR0cmlidXRlQnVmZmVyc1tfcG9pbnRBdHRyaWJ1dGUubmFtZV0gPSB7XFxcXG4gICAgICAgICAgYnVmZmVyOiBfYnVmZixcXFxcbiAgICAgICAgICBhdHRyaWJ1dGU6IF9wb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChbJ1JHQkEnLCAncmdiYSddLmluY2x1ZGVzKF9wb2ludEF0dHJpYnV0ZS5uYW1lKSkge1xcXFxuICAgICAgICB2YXIgX2J1ZmYyID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgY29sb3JzID0gbmV3IFVpbnQ4QXJyYXkoX2J1ZmYyKTtcXFxcbiAgICAgICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgbnVtUG9pbnRzOyBfajIrKykge1xcXFxuICAgICAgICAgIHZhciBfcG9pbnRPZmZzZXQgPSBfajIgKiBieXRlc1BlclBvaW50O1xcXFxuICAgICAgICAgIHZhciByID0gdmlldy5nZXRVaW50MTYoX3BvaW50T2Zmc2V0ICsgYXR0cmlidXRlT2Zmc2V0ICsgMCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgdmFyIGcgPSB2aWV3LmdldFVpbnQxNihfcG9pbnRPZmZzZXQgKyBhdHRyaWJ1dGVPZmZzZXQgKyAyLCB0cnVlKTtcXFxcbiAgICAgICAgICB2YXIgYiA9IHZpZXcuZ2V0VWludDE2KF9wb2ludE9mZnNldCArIGF0dHJpYnV0ZU9mZnNldCArIDQsIHRydWUpO1xcXFxuICAgICAgICAgIGNvbG9yc1s0ICogX2oyICsgMF0gPSByID4gMjU1ID8gciAvIDI1NiA6IHI7XFxcXG4gICAgICAgICAgY29sb3JzWzQgKiBfajIgKyAxXSA9IGcgPiAyNTUgPyBnIC8gMjU2IDogZztcXFxcbiAgICAgICAgICBjb2xvcnNbNCAqIF9qMiArIDJdID0gYiA+IDI1NSA/IGIgLyAyNTYgOiBiO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbX3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmYyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3BvaW50QXR0cmlidXRlXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9IGVsc2Uge1xcXFxuICAgICAgICB2YXIgX2J1ZmYzID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgX2YgPSBuZXcgRmxvYXQzMkFycmF5KF9idWZmMyk7XFxcXG4gICAgICAgIHZhciBUeXBlZEFycmF5ID0gdHlwZWRBcnJheU1hcHBpbmdbX3BvaW50QXR0cmlidXRlLnR5cGUubmFtZV07XFxcXG4gICAgICAgIHZhciBwcmVjaXNlQnVmZmVyID0gbmV3IFR5cGVkQXJyYXkobnVtUG9pbnRzKTtcXFxcbiAgICAgICAgdmFyIF9vZmZzZXQyID0gMCxcXFxcbiAgICAgICAgICBfc2NhbGUyID0gMTtcXFxcbiAgICAgICAgdmFyIGdldHRlck1hcCA9IHtcXFxcbiAgICAgICAgICAnaW50OCc6IHZpZXcuZ2V0SW50OCxcXFxcbiAgICAgICAgICAnaW50MTYnOiB2aWV3LmdldEludDE2LFxcXFxuICAgICAgICAgICdpbnQzMic6IHZpZXcuZ2V0SW50MzIsXFxcXG4gICAgICAgICAgLy8gJ2ludDY0JzogIHZpZXcuZ2V0SW50NjQsXFxcXG4gICAgICAgICAgJ3VpbnQ4Jzogdmlldy5nZXRVaW50OCxcXFxcbiAgICAgICAgICAndWludDE2Jzogdmlldy5nZXRVaW50MTYsXFxcXG4gICAgICAgICAgJ3VpbnQzMic6IHZpZXcuZ2V0VWludDMyLFxcXFxuICAgICAgICAgIC8vICd1aW50NjQnOiB2aWV3LmdldFVpbnQ2NCxcXFxcbiAgICAgICAgICAnZmxvYXQnOiB2aWV3LmdldEZsb2F0MzIsXFxcXG4gICAgICAgICAgJ2RvdWJsZSc6IHZpZXcuZ2V0RmxvYXQ2NFxcXFxuICAgICAgICB9O1xcXFxuICAgICAgICB2YXIgX2dldHRlciA9IGdldHRlck1hcFtfcG9pbnRBdHRyaWJ1dGUudHlwZS5uYW1lXS5iaW5kKHZpZXcpO1xcXFxuXFxcXG4gICAgICAgIC8vIGNvbXB1dGUgb2Zmc2V0IGFuZCBzY2FsZSB0byBwYWNrIGxhcmdlciB0eXBlcyBpbnRvIDMyIGJpdCBmbG9hdHNcXFxcbiAgICAgICAgaWYgKF9wb2ludEF0dHJpYnV0ZS50eXBlLnNpemUgPiA0KSB7XFxcXG4gICAgICAgICAgdmFyIF9wb2ludEF0dHJpYnV0ZSRyYW5nZSA9IF9zbGljZWRUb0FycmF5KF9wb2ludEF0dHJpYnV0ZS5yYW5nZSwgMiksXFxcXG4gICAgICAgICAgICBhbWluID0gX3BvaW50QXR0cmlidXRlJHJhbmdlWzBdLFxcXFxuICAgICAgICAgICAgYW1heCA9IF9wb2ludEF0dHJpYnV0ZSRyYW5nZVsxXTtcXFxcbiAgICAgICAgICBfb2Zmc2V0MiA9IGFtaW47XFxcXG4gICAgICAgICAgX3NjYWxlMiA9IDEgLyAoYW1heCAtIGFtaW4pO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIGZvciAodmFyIF9qMyA9IDA7IF9qMyA8IG51bVBvaW50czsgX2ozKyspIHtcXFxcbiAgICAgICAgICB2YXIgX3BvaW50T2Zmc2V0MiA9IF9qMyAqIGJ5dGVzUGVyUG9pbnQ7XFxcXG4gICAgICAgICAgdmFyIF92YWx1ZSA9IF9nZXR0ZXIoX3BvaW50T2Zmc2V0MiArIGF0dHJpYnV0ZU9mZnNldCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgX2ZbX2ozXSA9IChfdmFsdWUgLSBfb2Zmc2V0MikgKiBfc2NhbGUyO1xcXFxuICAgICAgICAgIHByZWNpc2VCdWZmZXJbX2ozXSA9IF92YWx1ZTtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW19wb2ludEF0dHJpYnV0ZS5uYW1lXSA9IHtcXFxcbiAgICAgICAgICBidWZmZXI6IF9idWZmMyxcXFxcbiAgICAgICAgICBwcmVjaXNlQnVmZmVyOiBwcmVjaXNlQnVmZmVyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogX3BvaW50QXR0cmlidXRlLFxcXFxuICAgICAgICAgIG9mZnNldDogX29mZnNldDIsXFxcXG4gICAgICAgICAgc2NhbGU6IF9zY2FsZTJcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH1cXFxcbiAgICAgIGF0dHJpYnV0ZU9mZnNldCArPSBfcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XFxcXG4gICAgfVxcXFxuICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICBfaXRlcmF0b3IyLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IyLmYoKTtcXFxcbiAgfVxcXFxuICB2YXIgb2NjdXBhbmN5ID0gcGFyc2VJbnQobnVtUG9pbnRzIC8gbnVtT2NjdXBpZWRDZWxscyk7XFxcXG4gIHtcXFxcbiAgICAvLyBhZGQgaW5kaWNlc1xcXFxuICAgIHZhciBidWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQpO1xcXFxuICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmYpO1xcXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUG9pbnRzOyBpKyspIHtcXFxcbiAgICAgIGluZGljZXNbaV0gPSBpO1xcXFxuICAgIH1cXFxcbiAgICBhdHRyaWJ1dGVCdWZmZXJzWydJTkRJQ0VTJ10gPSB7XFxcXG4gICAgICBidWZmZXI6IGJ1ZmYsXFxcXG4gICAgICBhdHRyaWJ1dGU6IFBvaW50QXR0cmlidXRlLklORElDRVNcXFxcbiAgICB9O1xcXFxuICB9XFxcXG4gIHtcXFxcbiAgICAvLyBoYW5kbGUgYXR0cmlidXRlIHZlY3RvcnNcXFxcbiAgICB2YXIgdmVjdG9ycyA9IHBvaW50QXR0cmlidXRlcy52ZWN0b3JzO1xcXFxuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodmVjdG9ycyksXFxcXG4gICAgICBfc3RlcDM7XFxcXG4gICAgdHJ5IHtcXFxcbiAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XFxcXG4gICAgICAgIHZhciB2ZWN0b3IgPSBfc3RlcDMudmFsdWU7XFxcXG4gICAgICAgIHZhciBfbmFtZSA9IHZlY3Rvci5uYW1lLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZXMgPSB2ZWN0b3IuYXR0cmlidXRlcztcXFxcbiAgICAgICAgdmFyIG51bVZlY3RvckVsZW1lbnRzID0gYXR0cmlidXRlcy5sZW5ndGg7XFxcXG4gICAgICAgIHZhciBfYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG51bVZlY3RvckVsZW1lbnRzICogbnVtUG9pbnRzICogNCk7XFxcXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KF9idWZmZXIpO1xcXFxuICAgICAgICB2YXIgaUVsZW1lbnQgPSAwO1xcXFxuICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGF0dHJpYnV0ZXMpLFxcXFxuICAgICAgICAgIF9zdGVwNDtcXFxcbiAgICAgICAgdHJ5IHtcXFxcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xcXFxuICAgICAgICAgICAgdmFyIHNvdXJjZU5hbWUgPSBfc3RlcDQudmFsdWU7XFxcXG4gICAgICAgICAgICB2YXIgc291cmNlQnVmZmVyID0gYXR0cmlidXRlQnVmZmVyc1tzb3VyY2VOYW1lXTtcXFxcbiAgICAgICAgICAgIHZhciBfb2Zmc2V0ID0gc291cmNlQnVmZmVyLm9mZnNldCxcXFxcbiAgICAgICAgICAgICAgX3NjYWxlID0gc291cmNlQnVmZmVyLnNjYWxlO1xcXFxuICAgICAgICAgICAgdmFyIF92aWV3ID0gbmV3IERhdGFWaWV3KHNvdXJjZUJ1ZmZlci5idWZmZXIpO1xcXFxuICAgICAgICAgICAgdmFyIGdldHRlciA9IF92aWV3LmdldEZsb2F0MzIuYmluZChfdmlldyk7XFxcXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bVBvaW50czsgaisrKSB7XFxcXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGdldHRlcihqICogNCwgdHJ1ZSk7XFxcXG4gICAgICAgICAgICAgIGYzMltqICogbnVtVmVjdG9yRWxlbWVudHMgKyBpRWxlbWVudF0gPSB2YWx1ZSAvIF9zY2FsZSArIF9vZmZzZXQ7XFxcXG4gICAgICAgICAgICB9XFxcXG4gICAgICAgICAgICBpRWxlbWVudCsrO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgICAgICAgX2l0ZXJhdG9yNC5lKGVycik7XFxcXG4gICAgICAgIH0gZmluYWxseSB7XFxcXG4gICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XFxcXG4gICAgICAgIH1cXFxcbiAgICAgICAgdmFyIHZlY0F0dHJpYnV0ZSA9IG5ldyBQb2ludEF0dHJpYnV0ZShfbmFtZSwgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpO1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW19uYW1lXSA9IHtcXFxcbiAgICAgICAgICBidWZmZXI6IF9idWZmZXIsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiB2ZWNBdHRyaWJ1dGVcXFxcbiAgICAgICAgfTtcXFxcbiAgICAgIH1cXFxcbiAgICB9IGNhdGNoIChlcnIpIHtcXFxcbiAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xcXFxuICAgIH0gZmluYWxseSB7XFxcXG4gICAgICBfaXRlcmF0b3IzLmYoKTtcXFxcbiAgICB9XFxcXG4gIH1cXFxcbiAgdmFyIG1lc3NhZ2UgPSB7XFxcXG4gICAgYnVmZmVyOiBidWZmZXIsXFxcXG4gICAgYXR0cmlidXRlQnVmZmVyczogYXR0cmlidXRlQnVmZmVycyxcXFxcbiAgICBkZW5zaXR5OiBvY2N1cGFuY3ksXFxcXG4gICAgdGlnaHRCb3VuZGluZ0JveDoge1xcXFxuICAgICAgbWluOiB0aWdodEJveE1pbixcXFxcbiAgICAgIG1heDogdGlnaHRCb3hNYXhcXFxcbiAgICB9XFxcXG4gIH07XFxcXG4gIHZhciB0cmFuc2ZlcmFibGVzID0gW107XFxcXG4gIGZvciAodmFyIHByb3BlcnR5IGluIG1lc3NhZ2UuYXR0cmlidXRlQnVmZmVycykge1xcXFxuICAgIHRyYW5zZmVyYWJsZXMucHVzaChtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnNbcHJvcGVydHldLmJ1ZmZlcik7XFxcXG4gIH1cXFxcbiAgdHJhbnNmZXJhYmxlcy5wdXNoKGJ1ZmZlcik7XFxcXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVyYWJsZXMpO1xcXFxufTsvLyMgc291cmNlVVJMPVttb2R1bGVdXFxcXG5cXFwiKX19LF9fd2VicGFja19leHBvcnRzX189e307X193ZWJwYWNrX21vZHVsZXNfX1syNTZdKCl9KSgpO1wiLCBcIldvcmtlclwiLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///300\n")},218:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()(\"(()=>{\\\"use strict\\\";var __webpack_modules__={374:()=>{eval(\\\"\\\\n;// CONCATENATED MODULE: ./src/loading2/point-attributes.ts\\\\n/**\\\\r\\\\n * Some types of possible point attribute data formats\\\\r\\\\n *\\\\r\\\\n * @class\\\\r\\\\n */\\\\r\\\\nconst PointAttributeTypes = {\\\\r\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, name: 'double', size: 8 },\\\\r\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, name: 'float', size: 4 },\\\\r\\\\n    DATA_TYPE_INT8: { ordinal: 2, name: 'int8', size: 1 },\\\\r\\\\n    DATA_TYPE_UINT8: { ordinal: 3, name: 'uint8', size: 1 },\\\\r\\\\n    DATA_TYPE_INT16: { ordinal: 4, name: 'int16', size: 2 },\\\\r\\\\n    DATA_TYPE_UINT16: { ordinal: 5, name: 'uint16', size: 2 },\\\\r\\\\n    DATA_TYPE_INT32: { ordinal: 6, name: 'int32', size: 4 },\\\\r\\\\n    DATA_TYPE_UINT32: { ordinal: 7, name: 'uint32', size: 4 },\\\\r\\\\n    DATA_TYPE_INT64: { ordinal: 8, name: 'int64', size: 8 },\\\\r\\\\n    DATA_TYPE_UINT64: { ordinal: 9, name: 'uint64', size: 8 }\\\\r\\\\n};\\\\r\\\\nlet i = 0;\\\\r\\\\nfor (const obj in PointAttributeTypes) {\\\\r\\\\n    PointAttributeTypes[i] = PointAttributeTypes[obj];\\\\r\\\\n    i++;\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nclass PointAttribute {\\\\r\\\\n    constructor(name, type, numElements, range = [Infinity, -Infinity], uri = undefined) {\\\\r\\\\n        this.name = name;\\\\r\\\\n        this.type = type;\\\\r\\\\n        this.numElements = numElements;\\\\r\\\\n        this.range = range;\\\\r\\\\n        this.uri = uri;\\\\r\\\\n        this.byteSize = this.numElements * this.type.size;\\\\r\\\\n        this.description = '';\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nconst POINT_ATTRIBUTES = {\\\\r\\\\n    POSITION_CARTESIAN: new PointAttribute('POSITION_CARTESIAN', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    RGBA_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\r\\\\n    COLOR_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 4),\\\\r\\\\n    RGB_PACKED: new PointAttribute('COLOR_PACKED', PointAttributeTypes.DATA_TYPE_INT8, 3),\\\\r\\\\n    NORMAL_FLOATS: new PointAttribute('NORMAL_FLOATS', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    INTENSITY: new PointAttribute('INTENSITY', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\r\\\\n    CLASSIFICATION: new PointAttribute('CLASSIFICATION', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    NORMAL_SPHEREMAPPED: new PointAttribute('NORMAL_SPHEREMAPPED', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL_OCT16: new PointAttribute('NORMAL_OCT16', PointAttributeTypes.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL: new PointAttribute('NORMAL', PointAttributeTypes.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    RETURN_NUMBER: new PointAttribute('RETURN_NUMBER', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    NUMBER_OF_RETURNS: new PointAttribute('NUMBER_OF_RETURNS', PointAttributeTypes.DATA_TYPE_UINT8, 1),\\\\r\\\\n    SOURCE_ID: new PointAttribute('SOURCE_ID', PointAttributeTypes.DATA_TYPE_UINT16, 1),\\\\r\\\\n    INDICES: new PointAttribute('INDICES', PointAttributeTypes.DATA_TYPE_UINT32, 1),\\\\r\\\\n    SPACING: new PointAttribute('SPACING', PointAttributeTypes.DATA_TYPE_FLOAT, 1),\\\\r\\\\n    GPS_TIME: new PointAttribute('GPS_TIME', PointAttributeTypes.DATA_TYPE_DOUBLE, 1)\\\\r\\\\n};\\\\r\\\\nclass PointAttributes {\\\\r\\\\n    constructor(pointAttributes, attributes = [], byteSize = 0, size = 0, vectors = []) {\\\\r\\\\n        this.attributes = attributes;\\\\r\\\\n        this.byteSize = byteSize;\\\\r\\\\n        this.size = size;\\\\r\\\\n        this.vectors = vectors;\\\\r\\\\n        if (pointAttributes != null) {\\\\r\\\\n            for (let i = 0; i < pointAttributes.length; i++) {\\\\r\\\\n                const pointAttributeName = pointAttributes[i];\\\\r\\\\n                const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\r\\\\n                this.attributes.push(pointAttribute);\\\\r\\\\n                this.byteSize += pointAttribute.byteSize;\\\\r\\\\n                this.size++;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    add(pointAttribute) {\\\\r\\\\n        this.attributes.push(pointAttribute);\\\\r\\\\n        this.byteSize += pointAttribute.byteSize;\\\\r\\\\n        this.size++;\\\\r\\\\n    }\\\\r\\\\n    addVector(vector) {\\\\r\\\\n        this.vectors.push(vector);\\\\r\\\\n    }\\\\r\\\\n    hasNormals() {\\\\r\\\\n        for (const name in this.attributes) {\\\\r\\\\n            const pointAttribute = this.attributes[name];\\\\r\\\\n            if (pointAttribute === POINT_ATTRIBUTES.NORMAL_SPHEREMAPPED ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_FLOATS ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL ||\\\\r\\\\n                pointAttribute === POINT_ATTRIBUTES.NORMAL_OCT16) {\\\\r\\\\n                return true;\\\\r\\\\n            }\\\\r\\\\n        }\\\\r\\\\n        return false;\\\\r\\\\n    }\\\\r\\\\n    getAttribute(attributeName) {\\\\r\\\\n        return this.attributes.find(attr => attr.name === attributeName);\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/loading2/gltf-decoder.worker.js\\\\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \\\\\\\"undefined\\\\\\\" && o[Symbol.iterator] || o[\\\\\\\"@@iterator\\\\\\\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\\\\\"number\\\\\\\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\\\\\\\"Invalid attempt to iterate non-iterable instance.\\\\\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\\\\\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\\\\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \\\\\\\"string\\\\\\\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \\\\\\\"Object\\\\\\\" && o.constructor) n = o.constructor.name; if (n === \\\\\\\"Map\\\\\\\" || n === \\\\\\\"Set\\\\\\\") return Array.from(o); if (n === \\\\\\\"Arguments\\\\\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\\\\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\\\\n\\\\nvar typedArrayMapping = {\\\\n  'int8': Int8Array,\\\\n  'int16': Int16Array,\\\\n  'int32': Int32Array,\\\\n  'int64': Float64Array,\\\\n  'uint8': Uint8Array,\\\\n  'uint16': Uint16Array,\\\\n  'uint32': Uint32Array,\\\\n  'uint64': Float64Array,\\\\n  'float': Float32Array,\\\\n  'double': Float64Array\\\\n};\\\\nonmessage = function onmessage(event) {\\\\n  var _event$data = event.data,\\\\n    buffer = _event$data.buffer,\\\\n    pointAttributes = _event$data.pointAttributes,\\\\n    scale = _event$data.scale,\\\\n    name = _event$data.name,\\\\n    min = _event$data.min,\\\\n    max = _event$data.max,\\\\n    size = _event$data.size,\\\\n    offset = _event$data.offset,\\\\n    numPoints = _event$data.numPoints;\\\\n  var view = new DataView(buffer);\\\\n  var attributeBuffers = {};\\\\n  var bytesPerPointPosition = 4 * 3;\\\\n  var gridSize = 32;\\\\n  var grid = new Uint32Array(Math.pow(gridSize, 3));\\\\n  var toIndex = function toIndex(x, y, z) {\\\\n    // min is already subtracted\\\\n    var dx = gridSize * x / size.x;\\\\n    var dy = gridSize * y / size.y;\\\\n    var dz = gridSize * z / size.z;\\\\n    var ix = Math.min(parseInt(dx), gridSize - 1);\\\\n    var iy = Math.min(parseInt(dy), gridSize - 1);\\\\n    var iz = Math.min(parseInt(dz), gridSize - 1);\\\\n    var index = ix + iy * gridSize + iz * gridSize * gridSize;\\\\n    return index;\\\\n  };\\\\n  var numOccupiedCells = 0;\\\\n  var tightBoxMin = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\\\\n  var tightBoxMax = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\\\\n  var _iterator = _createForOfIteratorHelper(pointAttributes.attributes),\\\\n    _step;\\\\n  try {\\\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\\\n      var pointAttribute = _step.value;\\\\n      if ([\\\\\\\"POSITION_CARTESIAN\\\\\\\", \\\\\\\"position\\\\\\\"].includes(pointAttribute.name)) {\\\\n        var _buff = new ArrayBuffer(numPoints * 4 * 3);\\\\n        var positions = new Float32Array(_buff);\\\\n        for (var _j = 0; _j < numPoints; _j++) {\\\\n          var pointOffset = _j * bytesPerPointPosition;\\\\n          var x = view.getFloat32(pointOffset + 0, true) + offset[0] - min.x;\\\\n          var y = view.getFloat32(pointOffset + 4, true) + offset[1] - min.y;\\\\n          var z = view.getFloat32(pointOffset + 8, true) + offset[2] - min.z;\\\\n          tightBoxMin[0] = Math.min(tightBoxMin[0], x);\\\\n          tightBoxMin[1] = Math.min(tightBoxMin[1], y);\\\\n          tightBoxMin[2] = Math.min(tightBoxMin[2], z);\\\\n          tightBoxMax[0] = Math.max(tightBoxMax[0], x);\\\\n          tightBoxMax[1] = Math.max(tightBoxMax[1], y);\\\\n          tightBoxMax[2] = Math.max(tightBoxMax[2], z);\\\\n          var index = toIndex(x, y, z);\\\\n          var count = grid[index]++;\\\\n          if (count === 0) {\\\\n            numOccupiedCells++;\\\\n          }\\\\n          positions[3 * _j + 0] = x;\\\\n          positions[3 * _j + 1] = y;\\\\n          positions[3 * _j + 2] = z;\\\\n        }\\\\n        attributeBuffers[pointAttribute.name] = {\\\\n          buffer: _buff,\\\\n          attribute: pointAttribute\\\\n        };\\\\n      } else if ([\\\\\\\"RGBA\\\\\\\", \\\\\\\"rgba\\\\\\\"].includes(pointAttribute.name)) {\\\\n        attributeBuffers[pointAttribute.name] = {\\\\n          buffer: buffer.slice(numPoints * bytesPerPointPosition),\\\\n          attribute: pointAttribute\\\\n        };\\\\n      }\\\\n    }\\\\n  } catch (err) {\\\\n    _iterator.e(err);\\\\n  } finally {\\\\n    _iterator.f();\\\\n  }\\\\n  var occupancy = parseInt(numPoints / numOccupiedCells);\\\\n  {\\\\n    // add indices\\\\n    var buff = new ArrayBuffer(numPoints * 4);\\\\n    var indices = new Uint32Array(buff);\\\\n    for (var i = 0; i < numPoints; i++) {\\\\n      indices[i] = i;\\\\n    }\\\\n    attributeBuffers[\\\\\\\"INDICES\\\\\\\"] = {\\\\n      buffer: buff,\\\\n      attribute: PointAttribute.INDICES\\\\n    };\\\\n  }\\\\n  {\\\\n    // handle attribute vectors\\\\n    var vectors = pointAttributes.vectors;\\\\n    var _iterator2 = _createForOfIteratorHelper(vectors),\\\\n      _step2;\\\\n    try {\\\\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\\\\n        var vector = _step2.value;\\\\n        var _name = vector.name,\\\\n          attributes = vector.attributes;\\\\n        var numVectorElements = attributes.length;\\\\n        var _buffer = new ArrayBuffer(numVectorElements * numPoints * 4);\\\\n        var f32 = new Float32Array(_buffer);\\\\n        var iElement = 0;\\\\n        var _iterator3 = _createForOfIteratorHelper(attributes),\\\\n          _step3;\\\\n        try {\\\\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\\\\n            var sourceName = _step3.value;\\\\n            var sourceBuffer = attributeBuffers[sourceName];\\\\n            var _offset = sourceBuffer.offset,\\\\n              _scale = sourceBuffer.scale;\\\\n            var _view = new DataView(sourceBuffer.buffer);\\\\n            var getter = _view.getFloat32.bind(_view);\\\\n            for (var j = 0; j < numPoints; j++) {\\\\n              var value = getter(j * 4, true);\\\\n              f32[j * numVectorElements + iElement] = value / _scale + _offset;\\\\n            }\\\\n            iElement++;\\\\n          }\\\\n        } catch (err) {\\\\n          _iterator3.e(err);\\\\n        } finally {\\\\n          _iterator3.f();\\\\n        }\\\\n        var vecAttribute = new PointAttribute(_name, PointAttributeTypes.DATA_TYPE_FLOAT, 3);\\\\n        attributeBuffers[_name] = {\\\\n          buffer: _buffer,\\\\n          attribute: vecAttribute\\\\n        };\\\\n      }\\\\n    } catch (err) {\\\\n      _iterator2.e(err);\\\\n    } finally {\\\\n      _iterator2.f();\\\\n    }\\\\n  }\\\\n  var message = {\\\\n    buffer: buffer,\\\\n    attributeBuffers: attributeBuffers,\\\\n    density: occupancy,\\\\n    tightBoundingBox: {\\\\n      min: tightBoxMin,\\\\n      max: tightBoxMax\\\\n    }\\\\n  };\\\\n  var transferables = [];\\\\n  for (var property in message.attributeBuffers) {\\\\n    transferables.push(message.attributeBuffers[property].buffer);\\\\n  }\\\\n  transferables.push(buffer);\\\\n  postMessage(message, transferables);\\\\n};//# sourceURL=[module]\\\\n\\\")}},__webpack_exports__={};__webpack_modules__[374]()})();\", \"Worker\", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjE4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcG90cmVlLy4vc3JjL2xvYWRpbmcyL2dsdGYtZGVjb2Rlci53b3JrZXIuanM/MjI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB3b3JrZXIgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC9ydW50aW1lL2lubGluZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXb3JrZXJfZm4oKSB7XG4gIHJldHVybiB3b3JrZXIoXCIoKCk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIF9fd2VicGFja19tb2R1bGVzX189ezM3NDooKT0+e2V2YWwoXFxcIlxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL2xvYWRpbmcyL3BvaW50LWF0dHJpYnV0ZXMudHNcXFxcbi8qKlxcXFxyXFxcXG4gKiBTb21lIHR5cGVzIG9mIHBvc3NpYmxlIHBvaW50IGF0dHJpYnV0ZSBkYXRhIGZvcm1hdHNcXFxcclxcXFxuICpcXFxcclxcXFxuICogQGNsYXNzXFxcXHJcXFxcbiAqL1xcXFxyXFxcXG5jb25zdCBQb2ludEF0dHJpYnV0ZVR5cGVzID0ge1xcXFxyXFxcXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBuYW1lOiAnZG91YmxlJywgc2l6ZTogOCB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX0ZMT0FUOiB7IG9yZGluYWw6IDEsIG5hbWU6ICdmbG9hdCcsIHNpemU6IDQgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQ4OiB7IG9yZGluYWw6IDIsIG5hbWU6ICdpbnQ4Jywgc2l6ZTogMSB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIG5hbWU6ICd1aW50OCcsIHNpemU6IDEgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQxNjogeyBvcmRpbmFsOiA0LCBuYW1lOiAnaW50MTYnLCBzaXplOiAyIH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIG5hbWU6ICd1aW50MTYnLCBzaXplOiAyIH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfSU5UMzI6IHsgb3JkaW5hbDogNiwgbmFtZTogJ2ludDMyJywgc2l6ZTogNCB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX1VJTlQzMjogeyBvcmRpbmFsOiA3LCBuYW1lOiAndWludDMyJywgc2l6ZTogNCB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX0lOVDY0OiB7IG9yZGluYWw6IDgsIG5hbWU6ICdpbnQ2NCcsIHNpemU6IDggfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9VSU5UNjQ6IHsgb3JkaW5hbDogOSwgbmFtZTogJ3VpbnQ2NCcsIHNpemU6IDggfVxcXFxyXFxcXG59O1xcXFxyXFxcXG5sZXQgaSA9IDA7XFxcXHJcXFxcbmZvciAoY29uc3Qgb2JqIGluIFBvaW50QXR0cmlidXRlVHlwZXMpIHtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlVHlwZXNbaV0gPSBQb2ludEF0dHJpYnV0ZVR5cGVzW29ial07XFxcXHJcXFxcbiAgICBpKys7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlIHtcXFxcclxcXFxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzLCByYW5nZSA9IFtJbmZpbml0eSwgLUluZmluaXR5XSwgdXJpID0gdW5kZWZpbmVkKSB7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcXFxcclxcXFxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xcXFxyXFxcXG4gICAgICAgIHRoaXMubnVtRWxlbWVudHMgPSBudW1FbGVtZW50cztcXFxcclxcXFxuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XFxcXHJcXFxcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSA9IHRoaXMubnVtRWxlbWVudHMgKiB0aGlzLnR5cGUuc2l6ZTtcXFxcclxcXFxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gJyc7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXHJcXFxcbmNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XFxcXHJcXFxcbiAgICBQT1NJVElPTl9DQVJURVNJQU46IG5ldyBQb2ludEF0dHJpYnV0ZSgnUE9TSVRJT05fQ0FSVEVTSUFOJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxyXFxcXG4gICAgUkdCQV9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXFxcXHJcXFxcbiAgICBDT0xPUl9QQUNLRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnQ09MT1JfUEFDS0VEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfSU5UOCwgNCksXFxcXHJcXFxcbiAgICBSR0JfUEFDS0VEOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0NPTE9SX1BBQ0tFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0lOVDgsIDMpLFxcXFxyXFxcXG4gICAgTk9STUFMX0ZMT0FUUzogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfRkxPQVRTJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxyXFxcXG4gICAgSU5URU5TSVRZOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ0lOVEVOU0lUWScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQxNiwgMSksXFxcXHJcXFxcbiAgICBDTEFTU0lGSUNBVElPTjogbmV3IFBvaW50QXR0cmlidXRlKCdDTEFTU0lGSUNBVElPTicsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAxKSxcXFxcclxcXFxuICAgIE5PUk1BTF9TUEhFUkVNQVBQRUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMX1NQSEVSRU1BUFBFRCcsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcXFxcclxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbmV3IFBvaW50QXR0cmlidXRlKCdOT1JNQUxfT0NUMTYnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMiksXFxcXHJcXFxcbiAgICBOT1JNQUw6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTk9STUFMJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfRkxPQVQsIDMpLFxcXFxyXFxcXG4gICAgUkVUVVJOX05VTUJFUjogbmV3IFBvaW50QXR0cmlidXRlKCdSRVRVUk5fTlVNQkVSJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxcXFxyXFxcXG4gICAgTlVNQkVSX09GX1JFVFVSTlM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnTlVNQkVSX09GX1JFVFVSTlMnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9VSU5UOCwgMSksXFxcXHJcXFxcbiAgICBTT1VSQ0VfSUQ6IG5ldyBQb2ludEF0dHJpYnV0ZSgnU09VUkNFX0lEJywgUG9pbnRBdHRyaWJ1dGVUeXBlcy5EQVRBX1RZUEVfVUlOVDE2LCAxKSxcXFxcclxcXFxuICAgIElORElDRVM6IG5ldyBQb2ludEF0dHJpYnV0ZSgnSU5ESUNFUycsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX1VJTlQzMiwgMSksXFxcXHJcXFxcbiAgICBTUEFDSU5HOiBuZXcgUG9pbnRBdHRyaWJ1dGUoJ1NQQUNJTkcnLCBQb2ludEF0dHJpYnV0ZVR5cGVzLkRBVEFfVFlQRV9GTE9BVCwgMSksXFxcXHJcXFxcbiAgICBHUFNfVElNRTogbmV3IFBvaW50QXR0cmlidXRlKCdHUFNfVElNRScsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0RPVUJMRSwgMSlcXFxcclxcXFxufTtcXFxcclxcXFxuY2xhc3MgUG9pbnRBdHRyaWJ1dGVzIHtcXFxcclxcXFxuICAgIGNvbnN0cnVjdG9yKHBvaW50QXR0cmlidXRlcywgYXR0cmlidXRlcyA9IFtdLCBieXRlU2l6ZSA9IDAsIHNpemUgPSAwLCB2ZWN0b3JzID0gW10pIHtcXFxcclxcXFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xcXFxyXFxcXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBieXRlU2l6ZTtcXFxcclxcXFxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudmVjdG9ycyA9IHZlY3RvcnM7XFxcXHJcXFxcbiAgICAgICAgaWYgKHBvaW50QXR0cmlidXRlcyAhPSBudWxsKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRBdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZXNbaV07XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcXFxcclxcXFxuICAgICAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgKz0gcG9pbnRBdHRyaWJ1dGUuYnl0ZVNpemU7XFxcXHJcXFxcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUrKztcXFxcclxcXFxuICAgICAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGFkZChwb2ludEF0dHJpYnV0ZSkge1xcXFxyXFxcXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKHBvaW50QXR0cmlidXRlKTtcXFxcclxcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxyXFxcXG4gICAgICAgIHRoaXMuc2l6ZSsrO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgYWRkVmVjdG9yKHZlY3Rvcikge1xcXFxyXFxcXG4gICAgICAgIHRoaXMudmVjdG9ycy5wdXNoKHZlY3Rvcik7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBoYXNOb3JtYWxzKCkge1xcXFxyXFxcXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcXFxcclxcXFxuICAgICAgICAgICAgY29uc3QgcG9pbnRBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XFxcXHJcXFxcbiAgICAgICAgICAgIGlmIChwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfU1BIRVJFTUFQUEVEIHx8XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUxfRkxPQVRTIHx8XFxcXHJcXFxcbiAgICAgICAgICAgICAgICBwb2ludEF0dHJpYnV0ZSA9PT0gUE9JTlRfQVRUUklCVVRFUy5OT1JNQUwgfHxcXFxcclxcXFxuICAgICAgICAgICAgICAgIHBvaW50QXR0cmlidXRlID09PSBQT0lOVF9BVFRSSUJVVEVTLk5PUk1BTF9PQ1QxNikge1xcXFxyXFxcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXHJcXFxcbiAgICAgICAgICAgIH1cXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoYXR0ciA9PiBhdHRyLm5hbWUgPT09IGF0dHJpYnV0ZU5hbWUpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9zcmMvbG9hZGluZzIvZ2x0Zi1kZWNvZGVyLndvcmtlci5qc1xcXFxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXFxcXFxcXCJ1bmRlZmluZWRcXFxcXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFxcXFxcIkBAaXRlcmF0b3JcXFxcXFxcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXFxcXFxcXCJudW1iZXJcXFxcXFxcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcXFxcXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXFxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXFxcXFwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cXFxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXFxcXFxcXCJzdHJpbmdcXFxcXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFxcXFxcXFwiT2JqZWN0XFxcXFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFxcXFxcXFwiTWFwXFxcXFxcXCIgfHwgbiA9PT0gXFxcXFxcXCJTZXRcXFxcXFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcXFxcXFxcIkFyZ3VtZW50c1xcXFxcXFwiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxcXFxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cXFxcblxcXFxudmFyIHR5cGVkQXJyYXlNYXBwaW5nID0ge1xcXFxuICAnaW50OCc6IEludDhBcnJheSxcXFxcbiAgJ2ludDE2JzogSW50MTZBcnJheSxcXFxcbiAgJ2ludDMyJzogSW50MzJBcnJheSxcXFxcbiAgJ2ludDY0JzogRmxvYXQ2NEFycmF5LFxcXFxuICAndWludDgnOiBVaW50OEFycmF5LFxcXFxuICAndWludDE2JzogVWludDE2QXJyYXksXFxcXG4gICd1aW50MzInOiBVaW50MzJBcnJheSxcXFxcbiAgJ3VpbnQ2NCc6IEZsb2F0NjRBcnJheSxcXFxcbiAgJ2Zsb2F0JzogRmxvYXQzMkFycmF5LFxcXFxuICAnZG91YmxlJzogRmxvYXQ2NEFycmF5XFxcXG59O1xcXFxub25tZXNzYWdlID0gZnVuY3Rpb24gb25tZXNzYWdlKGV2ZW50KSB7XFxcXG4gIHZhciBfZXZlbnQkZGF0YSA9IGV2ZW50LmRhdGEsXFxcXG4gICAgYnVmZmVyID0gX2V2ZW50JGRhdGEuYnVmZmVyLFxcXFxuICAgIHBvaW50QXR0cmlidXRlcyA9IF9ldmVudCRkYXRhLnBvaW50QXR0cmlidXRlcyxcXFxcbiAgICBzY2FsZSA9IF9ldmVudCRkYXRhLnNjYWxlLFxcXFxuICAgIG5hbWUgPSBfZXZlbnQkZGF0YS5uYW1lLFxcXFxuICAgIG1pbiA9IF9ldmVudCRkYXRhLm1pbixcXFxcbiAgICBtYXggPSBfZXZlbnQkZGF0YS5tYXgsXFxcXG4gICAgc2l6ZSA9IF9ldmVudCRkYXRhLnNpemUsXFxcXG4gICAgb2Zmc2V0ID0gX2V2ZW50JGRhdGEub2Zmc2V0LFxcXFxuICAgIG51bVBvaW50cyA9IF9ldmVudCRkYXRhLm51bVBvaW50cztcXFxcbiAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcXFxcbiAgdmFyIGF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcXFxcbiAgdmFyIGJ5dGVzUGVyUG9pbnRQb3NpdGlvbiA9IDQgKiAzO1xcXFxuICB2YXIgZ3JpZFNpemUgPSAzMjtcXFxcbiAgdmFyIGdyaWQgPSBuZXcgVWludDMyQXJyYXkoTWF0aC5wb3coZ3JpZFNpemUsIDMpKTtcXFxcbiAgdmFyIHRvSW5kZXggPSBmdW5jdGlvbiB0b0luZGV4KHgsIHksIHopIHtcXFxcbiAgICAvLyBtaW4gaXMgYWxyZWFkeSBzdWJ0cmFjdGVkXFxcXG4gICAgdmFyIGR4ID0gZ3JpZFNpemUgKiB4IC8gc2l6ZS54O1xcXFxuICAgIHZhciBkeSA9IGdyaWRTaXplICogeSAvIHNpemUueTtcXFxcbiAgICB2YXIgZHogPSBncmlkU2l6ZSAqIHogLyBzaXplLno7XFxcXG4gICAgdmFyIGl4ID0gTWF0aC5taW4ocGFyc2VJbnQoZHgpLCBncmlkU2l6ZSAtIDEpO1xcXFxuICAgIHZhciBpeSA9IE1hdGgubWluKHBhcnNlSW50KGR5KSwgZ3JpZFNpemUgLSAxKTtcXFxcbiAgICB2YXIgaXogPSBNYXRoLm1pbihwYXJzZUludChkeiksIGdyaWRTaXplIC0gMSk7XFxcXG4gICAgdmFyIGluZGV4ID0gaXggKyBpeSAqIGdyaWRTaXplICsgaXogKiBncmlkU2l6ZSAqIGdyaWRTaXplO1xcXFxuICAgIHJldHVybiBpbmRleDtcXFxcbiAgfTtcXFxcbiAgdmFyIG51bU9jY3VwaWVkQ2VsbHMgPSAwO1xcXFxuICB2YXIgdGlnaHRCb3hNaW4gPSBbTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWV07XFxcXG4gIHZhciB0aWdodEJveE1heCA9IFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXTtcXFxcbiAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSxcXFxcbiAgICBfc3RlcDtcXFxcbiAgdHJ5IHtcXFxcbiAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xcXFxuICAgICAgdmFyIHBvaW50QXR0cmlidXRlID0gX3N0ZXAudmFsdWU7XFxcXG4gICAgICBpZiAoW1xcXFxcXFwiUE9TSVRJT05fQ0FSVEVTSUFOXFxcXFxcXCIsIFxcXFxcXFwicG9zaXRpb25cXFxcXFxcIl0uaW5jbHVkZXMocG9pbnRBdHRyaWJ1dGUubmFtZSkpIHtcXFxcbiAgICAgICAgdmFyIF9idWZmID0gbmV3IEFycmF5QnVmZmVyKG51bVBvaW50cyAqIDQgKiAzKTtcXFxcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoX2J1ZmYpO1xcXFxuICAgICAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgbnVtUG9pbnRzOyBfaisrKSB7XFxcXG4gICAgICAgICAgdmFyIHBvaW50T2Zmc2V0ID0gX2ogKiBieXRlc1BlclBvaW50UG9zaXRpb247XFxcXG4gICAgICAgICAgdmFyIHggPSB2aWV3LmdldEZsb2F0MzIocG9pbnRPZmZzZXQgKyAwLCB0cnVlKSArIG9mZnNldFswXSAtIG1pbi54O1xcXFxuICAgICAgICAgIHZhciB5ID0gdmlldy5nZXRGbG9hdDMyKHBvaW50T2Zmc2V0ICsgNCwgdHJ1ZSkgKyBvZmZzZXRbMV0gLSBtaW4ueTtcXFxcbiAgICAgICAgICB2YXIgeiA9IHZpZXcuZ2V0RmxvYXQzMihwb2ludE9mZnNldCArIDgsIHRydWUpICsgb2Zmc2V0WzJdIC0gbWluLno7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMF0gPSBNYXRoLm1pbih0aWdodEJveE1pblswXSwgeCk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMV0gPSBNYXRoLm1pbih0aWdodEJveE1pblsxXSwgeSk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNaW5bMl0gPSBNYXRoLm1pbih0aWdodEJveE1pblsyXSwgeik7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMF0gPSBNYXRoLm1heCh0aWdodEJveE1heFswXSwgeCk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMV0gPSBNYXRoLm1heCh0aWdodEJveE1heFsxXSwgeSk7XFxcXG4gICAgICAgICAgdGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heCh0aWdodEJveE1heFsyXSwgeik7XFxcXG4gICAgICAgICAgdmFyIGluZGV4ID0gdG9JbmRleCh4LCB5LCB6KTtcXFxcbiAgICAgICAgICB2YXIgY291bnQgPSBncmlkW2luZGV4XSsrO1xcXFxuICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xcXFxuICAgICAgICAgICAgbnVtT2NjdXBpZWRDZWxscysrO1xcXFxuICAgICAgICAgIH1cXFxcbiAgICAgICAgICBwb3NpdGlvbnNbMyAqIF9qICsgMF0gPSB4O1xcXFxuICAgICAgICAgIHBvc2l0aW9uc1szICogX2ogKyAxXSA9IHk7XFxcXG4gICAgICAgICAgcG9zaXRpb25zWzMgKiBfaiArIDJdID0gejtcXFxcbiAgICAgICAgfVxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogX2J1ZmYsXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfSBlbHNlIGlmIChbXFxcXFxcXCJSR0JBXFxcXFxcXCIsIFxcXFxcXFwicmdiYVxcXFxcXFwiXS5pbmNsdWRlcyhwb2ludEF0dHJpYnV0ZS5uYW1lKSkge1xcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzW3BvaW50QXR0cmlidXRlLm5hbWVdID0ge1xcXFxuICAgICAgICAgIGJ1ZmZlcjogYnVmZmVyLnNsaWNlKG51bVBvaW50cyAqIGJ5dGVzUGVyUG9pbnRQb3NpdGlvbiksXFxcXG4gICAgICAgICAgYXR0cmlidXRlOiBwb2ludEF0dHJpYnV0ZVxcXFxuICAgICAgICB9O1xcXFxuICAgICAgfVxcXFxuICAgIH1cXFxcbiAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXFxcbiAgfSBmaW5hbGx5IHtcXFxcbiAgICBfaXRlcmF0b3IuZigpO1xcXFxuICB9XFxcXG4gIHZhciBvY2N1cGFuY3kgPSBwYXJzZUludChudW1Qb2ludHMgLyBudW1PY2N1cGllZENlbGxzKTtcXFxcbiAge1xcXFxuICAgIC8vIGFkZCBpbmRpY2VzXFxcXG4gICAgdmFyIGJ1ZmYgPSBuZXcgQXJyYXlCdWZmZXIobnVtUG9pbnRzICogNCk7XFxcXG4gICAgdmFyIGluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoYnVmZik7XFxcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xcXFxuICAgICAgaW5kaWNlc1tpXSA9IGk7XFxcXG4gICAgfVxcXFxuICAgIGF0dHJpYnV0ZUJ1ZmZlcnNbXFxcXFxcXCJJTkRJQ0VTXFxcXFxcXCJdID0ge1xcXFxuICAgICAgYnVmZmVyOiBidWZmLFxcXFxuICAgICAgYXR0cmlidXRlOiBQb2ludEF0dHJpYnV0ZS5JTkRJQ0VTXFxcXG4gICAgfTtcXFxcbiAgfVxcXFxuICB7XFxcXG4gICAgLy8gaGFuZGxlIGF0dHJpYnV0ZSB2ZWN0b3JzXFxcXG4gICAgdmFyIHZlY3RvcnMgPSBwb2ludEF0dHJpYnV0ZXMudmVjdG9ycztcXFxcbiAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZlY3RvcnMpLFxcXFxuICAgICAgX3N0ZXAyO1xcXFxuICAgIHRyeSB7XFxcXG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xcXFxuICAgICAgICB2YXIgdmVjdG9yID0gX3N0ZXAyLnZhbHVlO1xcXFxuICAgICAgICB2YXIgX25hbWUgPSB2ZWN0b3IubmFtZSxcXFxcbiAgICAgICAgICBhdHRyaWJ1dGVzID0gdmVjdG9yLmF0dHJpYnV0ZXM7XFxcXG4gICAgICAgIHZhciBudW1WZWN0b3JFbGVtZW50cyA9IGF0dHJpYnV0ZXMubGVuZ3RoO1xcXFxuICAgICAgICB2YXIgX2J1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihudW1WZWN0b3JFbGVtZW50cyAqIG51bVBvaW50cyAqIDQpO1xcXFxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShfYnVmZmVyKTtcXFxcbiAgICAgICAgdmFyIGlFbGVtZW50ID0gMDtcXFxcbiAgICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihhdHRyaWJ1dGVzKSxcXFxcbiAgICAgICAgICBfc3RlcDM7XFxcXG4gICAgICAgIHRyeSB7XFxcXG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcXFxcbiAgICAgICAgICAgIHZhciBzb3VyY2VOYW1lID0gX3N0ZXAzLnZhbHVlO1xcXFxuICAgICAgICAgICAgdmFyIHNvdXJjZUJ1ZmZlciA9IGF0dHJpYnV0ZUJ1ZmZlcnNbc291cmNlTmFtZV07XFxcXG4gICAgICAgICAgICB2YXIgX29mZnNldCA9IHNvdXJjZUJ1ZmZlci5vZmZzZXQsXFxcXG4gICAgICAgICAgICAgIF9zY2FsZSA9IHNvdXJjZUJ1ZmZlci5zY2FsZTtcXFxcbiAgICAgICAgICAgIHZhciBfdmlldyA9IG5ldyBEYXRhVmlldyhzb3VyY2VCdWZmZXIuYnVmZmVyKTtcXFxcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBfdmlldy5nZXRGbG9hdDMyLmJpbmQoX3ZpZXcpO1xcXFxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Qb2ludHM7IGorKykge1xcXFxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIoaiAqIDQsIHRydWUpO1xcXFxuICAgICAgICAgICAgICBmMzJbaiAqIG51bVZlY3RvckVsZW1lbnRzICsgaUVsZW1lbnRdID0gdmFsdWUgLyBfc2NhbGUgKyBfb2Zmc2V0O1xcXFxuICAgICAgICAgICAgfVxcXFxuICAgICAgICAgICAgaUVsZW1lbnQrKztcXFxcbiAgICAgICAgICB9XFxcXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xcXFxuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xcXFxuICAgICAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xcXFxuICAgICAgICB9XFxcXG4gICAgICAgIHZhciB2ZWNBdHRyaWJ1dGUgPSBuZXcgUG9pbnRBdHRyaWJ1dGUoX25hbWUsIFBvaW50QXR0cmlidXRlVHlwZXMuREFUQV9UWVBFX0ZMT0FULCAzKTtcXFxcbiAgICAgICAgYXR0cmlidXRlQnVmZmVyc1tfbmFtZV0gPSB7XFxcXG4gICAgICAgICAgYnVmZmVyOiBfYnVmZmVyLFxcXFxuICAgICAgICAgIGF0dHJpYnV0ZTogdmVjQXR0cmlidXRlXFxcXG4gICAgICAgIH07XFxcXG4gICAgICB9XFxcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxcXG4gICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcXFxcbiAgICB9IGZpbmFsbHkge1xcXFxuICAgICAgX2l0ZXJhdG9yMi5mKCk7XFxcXG4gICAgfVxcXFxuICB9XFxcXG4gIHZhciBtZXNzYWdlID0ge1xcXFxuICAgIGJ1ZmZlcjogYnVmZmVyLFxcXFxuICAgIGF0dHJpYnV0ZUJ1ZmZlcnM6IGF0dHJpYnV0ZUJ1ZmZlcnMsXFxcXG4gICAgZGVuc2l0eTogb2NjdXBhbmN5LFxcXFxuICAgIHRpZ2h0Qm91bmRpbmdCb3g6IHtcXFxcbiAgICAgIG1pbjogdGlnaHRCb3hNaW4sXFxcXG4gICAgICBtYXg6IHRpZ2h0Qm94TWF4XFxcXG4gICAgfVxcXFxuICB9O1xcXFxuICB2YXIgdHJhbnNmZXJhYmxlcyA9IFtdO1xcXFxuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBtZXNzYWdlLmF0dHJpYnV0ZUJ1ZmZlcnMpIHtcXFxcbiAgICB0cmFuc2ZlcmFibGVzLnB1c2gobWVzc2FnZS5hdHRyaWJ1dGVCdWZmZXJzW3Byb3BlcnR5XS5idWZmZXIpO1xcXFxuICB9XFxcXG4gIHRyYW5zZmVyYWJsZXMucHVzaChidWZmZXIpO1xcXFxuICBwb3N0TWVzc2FnZShtZXNzYWdlLCB0cmFuc2ZlcmFibGVzKTtcXFxcbn07Ly8jIHNvdXJjZVVSTD1bbW9kdWxlXVxcXFxuXFxcIil9fSxfX3dlYnBhY2tfZXhwb3J0c19fPXt9O19fd2VicGFja19tb2R1bGVzX19bMzc0XSgpfSkoKTtcIiwgXCJXb3JrZXJcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///218\n")},91:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ Worker_fn)\n/* harmony export */ });\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(512);\n/* harmony import */ var _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\nfunction Worker_fn() {\n  return _node_modules_worker_loader_dist_runtime_inline_js__WEBPACK_IMPORTED_MODULE_0___default()("(()=>{\\"use strict\\";var __webpack_modules__={717:()=>{eval(\'\\\\n;// CONCATENATED MODULE: ./src/point-attributes.ts\\\\n// -------------------------------------------------------------------------------------------------\\\\r\\\\n// Converted to Typescript and adapted from https://github.com/potree/potree\\\\r\\\\n// -------------------------------------------------------------------------------------------------\\\\r\\\\nvar PointAttributeName;\\\\r\\\\n(function (PointAttributeName) {\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"POSITION_CARTESIAN\\"] = 0] = \\"POSITION_CARTESIAN\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_PACKED\\"] = 1] = \\"COLOR_PACKED\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_1\\"] = 2] = \\"COLOR_FLOATS_1\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"COLOR_FLOATS_255\\"] = 3] = \\"COLOR_FLOATS_255\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_FLOATS\\"] = 4] = \\"NORMAL_FLOATS\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"FILLER\\"] = 5] = \\"FILLER\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"INTENSITY\\"] = 6] = \\"INTENSITY\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"CLASSIFICATION\\"] = 7] = \\"CLASSIFICATION\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_SPHEREMAPPED\\"] = 8] = \\"NORMAL_SPHEREMAPPED\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL_OCT16\\"] = 9] = \\"NORMAL_OCT16\\";\\\\r\\\\n    PointAttributeName[PointAttributeName[\\"NORMAL\\"] = 10] = \\"NORMAL\\";\\\\r\\\\n})(PointAttributeName || (PointAttributeName = {}));\\\\r\\\\nconst POINT_ATTRIBUTE_TYPES = {\\\\r\\\\n    DATA_TYPE_DOUBLE: { ordinal: 0, size: 8 },\\\\r\\\\n    DATA_TYPE_FLOAT: { ordinal: 1, size: 4 },\\\\r\\\\n    DATA_TYPE_INT8: { ordinal: 2, size: 1 },\\\\r\\\\n    DATA_TYPE_UINT8: { ordinal: 3, size: 1 },\\\\r\\\\n    DATA_TYPE_INT16: { ordinal: 4, size: 2 },\\\\r\\\\n    DATA_TYPE_UINT16: { ordinal: 5, size: 2 },\\\\r\\\\n    DATA_TYPE_INT32: { ordinal: 6, size: 4 },\\\\r\\\\n    DATA_TYPE_UINT32: { ordinal: 7, size: 4 },\\\\r\\\\n    DATA_TYPE_INT64: { ordinal: 8, size: 8 },\\\\r\\\\n    DATA_TYPE_UINT64: { ordinal: 9, size: 8 },\\\\r\\\\n};\\\\r\\\\nfunction makePointAttribute(name, type, numElements) {\\\\r\\\\n    return {\\\\r\\\\n        name,\\\\r\\\\n        type,\\\\r\\\\n        numElements,\\\\r\\\\n        byteSize: numElements * type.size,\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nconst RGBA_PACKED = makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 4);\\\\r\\\\nconst POINT_ATTRIBUTES = {\\\\r\\\\n    POSITION_CARTESIAN: makePointAttribute(PointAttributeName.POSITION_CARTESIAN, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    RGBA_PACKED,\\\\r\\\\n    COLOR_PACKED: RGBA_PACKED,\\\\r\\\\n    RGB_PACKED: makePointAttribute(PointAttributeName.COLOR_PACKED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_INT8, 3),\\\\r\\\\n    NORMAL_FLOATS: makePointAttribute(PointAttributeName.NORMAL_FLOATS, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\r\\\\n    FILLER_1B: makePointAttribute(PointAttributeName.FILLER, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\r\\\\n    INTENSITY: makePointAttribute(PointAttributeName.INTENSITY, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT16, 1),\\\\r\\\\n    CLASSIFICATION: makePointAttribute(PointAttributeName.CLASSIFICATION, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 1),\\\\r\\\\n    NORMAL_SPHEREMAPPED: makePointAttribute(PointAttributeName.NORMAL_SPHEREMAPPED, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL_OCT16: makePointAttribute(PointAttributeName.NORMAL_OCT16, POINT_ATTRIBUTE_TYPES.DATA_TYPE_UINT8, 2),\\\\r\\\\n    NORMAL: makePointAttribute(PointAttributeName.NORMAL, POINT_ATTRIBUTE_TYPES.DATA_TYPE_FLOAT, 3),\\\\r\\\\n};\\\\r\\\\nclass PointAttributes {\\\\r\\\\n    constructor(pointAttributeNames = []) {\\\\r\\\\n        this.attributes = [];\\\\r\\\\n        this.byteSize = 0;\\\\r\\\\n        this.size = 0;\\\\r\\\\n        for (let i = 0; i < pointAttributeNames.length; i++) {\\\\r\\\\n            const pointAttributeName = pointAttributeNames[i];\\\\r\\\\n            const pointAttribute = POINT_ATTRIBUTES[pointAttributeName];\\\\r\\\\n            this.attributes.push(pointAttribute);\\\\r\\\\n            this.byteSize += pointAttribute.byteSize;\\\\r\\\\n            this.size++;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    add(pointAttribute) {\\\\r\\\\n        this.attributes.push(pointAttribute);\\\\r\\\\n        this.byteSize += pointAttribute.byteSize;\\\\r\\\\n        this.size++;\\\\r\\\\n    }\\\\r\\\\n    hasColors() {\\\\r\\\\n        return this.attributes.find(isColorAttribute) !== undefined;\\\\r\\\\n    }\\\\r\\\\n    hasNormals() {\\\\r\\\\n        return this.attributes.find(isNormalAttribute) !== undefined;\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\nfunction isColorAttribute({ name }) {\\\\r\\\\n    return name === PointAttributeName.COLOR_PACKED;\\\\r\\\\n}\\\\r\\\\nfunction isNormalAttribute({ name }) {\\\\r\\\\n    return (name === PointAttributeName.NORMAL_SPHEREMAPPED ||\\\\r\\\\n        name === PointAttributeName.NORMAL_FLOATS ||\\\\r\\\\n        name === PointAttributeName.NORMAL ||\\\\r\\\\n        name === PointAttributeName.NORMAL_OCT16);\\\\r\\\\n}\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./src/version.ts\\\\nclass Version {\\\\r\\\\n    constructor(version) {\\\\r\\\\n        this.versionMinor = 0;\\\\r\\\\n        this.version = version;\\\\r\\\\n        const vmLength = version.indexOf(\\\\\'.\\\\\') === -1 ? version.length : version.indexOf(\\\\\'.\\\\\');\\\\r\\\\n        this.versionMajor = parseInt(version.substr(0, vmLength), 10);\\\\r\\\\n        this.versionMinor = parseInt(version.substr(vmLength + 1), 10);\\\\r\\\\n        if (isNaN(this.versionMinor)) {\\\\r\\\\n            this.versionMinor = 0;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    newerThan(version) {\\\\r\\\\n        const v = new Version(version);\\\\r\\\\n        if (this.versionMajor > v.versionMajor) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor > v.versionMinor) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    equalOrHigher(version) {\\\\r\\\\n        const v = new Version(version);\\\\r\\\\n        if (this.versionMajor > v.versionMajor) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else if (this.versionMajor === v.versionMajor && this.versionMinor >= v.versionMinor) {\\\\r\\\\n            return true;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            return false;\\\\r\\\\n        }\\\\r\\\\n    }\\\\r\\\\n    upTo(version) {\\\\r\\\\n        return !this.newerThan(version);\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/custom-array-view.ts\\\\n/**\\\\r\\\\n * Adapted from Potree.js http://potree.org\\\\r\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\r\\\\n */\\\\r\\\\n// http://jsperf.com/uint8array-vs-dataview3/3\\\\r\\\\n// tslint:disable:no-bitwise\\\\r\\\\nclass CustomArrayView {\\\\r\\\\n    constructor(buffer) {\\\\r\\\\n        this.tmp = new ArrayBuffer(4);\\\\r\\\\n        this.tmpf = new Float32Array(this.tmp);\\\\r\\\\n        this.tmpu8 = new Uint8Array(this.tmp);\\\\r\\\\n        this.u8 = new Uint8Array(buffer);\\\\r\\\\n    }\\\\r\\\\n    getUint32(i) {\\\\r\\\\n        return (this.u8[i + 3] << 24) | (this.u8[i + 2] << 16) | (this.u8[i + 1] << 8) | this.u8[i];\\\\r\\\\n    }\\\\r\\\\n    getUint16(i) {\\\\r\\\\n        return (this.u8[i + 1] << 8) | this.u8[i];\\\\r\\\\n    }\\\\r\\\\n    getFloat32(i) {\\\\r\\\\n        const tmpu8 = this.tmpu8;\\\\r\\\\n        const u8 = this.u8;\\\\r\\\\n        const tmpf = this.tmpf;\\\\r\\\\n        tmpu8[0] = u8[i + 0];\\\\r\\\\n        tmpu8[1] = u8[i + 1];\\\\r\\\\n        tmpu8[2] = u8[i + 2];\\\\r\\\\n        tmpu8[3] = u8[i + 3];\\\\r\\\\n        return tmpf[0];\\\\r\\\\n    }\\\\r\\\\n    getUint8(i) {\\\\r\\\\n        return this.u8[i];\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\n// tslint:enable:no-bitwise\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./src/workers/binary-decoder-worker-internal.ts\\\\n/**\\\\r\\\\n * Adapted from Potree.js http://potree.org\\\\r\\\\n * Potree License: https://github.com/potree/potree/blob/1.5/LICENSE\\\\r\\\\n */\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n\\\\r\\\\n// IE11 does not have Math.sign(), this has been adapted from CoreJS es6.math.sign.js for TypeScript\\\\r\\\\nconst mathSign = Math.sign ||\\\\r\\\\n    function (x) {\\\\r\\\\n        // tslint:disable-next-line:triple-equals\\\\r\\\\n        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\\\\r\\\\n    };\\\\r\\\\nfunction handleMessage(event) {\\\\r\\\\n    const buffer = event.data.buffer;\\\\r\\\\n    const pointAttributes = event.data.pointAttributes;\\\\r\\\\n    const ctx = {\\\\r\\\\n        attributeBuffers: {},\\\\r\\\\n        currentOffset: 0,\\\\r\\\\n        data: new CustomArrayView(buffer),\\\\r\\\\n        mean: [0, 0, 0],\\\\r\\\\n        nodeOffset: event.data.offset,\\\\r\\\\n        numPoints: event.data.buffer.byteLength / pointAttributes.byteSize,\\\\r\\\\n        pointAttributes,\\\\r\\\\n        scale: event.data.scale,\\\\r\\\\n        tightBoxMax: [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\\\\r\\\\n        tightBoxMin: [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\\\\r\\\\n        transferables: [],\\\\r\\\\n        version: new Version(event.data.version),\\\\r\\\\n    };\\\\r\\\\n    for (const pointAttribute of ctx.pointAttributes.attributes) {\\\\r\\\\n        decodeAndAddAttribute(pointAttribute, ctx);\\\\r\\\\n        ctx.currentOffset += pointAttribute.byteSize;\\\\r\\\\n    }\\\\r\\\\n    const indices = new ArrayBuffer(ctx.numPoints * 4);\\\\r\\\\n    const iIndices = new Uint32Array(indices);\\\\r\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\r\\\\n        iIndices[i] = i;\\\\r\\\\n    }\\\\r\\\\n    if (!ctx.attributeBuffers[PointAttributeName.CLASSIFICATION]) {\\\\r\\\\n        addEmptyClassificationBuffer(ctx);\\\\r\\\\n    }\\\\r\\\\n    const message = {\\\\r\\\\n        buffer: buffer,\\\\r\\\\n        mean: ctx.mean,\\\\r\\\\n        attributeBuffers: ctx.attributeBuffers,\\\\r\\\\n        tightBoundingBox: { min: ctx.tightBoxMin, max: ctx.tightBoxMax },\\\\r\\\\n        indices,\\\\r\\\\n    };\\\\r\\\\n    postMessage(message, ctx.transferables);\\\\r\\\\n}\\\\r\\\\nfunction addEmptyClassificationBuffer(ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\r\\\\n    const classifications = new Float32Array(buffer);\\\\r\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\r\\\\n        classifications[i] = 0;\\\\r\\\\n    }\\\\r\\\\n    ctx.attributeBuffers[PointAttributeName.CLASSIFICATION] = {\\\\r\\\\n        buffer,\\\\r\\\\n        attribute: POINT_ATTRIBUTES.CLASSIFICATION,\\\\r\\\\n    };\\\\r\\\\n}\\\\r\\\\nfunction decodeAndAddAttribute(attribute, ctx) {\\\\r\\\\n    const decodedAttribute = decodePointAttribute(attribute, ctx);\\\\r\\\\n    if (decodedAttribute === undefined) {\\\\r\\\\n        return;\\\\r\\\\n    }\\\\r\\\\n    ctx.attributeBuffers[decodedAttribute.attribute.name] = decodedAttribute;\\\\r\\\\n    ctx.transferables.push(decodedAttribute.buffer);\\\\r\\\\n}\\\\r\\\\nfunction decodePointAttribute(attribute, ctx) {\\\\r\\\\n    switch (attribute.name) {\\\\r\\\\n        case PointAttributeName.POSITION_CARTESIAN:\\\\r\\\\n            return decodePositionCartesian(attribute, ctx);\\\\r\\\\n        case PointAttributeName.COLOR_PACKED:\\\\r\\\\n            return decodeColor(attribute, ctx);\\\\r\\\\n        case PointAttributeName.INTENSITY:\\\\r\\\\n            return decodeIntensity(attribute, ctx);\\\\r\\\\n        case PointAttributeName.CLASSIFICATION:\\\\r\\\\n            return decodeClassification(attribute, ctx);\\\\r\\\\n        case PointAttributeName.NORMAL_SPHEREMAPPED:\\\\r\\\\n            return decodeNormalSphereMapped(attribute, ctx);\\\\r\\\\n        case PointAttributeName.NORMAL_OCT16:\\\\r\\\\n            return decodeNormalOct16(attribute, ctx);\\\\r\\\\n        case PointAttributeName.NORMAL:\\\\r\\\\n            return decodeNormal(attribute, ctx);\\\\r\\\\n        default:\\\\r\\\\n            return undefined;\\\\r\\\\n    }\\\\r\\\\n}\\\\r\\\\nfunction decodePositionCartesian(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\r\\\\n    const positions = new Float32Array(buffer);\\\\r\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\r\\\\n        let x;\\\\r\\\\n        let y;\\\\r\\\\n        let z;\\\\r\\\\n        if (ctx.version.newerThan(\\\\\'1.3\\\\\')) {\\\\r\\\\n            x = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0) * ctx.scale;\\\\r\\\\n            y = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 4) * ctx.scale;\\\\r\\\\n            z = ctx.data.getUint32(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 8) * ctx.scale;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            x = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 0) + ctx.nodeOffset[0];\\\\r\\\\n            y = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 4) + ctx.nodeOffset[1];\\\\r\\\\n            z = ctx.data.getFloat32(i * ctx.pointAttributes.byteSize + 8) + ctx.nodeOffset[2];\\\\r\\\\n        }\\\\r\\\\n        positions[3 * i + 0] = x;\\\\r\\\\n        positions[3 * i + 1] = y;\\\\r\\\\n        positions[3 * i + 2] = z;\\\\r\\\\n        ctx.mean[0] += x / ctx.numPoints;\\\\r\\\\n        ctx.mean[1] += y / ctx.numPoints;\\\\r\\\\n        ctx.mean[2] += z / ctx.numPoints;\\\\r\\\\n        ctx.tightBoxMin[0] = Math.min(ctx.tightBoxMin[0], x);\\\\r\\\\n        ctx.tightBoxMin[1] = Math.min(ctx.tightBoxMin[1], y);\\\\r\\\\n        ctx.tightBoxMin[2] = Math.min(ctx.tightBoxMin[2], z);\\\\r\\\\n        ctx.tightBoxMax[0] = Math.max(ctx.tightBoxMax[0], x);\\\\r\\\\n        ctx.tightBoxMax[1] = Math.max(ctx.tightBoxMax[1], y);\\\\r\\\\n        ctx.tightBoxMax[2] = Math.max(ctx.tightBoxMax[2], z);\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeColor(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 3);\\\\r\\\\n    const colors = new Uint8Array(buffer);\\\\r\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\r\\\\n        colors[3 * i + 0] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 0);\\\\r\\\\n        colors[3 * i + 1] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 1);\\\\r\\\\n        colors[3 * i + 2] = ctx.data.getUint8(ctx.currentOffset + i * ctx.pointAttributes.byteSize + 2);\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeIntensity(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4);\\\\r\\\\n    const intensities = new Float32Array(buffer);\\\\r\\\\n    for (let i = 0; i < ctx.numPoints; i++) {\\\\r\\\\n        intensities[i] = ctx.data.getUint16(ctx.currentOffset + i * ctx.pointAttributes.byteSize);\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeClassification(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints);\\\\r\\\\n    const classifications = new Uint8Array(buffer);\\\\r\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\r\\\\n        classifications[j] = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize);\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeNormalSphereMapped(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\r\\\\n    const normals = new Float32Array(buffer);\\\\r\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\r\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\r\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\r\\\\n        const ex = bx / 255;\\\\r\\\\n        const ey = by / 255;\\\\r\\\\n        let nx = ex * 2 - 1;\\\\r\\\\n        let ny = ey * 2 - 1;\\\\r\\\\n        let nz = 1;\\\\r\\\\n        const nw = -1;\\\\r\\\\n        const l = nx * -nx + ny * -ny + nz * -nw;\\\\r\\\\n        nz = l;\\\\r\\\\n        nx = nx * Math.sqrt(l);\\\\r\\\\n        ny = ny * Math.sqrt(l);\\\\r\\\\n        nx = nx * 2;\\\\r\\\\n        ny = ny * 2;\\\\r\\\\n        nz = nz * 2 - 1;\\\\r\\\\n        normals[3 * j + 0] = nx;\\\\r\\\\n        normals[3 * j + 1] = ny;\\\\r\\\\n        normals[3 * j + 2] = nz;\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeNormalOct16(attribute, ctx) {\\\\r\\\\n    const buff = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\r\\\\n    const normals = new Float32Array(buff);\\\\r\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\r\\\\n        const bx = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\r\\\\n        const by = ctx.data.getUint8(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 1);\\\\r\\\\n        const u = (bx / 255) * 2 - 1;\\\\r\\\\n        const v = (by / 255) * 2 - 1;\\\\r\\\\n        let z = 1 - Math.abs(u) - Math.abs(v);\\\\r\\\\n        let x = 0;\\\\r\\\\n        let y = 0;\\\\r\\\\n        if (z >= 0) {\\\\r\\\\n            x = u;\\\\r\\\\n            y = v;\\\\r\\\\n        }\\\\r\\\\n        else {\\\\r\\\\n            x = -(v / mathSign(v) - 1) / mathSign(u);\\\\r\\\\n            y = -(u / mathSign(u) - 1) / mathSign(v);\\\\r\\\\n        }\\\\r\\\\n        const length = Math.sqrt(x * x + y * y + z * z);\\\\r\\\\n        x = x / length;\\\\r\\\\n        y = y / length;\\\\r\\\\n        z = z / length;\\\\r\\\\n        normals[3 * j + 0] = x;\\\\r\\\\n        normals[3 * j + 1] = y;\\\\r\\\\n        normals[3 * j + 2] = z;\\\\r\\\\n    }\\\\r\\\\n    return { buffer: buff, attribute };\\\\r\\\\n}\\\\r\\\\nfunction decodeNormal(attribute, ctx) {\\\\r\\\\n    const buffer = new ArrayBuffer(ctx.numPoints * 4 * 3);\\\\r\\\\n    const normals = new Float32Array(buffer);\\\\r\\\\n    for (let j = 0; j < ctx.numPoints; j++) {\\\\r\\\\n        const x = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 0);\\\\r\\\\n        const y = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 4);\\\\r\\\\n        const z = ctx.data.getFloat32(ctx.currentOffset + j * ctx.pointAttributes.byteSize + 8);\\\\r\\\\n        normals[3 * j + 0] = x;\\\\r\\\\n        normals[3 * j + 1] = y;\\\\r\\\\n        normals[3 * j + 2] = z;\\\\r\\\\n    }\\\\r\\\\n    return { buffer, attribute };\\\\r\\\\n}\\\\r\\\\n\\\\n;// CONCATENATED MODULE: ./node_modules/babel-loader/lib/index.js!./src/workers/binary-decoder.worker.js\\\\n\\\\n\\\\n/*eslint-disable */\\\\nonmessage = handleMessage;//# sourceURL=[module]\\\\n\')}},__webpack_exports__={};__webpack_modules__[717]()})();", "Worker", undefined, undefined);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3RyZWUvLi9zcmMvd29ya2Vycy9iaW5hcnktZGVjb2Rlci53b3JrZXIuanM/YzYyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB3b3JrZXIgZnJvbSBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL3dvcmtlci1sb2FkZXIvZGlzdC9ydW50aW1lL2lubGluZS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXb3JrZXJfZm4oKSB7XG4gIHJldHVybiB3b3JrZXIoXCIoKCk9PntcXFwidXNlIHN0cmljdFxcXCI7dmFyIF9fd2VicGFja19tb2R1bGVzX189ezcxNzooKT0+e2V2YWwoJ1xcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BvaW50LWF0dHJpYnV0ZXMudHNcXFxcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXFxcclxcXFxuLy8gQ29udmVydGVkIHRvIFR5cGVzY3JpcHQgYW5kIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZVxcXFxyXFxcXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxcXHJcXFxcbnZhciBQb2ludEF0dHJpYnV0ZU5hbWU7XFxcXHJcXFxcbihmdW5jdGlvbiAoUG9pbnRBdHRyaWJ1dGVOYW1lKSB7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJQT1NJVElPTl9DQVJURVNJQU5cXFwiXSA9IDBdID0gXFxcIlBPU0lUSU9OX0NBUlRFU0lBTlxcXCI7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9QQUNLRURcXFwiXSA9IDFdID0gXFxcIkNPTE9SX1BBQ0tFRFxcXCI7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJDT0xPUl9GTE9BVFNfMVxcXCJdID0gMl0gPSBcXFwiQ09MT1JfRkxPQVRTXzFcXFwiO1xcXFxyXFxcXG4gICAgUG9pbnRBdHRyaWJ1dGVOYW1lW1BvaW50QXR0cmlidXRlTmFtZVtcXFwiQ09MT1JfRkxPQVRTXzI1NVxcXCJdID0gM10gPSBcXFwiQ09MT1JfRkxPQVRTXzI1NVxcXCI7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJOT1JNQUxfRkxPQVRTXFxcIl0gPSA0XSA9IFxcXCJOT1JNQUxfRkxPQVRTXFxcIjtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIkZJTExFUlxcXCJdID0gNV0gPSBcXFwiRklMTEVSXFxcIjtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIklOVEVOU0lUWVxcXCJdID0gNl0gPSBcXFwiSU5URU5TSVRZXFxcIjtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIkNMQVNTSUZJQ0FUSU9OXFxcIl0gPSA3XSA9IFxcXCJDTEFTU0lGSUNBVElPTlxcXCI7XFxcXHJcXFxcbiAgICBQb2ludEF0dHJpYnV0ZU5hbWVbUG9pbnRBdHRyaWJ1dGVOYW1lW1xcXCJOT1JNQUxfU1BIRVJFTUFQUEVEXFxcIl0gPSA4XSA9IFxcXCJOT1JNQUxfU1BIRVJFTUFQUEVEXFxcIjtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIk5PUk1BTF9PQ1QxNlxcXCJdID0gOV0gPSBcXFwiTk9STUFMX09DVDE2XFxcIjtcXFxcclxcXFxuICAgIFBvaW50QXR0cmlidXRlTmFtZVtQb2ludEF0dHJpYnV0ZU5hbWVbXFxcIk5PUk1BTFxcXCJdID0gMTBdID0gXFxcIk5PUk1BTFxcXCI7XFxcXHJcXFxcbn0pKFBvaW50QXR0cmlidXRlTmFtZSB8fCAoUG9pbnRBdHRyaWJ1dGVOYW1lID0ge30pKTtcXFxcclxcXFxuY29uc3QgUE9JTlRfQVRUUklCVVRFX1RZUEVTID0ge1xcXFxyXFxcXG4gICAgREFUQV9UWVBFX0RPVUJMRTogeyBvcmRpbmFsOiAwLCBzaXplOiA4IH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfRkxPQVQ6IHsgb3JkaW5hbDogMSwgc2l6ZTogNCB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX0lOVDg6IHsgb3JkaW5hbDogMiwgc2l6ZTogMSB9LFxcXFxyXFxcXG4gICAgREFUQV9UWVBFX1VJTlQ4OiB7IG9yZGluYWw6IDMsIHNpemU6IDEgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQxNjogeyBvcmRpbmFsOiA0LCBzaXplOiAyIH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDE2OiB7IG9yZGluYWw6IDUsIHNpemU6IDIgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQzMjogeyBvcmRpbmFsOiA2LCBzaXplOiA0IH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDMyOiB7IG9yZGluYWw6IDcsIHNpemU6IDQgfSxcXFxcclxcXFxuICAgIERBVEFfVFlQRV9JTlQ2NDogeyBvcmRpbmFsOiA4LCBzaXplOiA4IH0sXFxcXHJcXFxcbiAgICBEQVRBX1RZUEVfVUlOVDY0OiB7IG9yZGluYWw6IDksIHNpemU6IDggfSxcXFxcclxcXFxufTtcXFxcclxcXFxuZnVuY3Rpb24gbWFrZVBvaW50QXR0cmlidXRlKG5hbWUsIHR5cGUsIG51bUVsZW1lbnRzKSB7XFxcXHJcXFxcbiAgICByZXR1cm4ge1xcXFxyXFxcXG4gICAgICAgIG5hbWUsXFxcXHJcXFxcbiAgICAgICAgdHlwZSxcXFxcclxcXFxuICAgICAgICBudW1FbGVtZW50cyxcXFxcclxcXFxuICAgICAgICBieXRlU2l6ZTogbnVtRWxlbWVudHMgKiB0eXBlLnNpemUsXFxcXHJcXFxcbiAgICB9O1xcXFxyXFxcXG59XFxcXHJcXFxcbmNvbnN0IFJHQkFfUEFDS0VEID0gbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5DT0xPUl9QQUNLRUQsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfSU5UOCwgNCk7XFxcXHJcXFxcbmNvbnN0IFBPSU5UX0FUVFJJQlVURVMgPSB7XFxcXHJcXFxcbiAgICBQT1NJVElPTl9DQVJURVNJQU46IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuUE9TSVRJT05fQ0FSVEVTSUFOLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcclxcXFxuICAgIFJHQkFfUEFDS0VELFxcXFxyXFxcXG4gICAgQ09MT1JfUEFDS0VEOiBSR0JBX1BBQ0tFRCxcXFxcclxcXFxuICAgIFJHQl9QQUNLRUQ6IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0lOVDgsIDMpLFxcXFxyXFxcXG4gICAgTk9STUFMX0ZMT0FUUzogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfRkxPQVRTLCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX0ZMT0FULCAzKSxcXFxcclxcXFxuICAgIEZJTExFUl8xQjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5GSUxMRVIsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxcXFxyXFxcXG4gICAgSU5URU5TSVRZOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWSwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9VSU5UMTYsIDEpLFxcXFxyXFxcXG4gICAgQ0xBU1NJRklDQVRJT046IG1ha2VQb2ludEF0dHJpYnV0ZShQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT04sIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDEpLFxcXFxyXFxcXG4gICAgTk9STUFMX1NQSEVSRU1BUFBFRDogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfU1BIRVJFTUFQUEVELCBQT0lOVF9BVFRSSUJVVEVfVFlQRVMuREFUQV9UWVBFX1VJTlQ4LCAyKSxcXFxcclxcXFxuICAgIE5PUk1BTF9PQ1QxNjogbWFrZVBvaW50QXR0cmlidXRlKFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfT0NUMTYsIFBPSU5UX0FUVFJJQlVURV9UWVBFUy5EQVRBX1RZUEVfVUlOVDgsIDIpLFxcXFxyXFxcXG4gICAgTk9STUFMOiBtYWtlUG9pbnRBdHRyaWJ1dGUoUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTCwgUE9JTlRfQVRUUklCVVRFX1RZUEVTLkRBVEFfVFlQRV9GTE9BVCwgMyksXFxcXHJcXFxcbn07XFxcXHJcXFxcbmNsYXNzIFBvaW50QXR0cmlidXRlcyB7XFxcXHJcXFxcbiAgICBjb25zdHJ1Y3Rvcihwb2ludEF0dHJpYnV0ZU5hbWVzID0gW10pIHtcXFxcclxcXFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcXFxcclxcXFxuICAgICAgICB0aGlzLmJ5dGVTaXplID0gMDtcXFxcclxcXFxuICAgICAgICB0aGlzLnNpemUgPSAwO1xcXFxyXFxcXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRBdHRyaWJ1dGVOYW1lcy5sZW5ndGg7IGkrKykge1xcXFxyXFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZU5hbWUgPSBwb2ludEF0dHJpYnV0ZU5hbWVzW2ldO1xcXFxyXFxcXG4gICAgICAgICAgICBjb25zdCBwb2ludEF0dHJpYnV0ZSA9IFBPSU5UX0FUVFJJQlVURVNbcG9pbnRBdHRyaWJ1dGVOYW1lXTtcXFxcclxcXFxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLnB1c2gocG9pbnRBdHRyaWJ1dGUpO1xcXFxyXFxcXG4gICAgICAgICAgICB0aGlzLmJ5dGVTaXplICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxyXFxcXG4gICAgICAgICAgICB0aGlzLnNpemUrKztcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBhZGQocG9pbnRBdHRyaWJ1dGUpIHtcXFxcclxcXFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChwb2ludEF0dHJpYnV0ZSk7XFxcXHJcXFxcbiAgICAgICAgdGhpcy5ieXRlU2l6ZSArPSBwb2ludEF0dHJpYnV0ZS5ieXRlU2l6ZTtcXFxcclxcXFxuICAgICAgICB0aGlzLnNpemUrKztcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGhhc0NvbG9ycygpIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoaXNDb2xvckF0dHJpYnV0ZSkgIT09IHVuZGVmaW5lZDtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIGhhc05vcm1hbHMoKSB7XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5maW5kKGlzTm9ybWFsQXR0cmlidXRlKSAhPT0gdW5kZWZpbmVkO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcbmZ1bmN0aW9uIGlzQ29sb3JBdHRyaWJ1dGUoeyBuYW1lIH0pIHtcXFxcclxcXFxuICAgIHJldHVybiBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VEO1xcXFxyXFxcXG59XFxcXHJcXFxcbmZ1bmN0aW9uIGlzTm9ybWFsQXR0cmlidXRlKHsgbmFtZSB9KSB7XFxcXHJcXFxcbiAgICByZXR1cm4gKG5hbWUgPT09IFBvaW50QXR0cmlidXRlTmFtZS5OT1JNQUxfU1BIRVJFTUFQUEVEIHx8XFxcXHJcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9GTE9BVFMgfHxcXFxcclxcXFxuICAgICAgICBuYW1lID09PSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMIHx8XFxcXHJcXFxcbiAgICAgICAgbmFtZSA9PT0gUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTF9PQ1QxNik7XFxcXHJcXFxcbn1cXFxcclxcXFxuXFxcXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvdmVyc2lvbi50c1xcXFxuY2xhc3MgVmVyc2lvbiB7XFxcXHJcXFxcbiAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uKSB7XFxcXHJcXFxcbiAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb247XFxcXHJcXFxcbiAgICAgICAgY29uc3Qgdm1MZW5ndGggPSB2ZXJzaW9uLmluZGV4T2YoXFxcXCcuXFxcXCcpID09PSAtMSA/IHZlcnNpb24ubGVuZ3RoIDogdmVyc2lvbi5pbmRleE9mKFxcXFwnLlxcXFwnKTtcXFxcclxcXFxuICAgICAgICB0aGlzLnZlcnNpb25NYWpvciA9IHBhcnNlSW50KHZlcnNpb24uc3Vic3RyKDAsIHZtTGVuZ3RoKSwgMTApO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudmVyc2lvbk1pbm9yID0gcGFyc2VJbnQodmVyc2lvbi5zdWJzdHIodm1MZW5ndGggKyAxKSwgMTApO1xcXFxyXFxcXG4gICAgICAgIGlmIChpc05hTih0aGlzLnZlcnNpb25NaW5vcikpIHtcXFxcclxcXFxuICAgICAgICAgICAgdGhpcy52ZXJzaW9uTWlub3IgPSAwO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIG5ld2VyVGhhbih2ZXJzaW9uKSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgdiA9IG5ldyBWZXJzaW9uKHZlcnNpb24pO1xcXFxyXFxcXG4gICAgICAgIGlmICh0aGlzLnZlcnNpb25NYWpvciA+IHYudmVyc2lvbk1ham9yKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcXFxyXFxcXG4gICAgICAgIH1cXFxcclxcXFxuICAgICAgICBlbHNlIGlmICh0aGlzLnZlcnNpb25NYWpvciA9PT0gdi52ZXJzaW9uTWFqb3IgJiYgdGhpcy52ZXJzaW9uTWlub3IgPiB2LnZlcnNpb25NaW5vcikge1xcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBlcXVhbE9ySGlnaGVyKHZlcnNpb24pIHtcXFxcclxcXFxuICAgICAgICBjb25zdCB2ID0gbmV3IFZlcnNpb24odmVyc2lvbik7XFxcXHJcXFxcbiAgICAgICAgaWYgKHRoaXMudmVyc2lvbk1ham9yID4gdi52ZXJzaW9uTWFqb3IpIHtcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGVsc2UgaWYgKHRoaXMudmVyc2lvbk1ham9yID09PSB2LnZlcnNpb25NYWpvciAmJiB0aGlzLnZlcnNpb25NaW5vciA+PSB2LnZlcnNpb25NaW5vcikge1xcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICB1cFRvKHZlcnNpb24pIHtcXFxcclxcXFxuICAgICAgICByZXR1cm4gIXRoaXMubmV3ZXJUaGFuKHZlcnNpb24pO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3dvcmtlcnMvY3VzdG9tLWFycmF5LXZpZXcudHNcXFxcbi8qKlxcXFxyXFxcXG4gKiBBZGFwdGVkIGZyb20gUG90cmVlLmpzIGh0dHA6Ly9wb3RyZWUub3JnXFxcXHJcXFxcbiAqIFBvdHJlZSBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vcG90cmVlL3BvdHJlZS9ibG9iLzEuNS9MSUNFTlNFXFxcXHJcXFxcbiAqL1xcXFxyXFxcXG4vLyBodHRwOi8vanNwZXJmLmNvbS91aW50OGFycmF5LXZzLWRhdGF2aWV3My8zXFxcXHJcXFxcbi8vIHRzbGludDpkaXNhYmxlOm5vLWJpdHdpc2VcXFxcclxcXFxuY2xhc3MgQ3VzdG9tQXJyYXlWaWV3IHtcXFxcclxcXFxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xcXFxyXFxcXG4gICAgICAgIHRoaXMudG1wID0gbmV3IEFycmF5QnVmZmVyKDQpO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudG1wZiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy50bXApO1xcXFxyXFxcXG4gICAgICAgIHRoaXMudG1wdTggPSBuZXcgVWludDhBcnJheSh0aGlzLnRtcCk7XFxcXHJcXFxcbiAgICAgICAgdGhpcy51OCA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBnZXRVaW50MzIoaSkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgM10gPDwgMjQpIHwgKHRoaXMudThbaSArIDJdIDw8IDE2KSB8ICh0aGlzLnU4W2kgKyAxXSA8PCA4KSB8IHRoaXMudThbaV07XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICBnZXRVaW50MTYoaSkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiAodGhpcy51OFtpICsgMV0gPDwgOCkgfCB0aGlzLnU4W2ldO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZ2V0RmxvYXQzMihpKSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgdG1wdTggPSB0aGlzLnRtcHU4O1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHU4ID0gdGhpcy51ODtcXFxcclxcXFxuICAgICAgICBjb25zdCB0bXBmID0gdGhpcy50bXBmO1xcXFxyXFxcXG4gICAgICAgIHRtcHU4WzBdID0gdThbaSArIDBdO1xcXFxyXFxcXG4gICAgICAgIHRtcHU4WzFdID0gdThbaSArIDFdO1xcXFxyXFxcXG4gICAgICAgIHRtcHU4WzJdID0gdThbaSArIDJdO1xcXFxyXFxcXG4gICAgICAgIHRtcHU4WzNdID0gdThbaSArIDNdO1xcXFxyXFxcXG4gICAgICAgIHJldHVybiB0bXBmWzBdO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgZ2V0VWludDgoaSkge1xcXFxyXFxcXG4gICAgICAgIHJldHVybiB0aGlzLnU4W2ldO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG59XFxcXHJcXFxcbi8vIHRzbGludDplbmFibGU6bm8tYml0d2lzZVxcXFxyXFxcXG5cXFxcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3NyYy93b3JrZXJzL2JpbmFyeS1kZWNvZGVyLXdvcmtlci1pbnRlcm5hbC50c1xcXFxuLyoqXFxcXHJcXFxcbiAqIEFkYXB0ZWQgZnJvbSBQb3RyZWUuanMgaHR0cDovL3BvdHJlZS5vcmdcXFxcclxcXFxuICogUG90cmVlIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9wb3RyZWUvcG90cmVlL2Jsb2IvMS41L0xJQ0VOU0VcXFxcclxcXFxuICovXFxcXHJcXFxcblxcXFxyXFxcXG5cXFxcclxcXFxuXFxcXHJcXFxcbi8vIElFMTEgZG9lcyBub3QgaGF2ZSBNYXRoLnNpZ24oKSwgdGhpcyBoYXMgYmVlbiBhZGFwdGVkIGZyb20gQ29yZUpTIGVzNi5tYXRoLnNpZ24uanMgZm9yIFR5cGVTY3JpcHRcXFxcclxcXFxuY29uc3QgbWF0aFNpZ24gPSBNYXRoLnNpZ24gfHxcXFxcclxcXFxuICAgIGZ1bmN0aW9uICh4KSB7XFxcXHJcXFxcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnRyaXBsZS1lcXVhbHNcXFxcclxcXFxuICAgICAgICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XFxcXHJcXFxcbiAgICB9O1xcXFxyXFxcXG5mdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XFxcXHJcXFxcbiAgICBjb25zdCBidWZmZXIgPSBldmVudC5kYXRhLmJ1ZmZlcjtcXFxcclxcXFxuICAgIGNvbnN0IHBvaW50QXR0cmlidXRlcyA9IGV2ZW50LmRhdGEucG9pbnRBdHRyaWJ1dGVzO1xcXFxyXFxcXG4gICAgY29uc3QgY3R4ID0ge1xcXFxyXFxcXG4gICAgICAgIGF0dHJpYnV0ZUJ1ZmZlcnM6IHt9LFxcXFxyXFxcXG4gICAgICAgIGN1cnJlbnRPZmZzZXQ6IDAsXFxcXHJcXFxcbiAgICAgICAgZGF0YTogbmV3IEN1c3RvbUFycmF5VmlldyhidWZmZXIpLFxcXFxyXFxcXG4gICAgICAgIG1lYW46IFswLCAwLCAwXSxcXFxcclxcXFxuICAgICAgICBub2RlT2Zmc2V0OiBldmVudC5kYXRhLm9mZnNldCxcXFxcclxcXFxuICAgICAgICBudW1Qb2ludHM6IGV2ZW50LmRhdGEuYnVmZmVyLmJ5dGVMZW5ndGggLyBwb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUsXFxcXHJcXFxcbiAgICAgICAgcG9pbnRBdHRyaWJ1dGVzLFxcXFxyXFxcXG4gICAgICAgIHNjYWxlOiBldmVudC5kYXRhLnNjYWxlLFxcXFxyXFxcXG4gICAgICAgIHRpZ2h0Qm94TWF4OiBbTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXFxcXHJcXFxcbiAgICAgICAgdGlnaHRCb3hNaW46IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcXFxcclxcXFxuICAgICAgICB0cmFuc2ZlcmFibGVzOiBbXSxcXFxcclxcXFxuICAgICAgICB2ZXJzaW9uOiBuZXcgVmVyc2lvbihldmVudC5kYXRhLnZlcnNpb24pLFxcXFxyXFxcXG4gICAgfTtcXFxcclxcXFxuICAgIGZvciAoY29uc3QgcG9pbnRBdHRyaWJ1dGUgb2YgY3R4LnBvaW50QXR0cmlidXRlcy5hdHRyaWJ1dGVzKSB7XFxcXHJcXFxcbiAgICAgICAgZGVjb2RlQW5kQWRkQXR0cmlidXRlKHBvaW50QXR0cmlidXRlLCBjdHgpO1xcXFxyXFxcXG4gICAgICAgIGN0eC5jdXJyZW50T2Zmc2V0ICs9IHBvaW50QXR0cmlidXRlLmJ5dGVTaXplO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXHJcXFxcbiAgICBjb25zdCBpSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShpbmRpY2VzKTtcXFxcclxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lm51bVBvaW50czsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgaUluZGljZXNbaV0gPSBpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgaWYgKCFjdHguYXR0cmlidXRlQnVmZmVyc1tQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT05dKSB7XFxcXHJcXFxcbiAgICAgICAgYWRkRW1wdHlDbGFzc2lmaWNhdGlvbkJ1ZmZlcihjdHgpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY29uc3QgbWVzc2FnZSA9IHtcXFxcclxcXFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcXFxcclxcXFxuICAgICAgICBtZWFuOiBjdHgubWVhbixcXFxcclxcXFxuICAgICAgICBhdHRyaWJ1dGVCdWZmZXJzOiBjdHguYXR0cmlidXRlQnVmZmVycyxcXFxcclxcXFxuICAgICAgICB0aWdodEJvdW5kaW5nQm94OiB7IG1pbjogY3R4LnRpZ2h0Qm94TWluLCBtYXg6IGN0eC50aWdodEJveE1heCB9LFxcXFxyXFxcXG4gICAgICAgIGluZGljZXMsXFxcXHJcXFxcbiAgICB9O1xcXFxyXFxcXG4gICAgcG9zdE1lc3NhZ2UobWVzc2FnZSwgY3R4LnRyYW5zZmVyYWJsZXMpO1xcXFxyXFxcXG59XFxcXHJcXFxcbmZ1bmN0aW9uIGFkZEVtcHR5Q2xhc3NpZmljYXRpb25CdWZmZXIoY3R4KSB7XFxcXHJcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQpO1xcXFxyXFxcXG4gICAgY29uc3QgY2xhc3NpZmljYXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xcXFxyXFxcXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdHgubnVtUG9pbnRzOyBpKyspIHtcXFxcclxcXFxuICAgICAgICBjbGFzc2lmaWNhdGlvbnNbaV0gPSAwO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY3R4LmF0dHJpYnV0ZUJ1ZmZlcnNbUG9pbnRBdHRyaWJ1dGVOYW1lLkNMQVNTSUZJQ0FUSU9OXSA9IHtcXFxcclxcXFxuICAgICAgICBidWZmZXIsXFxcXHJcXFxcbiAgICAgICAgYXR0cmlidXRlOiBQT0lOVF9BVFRSSUJVVEVTLkNMQVNTSUZJQ0FUSU9OLFxcXFxyXFxcXG4gICAgfTtcXFxcclxcXFxufVxcXFxyXFxcXG5mdW5jdGlvbiBkZWNvZGVBbmRBZGRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjdHgpIHtcXFxcclxcXFxuICAgIGNvbnN0IGRlY29kZWRBdHRyaWJ1dGUgPSBkZWNvZGVQb2ludEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICBpZiAoZGVjb2RlZEF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkKSB7XFxcXHJcXFxcbiAgICAgICAgcmV0dXJuO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgY3R4LmF0dHJpYnV0ZUJ1ZmZlcnNbZGVjb2RlZEF0dHJpYnV0ZS5hdHRyaWJ1dGUubmFtZV0gPSBkZWNvZGVkQXR0cmlidXRlO1xcXFxyXFxcXG4gICAgY3R4LnRyYW5zZmVyYWJsZXMucHVzaChkZWNvZGVkQXR0cmlidXRlLmJ1ZmZlcik7XFxcXHJcXFxcbn1cXFxcclxcXFxuZnVuY3Rpb24gZGVjb2RlUG9pbnRBdHRyaWJ1dGUoYXR0cmlidXRlLCBjdHgpIHtcXFxcclxcXFxuICAgIHN3aXRjaCAoYXR0cmlidXRlLm5hbWUpIHtcXFxcclxcXFxuICAgICAgICBjYXNlIFBvaW50QXR0cmlidXRlTmFtZS5QT1NJVElPTl9DQVJURVNJQU46XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVQb3NpdGlvbkNhcnRlc2lhbihhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuQ09MT1JfUEFDS0VEOlxcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlQ29sb3IoYXR0cmlidXRlLCBjdHgpO1xcXFxyXFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLklOVEVOU0lUWTpcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUludGVuc2l0eShhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuQ0xBU1NJRklDQVRJT046XFxcXHJcXFxcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVDbGFzc2lmaWNhdGlvbihhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX1NQSEVSRU1BUFBFRDpcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbFNwaGVyZU1hcHBlZChhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICAgICAgY2FzZSBQb2ludEF0dHJpYnV0ZU5hbWUuTk9STUFMX09DVDE2OlxcXFxyXFxcXG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlTm9ybWFsT2N0MTYoYXR0cmlidXRlLCBjdHgpO1xcXFxyXFxcXG4gICAgICAgIGNhc2UgUG9pbnRBdHRyaWJ1dGVOYW1lLk5PUk1BTDpcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5vcm1hbChhdHRyaWJ1dGUsIGN0eCk7XFxcXHJcXFxcbiAgICAgICAgZGVmYXVsdDpcXFxcclxcXFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxufVxcXFxyXFxcXG5mdW5jdGlvbiBkZWNvZGVQb3NpdGlvbkNhcnRlc2lhbihhdHRyaWJ1dGUsIGN0eCkge1xcXFxyXFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXHJcXFxcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5udW1Qb2ludHM7IGkrKykge1xcXFxyXFxcXG4gICAgICAgIGxldCB4O1xcXFxyXFxcXG4gICAgICAgIGxldCB5O1xcXFxyXFxcXG4gICAgICAgIGxldCB6O1xcXFxyXFxcXG4gICAgICAgIGlmIChjdHgudmVyc2lvbi5uZXdlclRoYW4oXFxcXCcxLjNcXFxcJykpIHtcXFxcclxcXFxuICAgICAgICAgICAgeCA9IGN0eC5kYXRhLmdldFVpbnQzMihjdHguY3VycmVudE9mZnNldCArIGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCkgKiBjdHguc2NhbGU7XFxcXHJcXFxcbiAgICAgICAgICAgIHkgPSBjdHguZGF0YS5nZXRVaW50MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDQpICogY3R4LnNjYWxlO1xcXFxyXFxcXG4gICAgICAgICAgICB6ID0gY3R4LmRhdGEuZ2V0VWludDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA4KSAqIGN0eC5zY2FsZTtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHggPSBjdHguZGF0YS5nZXRGbG9hdDMyKGkgKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCkgKyBjdHgubm9kZU9mZnNldFswXTtcXFxcclxcXFxuICAgICAgICAgICAgeSA9IGN0eC5kYXRhLmdldEZsb2F0MzIoaSAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA0KSArIGN0eC5ub2RlT2Zmc2V0WzFdO1xcXFxyXFxcXG4gICAgICAgICAgICB6ID0gY3R4LmRhdGEuZ2V0RmxvYXQzMihpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDgpICsgY3R4Lm5vZGVPZmZzZXRbMl07XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIHBvc2l0aW9uc1szICogaSArIDBdID0geDtcXFxcclxcXFxuICAgICAgICBwb3NpdGlvbnNbMyAqIGkgKyAxXSA9IHk7XFxcXHJcXFxcbiAgICAgICAgcG9zaXRpb25zWzMgKiBpICsgMl0gPSB6O1xcXFxyXFxcXG4gICAgICAgIGN0eC5tZWFuWzBdICs9IHggLyBjdHgubnVtUG9pbnRzO1xcXFxyXFxcXG4gICAgICAgIGN0eC5tZWFuWzFdICs9IHkgLyBjdHgubnVtUG9pbnRzO1xcXFxyXFxcXG4gICAgICAgIGN0eC5tZWFuWzJdICs9IHogLyBjdHgubnVtUG9pbnRzO1xcXFxyXFxcXG4gICAgICAgIGN0eC50aWdodEJveE1pblswXSA9IE1hdGgubWluKGN0eC50aWdodEJveE1pblswXSwgeCk7XFxcXHJcXFxcbiAgICAgICAgY3R4LnRpZ2h0Qm94TWluWzFdID0gTWF0aC5taW4oY3R4LnRpZ2h0Qm94TWluWzFdLCB5KTtcXFxcclxcXFxuICAgICAgICBjdHgudGlnaHRCb3hNaW5bMl0gPSBNYXRoLm1pbihjdHgudGlnaHRCb3hNaW5bMl0sIHopO1xcXFxyXFxcXG4gICAgICAgIGN0eC50aWdodEJveE1heFswXSA9IE1hdGgubWF4KGN0eC50aWdodEJveE1heFswXSwgeCk7XFxcXHJcXFxcbiAgICAgICAgY3R4LnRpZ2h0Qm94TWF4WzFdID0gTWF0aC5tYXgoY3R4LnRpZ2h0Qm94TWF4WzFdLCB5KTtcXFxcclxcXFxuICAgICAgICBjdHgudGlnaHRCb3hNYXhbMl0gPSBNYXRoLm1heChjdHgudGlnaHRCb3hNYXhbMl0sIHopO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgcmV0dXJuIHsgYnVmZmVyLCBhdHRyaWJ1dGUgfTtcXFxcclxcXFxufVxcXFxyXFxcXG5mdW5jdGlvbiBkZWNvZGVDb2xvcihhdHRyaWJ1dGUsIGN0eCkge1xcXFxyXFxcXG4gICAgY29uc3QgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiAzKTtcXFxcclxcXFxuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XFxcXHJcXFxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN0eC5udW1Qb2ludHM7IGkrKykge1xcXFxyXFxcXG4gICAgICAgIGNvbG9yc1szICogaSArIDBdID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApO1xcXFxyXFxcXG4gICAgICAgIGNvbG9yc1szICogaSArIDFdID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDEpO1xcXFxyXFxcXG4gICAgICAgIGNvbG9yc1szICogaSArIDJdID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDIpO1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgcmV0dXJuIHsgYnVmZmVyLCBhdHRyaWJ1dGUgfTtcXFxcclxcXFxufVxcXFxyXFxcXG5mdW5jdGlvbiBkZWNvZGVJbnRlbnNpdHkoYXR0cmlidXRlLCBjdHgpIHtcXFxcclxcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCk7XFxcXHJcXFxcbiAgICBjb25zdCBpbnRlbnNpdGllcyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcclxcXFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3R4Lm51bVBvaW50czsgaSsrKSB7XFxcXHJcXFxcbiAgICAgICAgaW50ZW5zaXRpZXNbaV0gPSBjdHguZGF0YS5nZXRVaW50MTYoY3R4LmN1cnJlbnRPZmZzZXQgKyBpICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSk7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxyXFxcXG59XFxcXHJcXFxcbmZ1bmN0aW9uIGRlY29kZUNsYXNzaWZpY2F0aW9uKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXHJcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyk7XFxcXHJcXFxcbiAgICBjb25zdCBjbGFzc2lmaWNhdGlvbnMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xcXFxyXFxcXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdHgubnVtUG9pbnRzOyBqKyspIHtcXFxcclxcXFxuICAgICAgICBjbGFzc2lmaWNhdGlvbnNbal0gPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplKTtcXFxcclxcXFxuICAgIH1cXFxcclxcXFxuICAgIHJldHVybiB7IGJ1ZmZlciwgYXR0cmlidXRlIH07XFxcXHJcXFxcbn1cXFxcclxcXFxuZnVuY3Rpb24gZGVjb2RlTm9ybWFsU3BoZXJlTWFwcGVkKGF0dHJpYnV0ZSwgY3R4KSB7XFxcXHJcXFxcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoY3R4Lm51bVBvaW50cyAqIDQgKiAzKTtcXFxcclxcXFxuICAgIGNvbnN0IG5vcm1hbHMgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XFxcXHJcXFxcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGN0eC5udW1Qb2ludHM7IGorKykge1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGJ4ID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBqICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApO1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGJ5ID0gY3R4LmRhdGEuZ2V0VWludDgoY3R4LmN1cnJlbnRPZmZzZXQgKyBqICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDEpO1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGV4ID0gYnggLyAyNTU7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgZXkgPSBieSAvIDI1NTtcXFxcclxcXFxuICAgICAgICBsZXQgbnggPSBleCAqIDIgLSAxO1xcXFxyXFxcXG4gICAgICAgIGxldCBueSA9IGV5ICogMiAtIDE7XFxcXHJcXFxcbiAgICAgICAgbGV0IG56ID0gMTtcXFxcclxcXFxuICAgICAgICBjb25zdCBudyA9IC0xO1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IGwgPSBueCAqIC1ueCArIG55ICogLW55ICsgbnogKiAtbnc7XFxcXHJcXFxcbiAgICAgICAgbnogPSBsO1xcXFxyXFxcXG4gICAgICAgIG54ID0gbnggKiBNYXRoLnNxcnQobCk7XFxcXHJcXFxcbiAgICAgICAgbnkgPSBueSAqIE1hdGguc3FydChsKTtcXFxcclxcXFxuICAgICAgICBueCA9IG54ICogMjtcXFxcclxcXFxuICAgICAgICBueSA9IG55ICogMjtcXFxcclxcXFxuICAgICAgICBueiA9IG56ICogMiAtIDE7XFxcXHJcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDBdID0gbng7XFxcXHJcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDFdID0gbnk7XFxcXHJcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDJdID0gbno7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxyXFxcXG59XFxcXHJcXFxcbmZ1bmN0aW9uIGRlY29kZU5vcm1hbE9jdDE2KGF0dHJpYnV0ZSwgY3R4KSB7XFxcXHJcXFxcbiAgICBjb25zdCBidWZmID0gbmV3IEFycmF5QnVmZmVyKGN0eC5udW1Qb2ludHMgKiA0ICogMyk7XFxcXHJcXFxcbiAgICBjb25zdCBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShidWZmKTtcXFxcclxcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgYnggPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMCk7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgYnkgPSBjdHguZGF0YS5nZXRVaW50OChjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgMSk7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgdSA9IChieCAvIDI1NSkgKiAyIC0gMTtcXFxcclxcXFxuICAgICAgICBjb25zdCB2ID0gKGJ5IC8gMjU1KSAqIDIgLSAxO1xcXFxyXFxcXG4gICAgICAgIGxldCB6ID0gMSAtIE1hdGguYWJzKHUpIC0gTWF0aC5hYnModik7XFxcXHJcXFxcbiAgICAgICAgbGV0IHggPSAwO1xcXFxyXFxcXG4gICAgICAgIGxldCB5ID0gMDtcXFxcclxcXFxuICAgICAgICBpZiAoeiA+PSAwKSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHggPSB1O1xcXFxyXFxcXG4gICAgICAgICAgICB5ID0gdjtcXFxcclxcXFxuICAgICAgICB9XFxcXHJcXFxcbiAgICAgICAgZWxzZSB7XFxcXHJcXFxcbiAgICAgICAgICAgIHggPSAtKHYgLyBtYXRoU2lnbih2KSAtIDEpIC8gbWF0aFNpZ24odSk7XFxcXHJcXFxcbiAgICAgICAgICAgIHkgPSAtKHUgLyBtYXRoU2lnbih1KSAtIDEpIC8gbWF0aFNpZ24odik7XFxcXHJcXFxcbiAgICAgICAgfVxcXFxyXFxcXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xcXFxyXFxcXG4gICAgICAgIHggPSB4IC8gbGVuZ3RoO1xcXFxyXFxcXG4gICAgICAgIHkgPSB5IC8gbGVuZ3RoO1xcXFxyXFxcXG4gICAgICAgIHogPSB6IC8gbGVuZ3RoO1xcXFxyXFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAwXSA9IHg7XFxcXHJcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDFdID0geTtcXFxcclxcXFxuICAgICAgICBub3JtYWxzWzMgKiBqICsgMl0gPSB6O1xcXFxyXFxcXG4gICAgfVxcXFxyXFxcXG4gICAgcmV0dXJuIHsgYnVmZmVyOiBidWZmLCBhdHRyaWJ1dGUgfTtcXFxcclxcXFxufVxcXFxyXFxcXG5mdW5jdGlvbiBkZWNvZGVOb3JtYWwoYXR0cmlidXRlLCBjdHgpIHtcXFxcclxcXFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihjdHgubnVtUG9pbnRzICogNCAqIDMpO1xcXFxyXFxcXG4gICAgY29uc3Qgbm9ybWFscyA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcXFxcclxcXFxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3R4Lm51bVBvaW50czsgaisrKSB7XFxcXHJcXFxcbiAgICAgICAgY29uc3QgeCA9IGN0eC5kYXRhLmdldEZsb2F0MzIoY3R4LmN1cnJlbnRPZmZzZXQgKyBqICogY3R4LnBvaW50QXR0cmlidXRlcy5ieXRlU2l6ZSArIDApO1xcXFxyXFxcXG4gICAgICAgIGNvbnN0IHkgPSBjdHguZGF0YS5nZXRGbG9hdDMyKGN0eC5jdXJyZW50T2Zmc2V0ICsgaiAqIGN0eC5wb2ludEF0dHJpYnV0ZXMuYnl0ZVNpemUgKyA0KTtcXFxcclxcXFxuICAgICAgICBjb25zdCB6ID0gY3R4LmRhdGEuZ2V0RmxvYXQzMihjdHguY3VycmVudE9mZnNldCArIGogKiBjdHgucG9pbnRBdHRyaWJ1dGVzLmJ5dGVTaXplICsgOCk7XFxcXHJcXFxcbiAgICAgICAgbm9ybWFsc1szICogaiArIDBdID0geDtcXFxcclxcXFxuICAgICAgICBub3JtYWxzWzMgKiBqICsgMV0gPSB5O1xcXFxyXFxcXG4gICAgICAgIG5vcm1hbHNbMyAqIGogKyAyXSA9IHo7XFxcXHJcXFxcbiAgICB9XFxcXHJcXFxcbiAgICByZXR1cm4geyBidWZmZXIsIGF0dHJpYnV0ZSB9O1xcXFxyXFxcXG59XFxcXHJcXFxcblxcXFxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi9zcmMvd29ya2Vycy9iaW5hcnktZGVjb2Rlci53b3JrZXIuanNcXFxcblxcXFxuXFxcXG4vKmVzbGludC1kaXNhYmxlICovXFxcXG5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlOy8vIyBzb3VyY2VVUkw9W21vZHVsZV1cXFxcbicpfX0sX193ZWJwYWNrX2V4cG9ydHNfXz17fTtfX3dlYnBhY2tfbW9kdWxlc19fWzcxN10oKX0pKCk7XCIsIFwiV29ya2VyXCIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91\n')},512:module=>{eval('\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor]("data:application/javascript,".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error("Inline worker is not supported");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3BvdHJlZS8uL25vZGVfbW9kdWxlcy93b3JrZXItbG9hZGVyL2Rpc3QvcnVudGltZS9pbmxpbmUuanM/ZWNkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmLCBuby11c2UtYmVmb3JlLWRlZmluZSwgbmV3LWNhcCAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGVudCwgd29ya2VyQ29uc3RydWN0b3IsIHdvcmtlck9wdGlvbnMsIHVybCkge1xuICB2YXIgZ2xvYmFsU2NvcGUgPSBzZWxmIHx8IHdpbmRvdztcblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgYmxvYjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTmV3IEFQSVxuICAgICAgICBibG9iID0gbmV3IGdsb2JhbFNjb3BlLkJsb2IoW2NvbnRlbnRdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gQmxvYkJ1aWxkZXIgPSBEZXByZWNhdGVkLCBidXQgd2lkZWx5IGltcGxlbWVudGVkXG4gICAgICAgIHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbFNjb3BlLkJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLldlYktpdEJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1vekJsb2JCdWlsZGVyIHx8IGdsb2JhbFNjb3BlLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgIGJsb2IgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgICAgICAgYmxvYi5hcHBlbmQoY29udGVudCk7XG4gICAgICAgIGJsb2IgPSBibG9iLmdldEJsb2IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFVSTCA9IGdsb2JhbFNjb3BlLlVSTCB8fCBnbG9iYWxTY29wZS53ZWJraXRVUkw7XG4gICAgICB2YXIgb2JqZWN0VVJMID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIHZhciB3b3JrZXIgPSBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKG9iamVjdFVSTCwgd29ya2VyT3B0aW9ucyk7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKG9iamVjdFVSTCk7XG4gICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsU2NvcGVbd29ya2VyQ29uc3RydWN0b3JdKFwiZGF0YTphcHBsaWNhdGlvbi9qYXZhc2NyaXB0LFwiLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoY29udGVudCkpLCB3b3JrZXJPcHRpb25zKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbmxpbmUgd29ya2VyIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBnbG9iYWxTY29wZVt3b3JrZXJDb25zdHJ1Y3Rvcl0odXJsLCB3b3JrZXJPcHRpb25zKTtcbiAgfVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///512\n')},604:g=>{g.exports=__WEBPACK_EXTERNAL_MODULE__604__}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var t=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](t,t.exports,__webpack_require__),t.exports}__webpack_require__.n=g=>{var I=g&&g.__esModule?()=>g.default:()=>g;return __webpack_require__.d(I,{a:I}),I},__webpack_require__.d=(g,I)=>{for(var t in I)__webpack_require__.o(I,t)&&!__webpack_require__.o(g,t)&&Object.defineProperty(g,t,{enumerable:!0,get:I[t]})},__webpack_require__.o=(g,I)=>Object.prototype.hasOwnProperty.call(g,I),__webpack_require__.r=g=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(238);return __webpack_exports__})()));
\ No newline at end of file
diff --git a/package.json b/package.json
index ac72867527bc13123bf44223c334028ef0b3653c..1f5bcc207073c1dba4e6d321c1d472676c2dbea3 100644
--- a/package.json
+++ b/package.json
@@ -27,13 +27,13 @@
   },
   "dependencies": {},
   "peerDependencies": {
-    "three": "~0.160.0"
+    "three": ">=0.160.0"
   },
   "devDependencies": {
     "@babel/core": "^7.17.8",
     "@babel/preset-env": "^7.16.11",
     "@types/node": "^17.0.23",
-    "@types/three": "~0.160.0",
+    "@types/three": "^0.160.0",
     "babel-core": "^6.26.3",
     "babel-loader": "^8.2.4",
     "babel-preset-env": "^1.7.0",
@@ -48,7 +48,7 @@
     "size-plugin": "^3.0.0",
     "standard-version": "^9.3.2",
     "style-loader": "^3.3.1",
-    "three": "~0.160.0",
+    "three": "^0.160.0",
     "ts-loader": "^9.4.2",
     "tslint": "^6.1.3",
     "typescript": "^4.6.3",
diff --git a/src/materials/clipping.ts b/src/materials/clipping.ts
index 9caad1f565077fc64e069237bf4bd1a41993e656..033c35cb70eac68ee4fe7ad3acad714f1d84b96d 100644
--- a/src/materials/clipping.ts
+++ b/src/materials/clipping.ts
@@ -1,4 +1,4 @@
-import { Box3, Matrix4, Vector3 } from 'three';
+import { Box3, Color, Matrix4, Vector3 } from 'three';
 
 export enum ClipMode {
   DISABLED = 0,
@@ -13,4 +13,5 @@ export interface IClipBox {
   inverse: Matrix4;
   matrix: Matrix4;
   position: Vector3;
+  color?: Color
 }
diff --git a/src/materials/point-cloud-material.ts b/src/materials/point-cloud-material.ts
index a580d87beabb3c68ef417412a6511070aa86c77a..57f9ed4086e192212716735f470733f2d7739d4f 100644
--- a/src/materials/point-cloud-material.ts
+++ b/src/materials/point-cloud-material.ts
@@ -62,6 +62,7 @@ export interface IPointCloudMaterialUniforms {
   classificationLUT: IUniform<Texture>;
   clipBoxCount: IUniform<number>;
   clipBoxes: IUniform<Float32Array>;
+  clipHighlightColors: IUniform<Float32Array>;
   clipExtent: IUniform<[number, number, number, number]>;
   depthMap: IUniform<Texture | null>;
   diffuse: IUniform<[number, number, number]>;
@@ -194,6 +195,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
     classificationLUT: makeUniform('t', this.classificationTexture || new Texture()),
     clipBoxCount: makeUniform('f', 0),
     clipBoxes: makeUniform('Matrix4fv', [] as any),
+    clipHighlightColors: makeUniform('fv', new Float32Array()),
     clipExtent: makeUniform('fv', [0.0, 0.0, 1.0, 1.0] as [number, number, number, number]),
     depthMap: makeUniform('t', null),
     diffuse: makeUniform('fv', [1, 1, 1] as [number, number, number]),
@@ -503,9 +505,13 @@ export class PointCloudMaterial extends RawShaderMaterial {
 
     const clipBoxesLength = this.numClipBoxes * 16;
     const clipBoxesArray = new Float32Array(clipBoxesLength);
+    
+    const clipColorsLength = this.numClipBoxes * 3;
+    const clipColorsArray = new Float32Array(clipColorsLength);
 
     for (let i = 0; i < this.numClipBoxes; i++) {
       clipBoxesArray.set(clipBoxes[i].inverse.elements, 16 * i);
+      clipColorsArray.set((clipBoxes[i].color || this.color).toArray(), 3 * i);
     }
 
     for (let i = 0; i < clipBoxesLength; i++) {
@@ -515,6 +521,7 @@ export class PointCloudMaterial extends RawShaderMaterial {
     }
 
     this.setUniform('clipBoxes', clipBoxesArray);
+    this.setUniform('clipHighlightColors', clipColorsArray);
   }
 
   get gradient(): IGradient {
diff --git a/src/materials/shaders/pointcloud.vert b/src/materials/shaders/pointcloud.vert
index 9b759799364346dce6901cc73bee2773f5c6aabd..9136e95af7429f0381058e33917018bc3f960c26 100644
--- a/src/materials/shaders/pointcloud.vert
+++ b/src/materials/shaders/pointcloud.vert
@@ -34,6 +34,7 @@ uniform float spacing;
 
 #if defined use_clip_box
 	uniform mat4 clipBoxes[max_clip_boxes];
+	uniform vec3 clipHighlightColors[max_clip_boxes];
 #endif
 
 uniform float heightMin;
@@ -565,6 +566,7 @@ void main() {
 
 	#if defined use_clip_box
 		bool insideAny = false;
+		vec3 highlightColor = vec3(0.0);
 		for (int i = 0; i < max_clip_boxes; i++) {
 			if (i == int(clipBoxCount)) {
 				break;
@@ -575,6 +577,9 @@ void main() {
 			inside = inside && -0.5 <= clipPosition.y && clipPosition.y <= 0.5;
 			inside = inside && -0.5 <= clipPosition.z && clipPosition.z <= 0.5;
 			insideAny = insideAny || inside;
+			if (inside) {
+				highlightColor += clipHighlightColors[i].xyz;
+			}
 		}
 
 		if (!insideAny) {
@@ -585,7 +590,7 @@ void main() {
 			#endif
 		} else {
 			#if defined clip_highlight_inside
-				vColor.r += 0.5;
+				vColor.rgb += highlightColor; 
 			#endif
 		}
 	#endif
